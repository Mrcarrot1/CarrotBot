<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.ML.Data</name>
    </assembly>
    <members>
        <member name="M:Microsoft.ML.Runtime.Data.CrossValidationCommand.ApplyAllTransformsToData(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Callback from the CV method to apply the transforms from the train data to the test and/or validation data.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CrossValidationCommand.CreateRoleMappedData(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.ITrainer)">
            <summary>
            Callback from the CV method to apply the transforms to the train data.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CrossValidationCommand.FoldHelper.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.IDataView,System.String,Microsoft.ML.Runtime.Data.CrossValidationCommand.Arguments,System.Func{Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.ITrainer,Microsoft.ML.Runtime.Data.RoleMappedData},System.Func{Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.RoleMappedData},Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.RoleMappedSchema,Microsoft.ML.Runtime.Data.IDataScorerTransform},Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.Data.IMamlEvaluator},System.Func{Microsoft.ML.Runtime.Data.IDataView},System.Func{Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.RoleMappedData},Microsoft.ML.Runtime.IPredictor,System.String,Microsoft.ML.Runtime.Data.IDataLoader,System.Boolean)">
            <param name="env">The environment.</param>
            <param name="registrationName">The registration name.</param>
            <param name="inputDataView">The input data view.</param>
            <param name="splitColumn">The column to use for splitting data into folds.</param>
            <param name="args">Cross validation arguments.</param>
            <param name="createExamples">The delegate to create RoleMappedData</param>
            <param name="applyTransformsToTestData">The delegate to apply the transforms from the train pipeline to the test data</param>
            <param name="scorer">The scorer</param>
            <param name="evaluator">The evaluator</param>
            <param name="getValidationDataView">The delegate to create validation data view</param>
            <param name="applyTransformsToValidationData">The delegate to apply the transforms from the train pipeline to the validation data</param>
            <param name="inputPredictor">The input predictor, for the continue training option</param>
            <param name="cmd">The command string.</param>
            <param name="loader">Original loader so we can construct correct pipeline for model saving.</param>
            <param name="savePerInstance">Whether to produce the per-instance data view.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CrossValidationCommand.FoldHelper.GetCrossValidationTasks">
            <summary>
            Creates and runs tasks for each fold of cross validation. The split column is used to split the input data into folds.
            There are two cases:
                1. The split column is R4: in this case it assumes that the values are in the interval [0,1] and will split
                this interval into equal width folds. If the values are uniformly distributed it should result in balanced folds.
                2. The split column is key of known cardinality: will split the whole range into equal parts to form folds. If the
                keys are generated by hashing for example, it should result in balanced folds.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CrossValidationCommand.ConstructPerFoldName(System.String,System.Int32)">
            <summary>
            Take path to expected output model file and return path to output model file for specific fold.
            Example: \\share\model.zip -> \\share\model.fold001.zip
            </summary>
            <param name="outputModelFile">Path to output model file</param>
            <param name="fold">Current fold</param>
            <returns>Path to output model file for specific fold</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataCommand">
            <summary>
            This holds useful base classes for commands that ingest a primary dataset and deal with associated model files.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataCommand.ImplBase`1.#ctor(Microsoft.ML.Runtime.IHostEnvironment,`0,System.String,System.Nullable{System.Int32})">
            <summary>
            The degree of concurrency is passed in the conc parameter. If it is null, the value
            of args.parralel is used. If that is null, zero is used (which means "automatic").
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataCommand.ImplBase`1.LoadModelObjects(Microsoft.ML.Runtime.IChannel,System.Nullable{System.Boolean},Microsoft.ML.Runtime.IPredictor@,System.Boolean,Microsoft.ML.Runtime.Data.RoleMappedSchema@,Microsoft.ML.Runtime.Data.IDataLoader@)">
            <summary>
            Loads multiple artifacts of interest from the input model file, given the context
            established by the command line arguments.
            </summary>
            <param name="ch">The channel to which to provide output.</param>
            <param name="wantPredictor">Whether we want a predictor from the model file. If
            <c>false</c> we will not even attempt to load a predictor. If <c>null</c> we will
            load the predictor, if present. If <c>true</c> we will load the predictor, or fail
            noisily if we cannot.</param>
            <param name="predictor">The predictor in the model, or <c>null</c> if
            <paramref name="wantPredictor"/> was false, or <paramref name="wantPredictor"/> was
            <c>null</c> and no predictor was present.</param>
            <param name="wantTrainSchema">Whether we want the training schema. Unlike
            <paramref name="wantPredictor"/>, this has no "hard fail if not present" option. If
            this is <c>true</c>, it is still possible for <paramref name="trainSchema"/> to remain
            <c>null</c> if there were no role mappings, or pipeline.</param>
            <param name="trainSchema">The training schema if <paramref name="wantTrainSchema"/>
            is true, and there were role mappings stored in the model.</param>
            <param name="pipe">The data pipe constructed from the combination of the
            model and command line arguments.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LoaderUtils.SaveLoader(Microsoft.ML.Runtime.Data.IDataLoader,Microsoft.ML.Runtime.IFileHandle)">
            <summary>
            Saves <paramref name="loader"/> to the specified <paramref name="file"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LoaderUtils.SaveLoader(Microsoft.ML.Runtime.Data.IDataLoader,System.IO.Stream)">
            <summary>
            Saves <paramref name="loader"/> to the specified <paramref name="stream"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetricColumn">
            <summary>
            This class contains information about an overall metric, namely its name and whether it is a vector
            metric or not.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetricColumn.Objective">
            <summary>
            An enum specifying whether the metric should be maximized or minimized while sweeping. 'Info' should be
            used for metrics that are irrelevant to the model's quality (such as the number of positive/negative
            examples etc.).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IEvaluator">
            <summary>
            This is an interface for evaluation. It has two methods: <see cref="M:Microsoft.ML.Runtime.Data.IEvaluator.Evaluate(Microsoft.ML.Runtime.Data.RoleMappedData)"/> and <see cref="M:Microsoft.ML.Runtime.Data.IEvaluator.GetPerInstanceMetrics(Microsoft.ML.Runtime.Data.RoleMappedData)"/>.
            Both take a <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedData"/> as input. The <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedData"/> is assumed to contain all the column
            roles needed for evaluation, including the score column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IEvaluator.Evaluate(Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Compute the aggregate metrics. Return a dictionary from the metric kind
            (overal/per-fold/confusion matrix/PR-curves etc.), to a data view containing the metric.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IEvaluator.GetPerInstanceMetrics(Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Return an <see cref="T:Microsoft.ML.Runtime.Data.IDataTransform"/> containing the per-instance results.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IEvaluator.GetOverallMetricColumns">
            <summary>
            Get all the overall metrics returned by this evaluator.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SignatureEvaluator">
            <summary>
            Signature for creating an IEvaluator.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SignatureDataScorer">
            <summary>
            Signature for creating an <see cref="T:Microsoft.ML.Runtime.Data.IDataScorerTransform"/>.
            </summary>
            <param name="data">The data containing the columns to score</param>
            <param name="mapper">The mapper, already bound to the schema column in <paramref name="data"/></param>
            <param name="trainSchema">This parameter holds a snapshot of the role mapped training schema as
            it existed at the point when <paramref name="mapper"/> was trained, or <c>null</c> if it not
            available for some reason</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreCommand.ShouldAddColumn(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.UInt32,System.Boolean)">
            <summary>
            Whether a column should be added, assuming it's not hidden
            (i.e.: this doesn't check for hidden
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreUtils.GetScorerComponentAndMapper(Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.RoleMappedSchema,Microsoft.ML.Runtime.Data.IDataScorerTransform},Microsoft.ML.Runtime.Data.RoleMappedSchema,Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.ISchemaBindableMapper},Microsoft.ML.Runtime.Data.ISchemaBoundMapper@)">
            <summary>
            Determines the scorer component factory (if the given one is null or empty), and creates the schema bound mapper.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreUtils.GetScorerComponent(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBoundMapper,System.String)">
            <summary>
            Determine the default scorer for a schema bound mapper. This looks for text-valued ScoreColumnKind
            metadata on the first column of the mapper. If that text is found and maps to a scorer loadable class,
            that component is used. Otherwise, the GenericScorer is used.
            </summary>
            <param name="environment">The host environment.</param>.
            <param name="mapper">The schema bound mapper to get the default scorer.</param>.
            <param name="suffix">An optional suffix to append to the default column names.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreUtils.GetSchemaBindableMapper(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.ISchemaBindableMapper},Microsoft.ML.Runtime.CommandLine.ICommandLineComponentFactory)">
            <summary>
            Given a predictor, an optional mapper factory, and an optional scorer factory settings,
            produces a compatible ISchemaBindableMapper.
            First, it tries to instantiate the bindable mapper using the mapper factory.
            Next, it tries to instantiate the bindable mapper using the <paramref name="scorerFactorySettings"/>
            (this will only succeed if there's a registered BindableMapper creation method with load name equal to the one
            of the scorer).
            If the above fails, it checks whether the predictor implements <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBindableMapper"/>
            directly.
            If this also isn't true, it will create a 'matching' standard mapper.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShowSchemaCommand.RunOnData(System.IO.TextWriter,Microsoft.ML.Runtime.Data.ShowSchemaCommand.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            This shows the schema of the given <paramref name="data"/>, ignoring the data specification
            in the <paramref name="args"/> parameter. Test code invokes this, hence it is internal.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShowSchemaCommand.GetViewChainReversed(Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Returns the sequence of views passed through the transform chain, last to first.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TrainUtils.MatchNameOrDefaultOrNull(Microsoft.ML.Runtime.IExceptionContext,Microsoft.ML.Runtime.Data.ISchema,System.String,System.String,System.String)">
            <summary>
            If user name is null or empty, return null.
            Else, if the user name is found in the schema, return the user name.
            Else, if the user name equals the default name return null.
            Else, throw an error.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TrainUtils.SaveModel(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.IFileHandle,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedData,System.String)">
            <summary>
            Save the model to the output path.
            The method saves the loader and the transformations of dataPipe and saves optionally predictor
            and command. It also uses featureColumn, if provided, to extract feature names.
            </summary>
            <param name="env">The host environment to use.</param>
            <param name="ch">The communication channel to use.</param>
            <param name="output">The output file handle.</param>
            <param name="predictor">The predictor.</param>
            <param name="data">The training examples.</param>
            <param name="command">The command string.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TrainUtils.SaveModel(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,System.IO.Stream,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedData,System.String)">
            <summary>
            Save the model to the stream.
            The method saves the loader and the transformations of dataPipe and saves optionally predictor
            and command. It also uses featureColumn, if provided, to extract feature names.
            </summary>
            <param name="env">The host environment to use.</param>
            <param name="ch">The communication channel to use.</param>
            <param name="outputStream">The output model stream.</param>
            <param name="predictor">The predictor.</param>
            <param name="data">The training examples.</param>
            <param name="command">The command string.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TrainUtils.SaveDataPipe(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.RepositoryWriter,Microsoft.ML.Runtime.Data.IDataView,System.Boolean)">
            <summary>
            Save the data pipeline defined by dataPipe. If blankLoader is true or the root IDataView is not an IDataLoader,
            this persists the root as a BinaryLoader having the same schema.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TrainUtils.BacktrackPipe(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.IDataView@)">
            <summary>
            Traces back the .Source chain of the transformation pipe <paramref name="dataPipe"/> up to the moment it no longer can.
            Returns all the transforms of <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> and the first data view (a non-transform).
            </summary>
            <param name="dataPipe">The transformation pipe to traverse.</param>
            <param name="pipeStart">The beginning data view of the transform chain</param>
            <returns>The list of the transforms</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry">
            <summary>
            Each column corresponds to a table of contents entry, describing information about the column
            and how values may be extracted. For columns represented physically within the stream this will
            include its location within the stream and a codec to decode the bytestreams, and for generated
            columns procedures to create them. This structure is used both for those columns that
            we know how to access (called alive columns), and those columns we do not know how to access
            (either because the value codec or compressions scheme is unrecognized, called a dead column).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.Name">
            <summary>
            The name of the column.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.Codec">
            <summary>
            The codec we will use to read the values from the stream. This will be null if
            and only if this is a dead or generated column.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.Type">
            <summary>
            The column type of the column. This will be null if and only if this is a dead
            column.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.Compression">
            <summary>
            The compression scheme used on this column's blocks.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.RowsPerBlock">
            <summary>
            The number of rows in each block (except for the last one).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.LookupOffset">
            <summary>
            The offset into the stream where the lookup table for this column is stored.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.MetadataTocOffset">
            <summary>
            The offset into the stream where the metadata TOC entries for this column are
            stored. This will be 0 if there is no metadata for this column.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.ColumnIndex">
            <summary>
            The index of the column. Note that if there are dead columns, this value may
            differ from the corresponding column index as reported by the dataview.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.IsGenerated">
            <summary>
            Whether this is a generated column, that is, something dependent on no actual block data
            in the file.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.#ctor(Microsoft.ML.Runtime.Data.IO.BinaryLoader,System.String,Microsoft.ML.Runtime.Data.ColumnType,System.Delegate)">
            <summary>
            Constructor for a generated column, which corresponds to no column in the original file,
            and has no stored blocks associated with it. The input <paramref name="valueMapper"/> must
            be a <c>ValueMapper</c> mapping a <c>long</c> zero based row index, to some value with the
            same type as the raw type in <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetValueMapper``1">
            <summary>
            Returns the value mapper for a generated column. Only a valid call if
            <typeparamref name="T"/> is the same type as <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.RawType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetLookup">
            <summary>
            Gets an array, one for each block of this column, describing its location within the file.
            This will return null if and only if this is a generated column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetMaxBlockSizes(System.Int32@,System.Int32@)">
            <summary>
            Fetches the maximum block sizes for both the compressed and decompressed
            block sizes, for this column. If there are no blocks associated with this
            column, for whatever reason (e.g., a data view with no rows, or a generated
            column), this will return 0 in both vlaues.
            </summary>
            <param name="compressed">The maximum value of the compressed block size
            (that is, the actual size of the block in stream) among all blocks for this
            column</param>
            <param name="decompressed">The maximum value of the block size when
            decompressed among all blocks for this column</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetMetadataTocArray">
            <summary>
            Gets an array containing the metadata TOC entries. This will return null if there
            are no entries stored at all, and empty if there is metadata, but none of it was
            readable. (To inspect attributes of the unreadable metadata, if any, see
            <see cref="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetDeadMetadataTocArray"/>.) All entries will point to metadata with
            known codecs and compression schemes.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetDeadMetadataTocArray">
            <summary>
            Gets an array containing the metadata TOC entries for all "dead" pieces of metadata. This
            will return null if there are no metadata stored at all either readable or unreadable, and
            empty if there is no unreadable piece of metadata. A piece of metadata is considered "dead"
            if either its codec or compression kind is unknown. This is primarily for diagnostic purposes.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetMetadataTocEntryOrNull(System.String)">
            <summary>
            Returns the entry for a valid "live" piece of metadata given a kind.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.TableOfContentsEntry.GetMetadataTocEndOffset">
            <summary>
            Returns the location in the stream just past the end of the metadata table of contents.
            If this column has no metadata table of contents defined, this will return 0. This is
            primarily for diagnostic purposes.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataTableOfContentsEntry">
            <summary>
            A column can be associated with metadata, in which case it will have one or more table of contents entries,
            each represented by one of these entries.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataTableOfContentsEntry.Kind">
            <summary>
            The kind of the metadata, an identifying name.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataTableOfContentsEntry.Codec">
            <summary>
            The codec we will use to read the metadata value. If this is <c>null</c>,
            the metadata is considered "dead," that is, uninterpretable.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataTableOfContentsEntry.Compression">
            <summary>
            The compression scheme used on the metadata block. If this is an unknown
            type, the metadata is considered "dead," that is, uninterpretable.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataTableOfContentsEntry.BlockOffset">
            <summary>
            The offset into the stream where the metadata block begins.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataTableOfContentsEntry.BlockSize">
            <summary>
            The number of bytes used to store the metadata block.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataTableOfContentsEntry.ImplDead">
            <summary>
            Information on a metadata that could not be interpreted for some reason.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.ReaderVersion">
            <summary>
            Upper inclusive bound of versions this reader can read.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.StandardDataTypesVersion">
            <summary>
            The first version that removes DvTypes and uses .NET standard
            data types.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MissingTextVersion">
            <summary>
            The first version of the format that accomodated DvText.NA.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.MetadataVersion">
            <summary>
            The first version of the format that accomodated arbitrary metadata.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.SlotNamesVersion">
            <summary>
            The first version of the format that accomodated slot names.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.ReaderFirstVersion">
            <summary>
            Lower inclusive bound of versions this reader can read.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IO.BinaryLoader.Arguments,System.IO.Stream,System.Boolean)">
            <summary>
            Constructs a new data view reader.
            </summary>
            <param name="stream">A seekable, readable stream. Note that the data view reader assumes
            that it is the exclusive owner of this stream.</param>
            <param name="args">Arguments</param>
            <param name="env">Host enviroment</param>
            <param name="leaveOpen">Whether to leave the input stream open</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.#ctor(Microsoft.ML.Runtime.IHost,Microsoft.ML.Runtime.Model.ModelLoadContext,System.IO.Stream)">
            <summary>
            Creates a binary loader from a <see cref="T:Microsoft.ML.Runtime.Model.ModelLoadContext"/>. Since the loader code
            opens the file, this will always take ownership of the stream, that is, this is always
            akin to <c>leaveOpen</c> in the other constructor being false.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,System.IO.Stream)">
            <summary>
            Creates a binary loader from a stream that is not owned by the loader.
            This creates its own independent copy of input stream for the binary loader.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.SaveParameters(Microsoft.ML.Runtime.Model.ModelSaveContext,System.Int32,System.String,System.Double)">
            <summary>
            Write the parameters of a loader to the save context. Can be called by <see cref="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.SaveInstance(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelSaveContext,Microsoft.ML.Runtime.Data.ISchema)"/>, where there's no actual
            loader, only default parameters.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.SaveSchema(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelSaveContext,Microsoft.ML.Runtime.Data.ISchema,System.Int32[]@)">
            <summary>
            Save a zero-row dataview that will be used to infer schema information, used in the case
            where the binary loader is instantiated with no input streams.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.SaveInstance(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelSaveContext,Microsoft.ML.Runtime.Data.ISchema)">
             <summary>
             Given the schema and a model context, save an imaginary instance of a binary loader with the
             specified schema. Deserialization from this context should produce a real binary loader that
             has the specified schema.
            
             This is used in an API scenario, when the data originates from something other than a loader.
             Since our model file requires a loader at the beginning, we have to construct a bogus 'binary' loader
             to begin the pipe with, with the assumption that the user will bypass the loader at deserialization
             time by providing a starting data view.
             </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe.DecompressOne">
            <summary>
            This will attempt to extract a compressed block from the
            <see cref="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1._toDecompress"/> queue. This returns true if and only if it
            succeeded in extracting an item from the queue (even a sentinel block);
            that is, if it returns false, then there are no more items to extract
            (though, continuing to call this method is entirely possible, and legal,
            if convenient).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe.MoveNextCleanup">
            <summary>
            Necessary to be called in the event of a premature exiting. This executes
            the same recycle-fetch block cycle as <see cref="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe.MoveNext"/>, except that
            nothing is actually done with the resulting block. This should be called
            in a similar fashion as the cursor calls <see cref="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe.MoveNext"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipeGenerated`1.Block.IsSentinel">
            <summary>
            This indicates that this block does not contain any actual information, or
            correspond to an actual block, but it will still contain the
            <see cref="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipeGenerated`1.Block.BlockSequence"/> index. Sentinel blocks are used to indicate that
            there will be no more blocks to be decompressed along a particular pipe,
            allowing the pipe worker to perform necessary cleanup.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipeGenerated`1.Block.#ctor(System.Int64)">
            <summary>
            Constructor for a sentinel compressed block. (E.g.,
            the pipe's last block, which contains no valid data.)
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1._toDecompress">
            <summary>
            Calls from the stream reader worker into <see cref="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1.PrepAndSendCompressedBlock(System.Int64,System.Int64,System.Int32)"/> will feed
            into this collection, and calls from the decompress worker into <see cref="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1.DecompressOne"/>
            will consume this collection.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1.CompressedBlock.IsSentinel">
            <summary>
            This indicates that this block does not contain any actual information, or
            correspond to an actual block, but it will still contain the
            <see cref="F:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1.CompressedBlock.BlockSequence"/> index. Sentinel blocks are used to indicate that
            there will be no more blocks to be decompressed along a particular pipe,
            allowing the pipe worker to perform necessary cleanup.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1.CompressedBlock.#ctor(System.Int64)">
            <summary>
            Constructor for a sentinel compressed block. (E.g.,
            the pipe's last block, which contains no valid data.)
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.ReadPipe`1.#ctor(Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor,System.Int32,System.Int32)">
            <summary>
            This is called through reflection so it will appear to have no references.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinaryLoader.Cursor.GetNoRowGetter(Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            Even in the case with no rows, there still must be valid delegates. This will return
            a delegate that simply always throws.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.BinarySaver.ColumnCodec">
            <summary>
            This is a simple struct to associate a source index with a codec, without having to have
            parallel structures everywhere.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.WritePipe.Create(Microsoft.ML.Runtime.Data.IO.BinarySaver,Microsoft.ML.Runtime.Data.IRowCursor,Microsoft.ML.Runtime.Data.IO.BinarySaver.ColumnCodec)">
            <summary>
            Returns an appropriate generic <c>WritePipe{T}</c> for the given column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.BinarySaver.Block">
            <summary>
            A class useful for encapsulating both compressed and uncompressed block data.
            As the mechanism the compress workers communicate with the writer worker, they
            also have a dual usage if <see cref="T:System.Exception"/> is non-null of indicating
            a source worker threw an exception.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinarySaver.Block.BlockData">
            <summary>
            Take one guess.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinarySaver.Block.UncompressedLength">
            <summary>
            The length of the block if uncompressed. This quantity is only intended to be
            meaningful if the block data is compressed.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinarySaver.Block.ColumnIndex">
            <summary>
            The column index, which is the index of the column as being written, which
            may be less than the column from the source dataview if there were preceeding
            columns being dropped.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BinarySaver.Block.BlockIndex">
            <summary>
            The block sequence number for this column, starting consecutively from 0.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IO.BinarySaver.Arguments)">
            <summary>
            Constructs a saver for a data view.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.WriteMetadata(System.IO.BinaryWriter,Microsoft.ML.Runtime.Data.ISchema,System.Int32,Microsoft.ML.Runtime.IChannel)">
            <summary>
            A helper method to query and write metadata to the stream.
            </summary>
            <param name="writer">A binary writer, which if metadata exists for the
            indicated column the base stream will be positioned just past the end of
            the written metadata table of contents, and if metadata does not exist
            remains unchanged</param>
            <param name="schema">The schema to query for metadat</param>
            <param name="col">The column we are attempting to get metadata for</param>
            <param name="ch">The channel to which we write any diagnostic information</param>
            <returns>The offset of the metadata table of contents, or 0 if there was
            no metadata</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.TryWriteTypeDescription(System.IO.Stream,Microsoft.ML.Runtime.Data.ColumnType,System.Int32@)">
            <summary>
            A utility method to save a column type to a stream, if we have a codec for that.
            </summary>
            <param name="stream">The stream to save the description to</param>
            <param name="type">The type to save</param>
            <param name="bytesWritten">The number of bytes written to the stream, which will
            be zero if we could not save the stream</param>
            <returns>Returns if have the ability to save this column type. If we do, we write
            the description to the stream. If we do not, nothing is written to the stream and
            the stream is not advanced.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.LoadTypeDescriptionOrNull(System.IO.Stream)">
            <summary>
            Attempts to load a type description from a stream. In all cases, in the event
            of a properly formatted stream, even if the type-descriptor is not recognized,
            the stream will be at the end of that type descriptor. Note that any detected
            format errors will result in a throw.
            </summary>
            <param name="stream">The stream to load the type description from</param>
            <returns>A non-null value if the type descriptor was recognized, or null if
            it was not</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.TryWriteTypeAndValue``1(System.IO.Stream,Microsoft.ML.Runtime.Data.ColumnType,``0@,System.Int32@)">
            <summary>
            A utility method to save a column type and value to a stream, if we have a codec for that.
            </summary>
            <param name="stream">The stream to write the type and value to</param>
            <param name="type">The type of the codec to write and utilize</param>
            <param name="value">The value to encode and write</param>
            <param name="bytesWritten">The number of bytes written</param>
            <returns>Whether the write was successful or not</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.TryLoadTypeAndValue(System.IO.Stream,Microsoft.ML.Runtime.Data.ColumnType@,System.Object@)">
            <summary>
            Attempts to load a type description and a value of that type from a stream.
            </summary>
            <param name="stream">The stream to load the type description and value from</param>
            <param name="type">A non-null value if the type descriptor was recognized, or null if
            it was not</param>
            <param name="value">A non-null value if the type descriptor was recognized and a value
            read, or null if the type descriptor was not recognized</param>
            <returns>Whether the load of a type description and value was successful</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.BinarySaver.LoadValue``1(System.IO.Stream,Microsoft.ML.Runtime.Data.IO.IValueCodec{``0})">
            <summary>
            Deserializes and returns a value given a stream and codec.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.BlockLookup">
            <summary>
            This structure is utilized by both the binary loader and binary saver to hold
            information on the location of blocks written to an .IDV binary file.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BlockLookup.BlockOffset">
            <summary>The offset of the block into the file.</summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BlockLookup.BlockLength">
            <summary>The byte length of the block on disk.</summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.BlockLookup.DecompressedBlockLength">
            <summary>The byte length of the block if decompressed.</summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.CodecFactory.WriteCodec(System.IO.Stream,Microsoft.ML.Runtime.Data.IO.IValueCodec)">
            <summary>
            Given a codec, write a type description to a stream, from which this codec can be
            reconstructed later. This returns the number of bytes written, so that, if this
            were a seekable stream, the positions would differ by this amount before and after
            a call to this method.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.CodecFactory.TryReadCodec(System.IO.Stream,Microsoft.ML.Runtime.Data.IO.IValueCodec@)">
            <summary>
            Attempts to define a codec, given a stream positioned at the start of a serialized
            codec type definition.
            </summary>
            <param name="definitionStream">The input stream, which whether this returns true or false
            will be left at the end of the codec type definition</param>
            <param name="codec">A codec castable to a generic <c>IValueCodec{T}</c> where
            <c>typeof(T)==codec.Type.RawType</c></param>
            <returns>Whether the codec type definition was understood. If true the codec has defined
            value, and should be usable. If false, the name of the codec was unrecognized. Note that
            malformed definitions are detected, this will throw instead of returning either true or
            false.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.CodecFactory.ValueWriterBase`1">
            <summary>
            A convenient base class for value writers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.CodecFactory.ValueReaderBase`1">
            <summary>
            A convenient base class for value readers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.CodecFactory.SimpleCodec`1">
            <summary>
            A simple codec is useful for those types with no parameterizations.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.CodecFactory.UnsafeTypeCodec`1">
            <summary>
            This codec is for use with types that have <c>UnsafeTypeOps</c> operations defined.
            Generally, this corresponds to numeric types that can be safely blitted.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.CodecFactory.BoolCodec">
            <summary>
            This is a boolean code that reads from a form that serialized
            1 bit per value. The old encoding (implemented by a different codec)
            uses 2 bits per value so NA values can be supported.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.CompressionKind">
            <summary>
            A code indicating the kind of compression. It is supposed that each kind of compression is totally
            sufficient to describe how a given stream should be decompressed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.CompressStream(Microsoft.ML.Runtime.Data.IO.CompressionKind,System.IO.Stream)">
            <summary>
            Generate an appropriate wrapping compressing stream for the codec. This
            stream will be closable and disposable, without closing or disposing of
            the passed in stream. The scheme for compression is not in any way
            parameterizable.
            </summary>
            <param name="compression">The compression codec</param>
            <param name="stream">The stream to which compressed data will be written</param>
            <returns>A stream to which the user can write uncompressed data</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.CompressionCodecExtension.DecompressStream(Microsoft.ML.Runtime.Data.IO.CompressionKind,System.IO.Stream)">
            <summary>
            Generate an appropriate wrapping decompressing stream for the codec.
            </summary>
            <param name="compression">The compression codec</param>
            <param name="stream">The stream from which compressed data will be written</param>
            <returns>A stream from which the user can read uncompressed data</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.Compression">
            <summary>
            A loadable class to parameterize compression.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.Compression.Open(System.IO.Stream)">
            <summary>
            Generate an appropriate wrapping compressing stream for the codec. This
            stream will be closable and disposable, without closing or disposing of
            the passed in stream. The scheme for compression is parameterized by the
            <see cref="T:Microsoft.ML.Runtime.Data.IO.Compression"/> instance.
            </summary>
            <param name="stream">The stream to which compressed data will be written</param>
            <returns>A stream to which the user can write uncompressed data</returns>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.HeaderSize">
            <summary>
            The fixed header size. This should not be changed even in future versions of the format.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.SignatureValue">
            <summary>
            The header must start with this signature. This number will
            appear as the eight-byte sequence "CML\0DVB\0" if encoded in
            little-endian. (CML DVB is meant to suggest CloudML DataView binary).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.TailSignatureValue">
            <summary>
            The file must end with this value. Is is simply the
            byte-order-reversed version of the head signature.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.WriterVersion">
            <summary>
            The current version of the format this software can write.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.Signature">
            <summary>
            The magic number of this file.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.Version">
            <summary>
            Indicates the version of the data file.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.CompatibleVersion">
            <summary>
            Indicates the minimum reader version that can interpret this file, possibly
            with some data loss.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.TableOfContentsOffset">
            <summary>
            The offset to the table of contents structure where the column type definitions
            are stored.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.TailOffset">
            <summary>
            The eight-byte tail signature starts at this offset. So, the entire dataset
            stream should be considered to have eight plus this value bytes.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.RowCount">
            <summary>
            The number of rows in this data file.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Header.ColumnCount">
            <summary>
            The number of columns in this data file.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.IValueCodec">
             <summary>
             A value codec encapsulates implementations capable of writing and reading data of some
             type to and from streams. The idea is that one creates a codec using <c>TryGetCodec</c>
             on the appropriate <c>ColumnType</c>, then opens multiple writers to write blocks of data
             to some stream. The idea is that each writer or reader is called on some "managable chunk"
             of data.
            
             Codecs should be thread safe, though the readers and writers they spawn do not need to
             be thread safe.
             </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.IValueCodec.LoadName">
            <summary>
            This is the codec's identifying name. This is utilized both by the codec factory's
            <c>WriteTypeDescription</c> and <c>TryGetCodec</c>, for persisting and recovering
            the codec, respectively.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueCodec.WriteParameterization(System.IO.Stream)">
            <summary>
            Writes the codec parameterization to the stream. (The parameterization
            is the third part of the codec type description, after the name, and length
            of the parameterization.)
            </summary>
            <returns>The number of bytes written to the stream</returns>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.IValueCodec.Type">
            <summary>
            The column type for this codec.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.IValueCodec`1">
            <summary>
            The generic value codec.
            </summary>
            <typeparam name="T">The type for which we can spawn readers and writers.
            Note that <c>Type.RawType == typeof(T)</c>.</typeparam>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueCodec`1.OpenWriter(System.IO.Stream)">
            <summary>
            Returns a writer for this codec, capable of writing a series of values to a block
            starting at the current position of the indicated writable stream.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueCodec`1.OpenReader(System.IO.Stream,System.Int32)">
            <summary>
            Returns a reader for this codec, capable of reading a series of values to a block
            starting at the current position of the indicated readable stream.
            </summary>
            <param name="stream">Stream on which we open reader.</param>
            <param name="items">The number of items expected to be encoded in the block
            starting from the current position of the stream. Implementors should, if
            possible, throw if it seems if the block contains a different number of
            elements.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueWriter.Commit">
            <summary>
            Finishes writing to the stream. No further values should be written using the
            <c>Write</c> methods. Note that failure to commit does not leave the stream in
            a defined state: something or nothing could have already been written to the
            stream, and the writer has no facilities to "rewind" whatever writes it may
            have performed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueWriter.GetCommitLengthEstimate">
            <summary>
            Returns an estimate of the total length that would be written to the stream
            were we to commit right now. This may be called very often in some circumstances,
            so implementors should optimize for speed over accuracy.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.IValueWriter`1">
             <summary>
             A value writer on a particular type. The intent is that implementors of this will
             be spawned from an <seealso cref="T:Microsoft.ML.Runtime.Data.IO.IValueCodec"/>, its write methods called some
             number of times to write to the stream, and then <c>Commit</c> will be called when
             all values have been written, the stream now being at the end of the written block.
            
             The intended usage of the value writers is that blocks are composed of some small
             number of values (perhaps a few thousand), the idea being that a block is something
             that should easily fit in main memory, both for reading and writing. Some writers
             take advantage of this to organize their values for more efficient reading.
             </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueWriter`1.Write(`0@)">
            <summary>
            Writes a single value to the writer.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueWriter`1.Write(`0[],System.Int32,System.Int32)">
            <summary>
            Writes an array of values. This should be equivalent to writing each element
            singly, though possibly more efficient than such a naive implementation.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.IValueReader`1">
            <summary>
            A value reader on a particular type. As with writers, implementors of this will be
            spawned form an <seealso cref="T:Microsoft.ML.Runtime.Data.IO.IValueCodec"/>. Its read methods will be called some
            number of times to read from the stream. The read methods should be used to read
            precisely the same number of times as was written to the block. if you read more,
            then the values returned past the last will be undefined, and in either case the
            stream will be left in an undefined state. Implementors may optionally complain in
            such a case, but many will not, so outside knowledge should be used by the user
            to ensure bad behavior does not happen. (For example, if you have a writer that
            just writes packed binary values with no descriptive information, the corresponding
            read will have no ability to tell when it is supposed to "end.")
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueReader`1.MoveNext">
            <summary>
            Moves to the next element.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueReader`1.Get(`0@)">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.IValueReader`1.Read(`0[],System.Int32,System.Int32)">
            <summary>
            Reads into an array of values. This should be roughly equivalent to calling <c>MoveNext</c>
            then <c>Get</c> into an array on each element singly, though possibly more efficient than
            such a naive implementation. It may also diverge from that, in that <c>Get</c>'s behavior
            before the next <c>MoveNext</c> is undefined when this function is called.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.MemoryStreamCollection.IndexFor(System.Int32)">
            <summary>
            Given a byte size, returns an appropriate index to <see cref="F:Microsoft.ML.Runtime.Data.IO.MemoryStreamCollection._pools"/>.
            This is a non-decreasing function w.r.t. <paramref name="maxSize"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.Zlib.Constants">
            <summary>
            See zlib.h
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.Constants.MaxBufferSize">
            <summary>
            Maximum size of history buffer inside zlib.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.Zlib.ZDeflateStream.RefreshOutput(System.Byte*)">
            <summary>
            Check zlib internal buffer and if it's full flush its results to compressed stream.
            </summary>
            <param name="pOutput">link internal buffer</param>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.NextIn">
            <summary>
            Pointer to input buffer. Zlib inflate and deflate routine consumes data from this buffer.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.AvailIn">
            <summary>
            Number of bytes available at next_in.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.TotalIn">
            <summary>
            Total number of input bytes read so far.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.NextOut">
            <summary>
            Pointer to output buffer. Zlib inflate and deflate routine produce output to this location.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.AvailOut">
            <summary>
            Remaining free space at next_out.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.TotalOut">
            <summary>
            Total number of bytes output so far.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.Msg">
            <summary>
            Last error message, NULL if no error.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.State">
            <summary>
            Internal state struct.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.Zalloc">
            <summary>
            Used to allocate the internal state.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.Zfree">
            <summary>
            Used to free the internal state.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.Opaque">
            <summary>
            Private data object passed to zalloc and zfree.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.DataType">
            <summary>
            Best guess about the data type: binary or text.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.Adler">
            <summary>
            Adler32 value of the uncompressed data.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.Zlib.ZStream.Reserved">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TextSaver.ValueWriter.WriteData(System.Action{System.Text.StringBuilder,System.Int32},System.Int32@)">
            <summary>
            Write the data to the given stream. This requires that FetchData was previously called.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TextSaver.SeparatorCharToString(System.Char)">
            <summary>
            Returns the string representation of a separator: helpful if it's whitespace or a punctuation mark.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TextSaverUtils.MapText(System.ReadOnlySpan{System.Char},System.Text.StringBuilder@,System.Char)">
            <summary>
            Converts a ReadOnlySpan to a StringBuilder using TextSaver escaping and string quoting rules.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.TransposeLoader">
            <summary>
            The transposed loader reads the transposed binary format. This binary format, at a high level, is nothing more
            than, for a dataview with "c" columns, "c+1" binary IDVs glued together. We call these sub-IDVs. The first of these,
            the master sub-IDV stores the overall schema, and optionally the data in row-wise format.
            </summary>
            <seealso cref="T:Microsoft.ML.Runtime.Data.IO.TransposeSaver"/>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.HeaderSize">
            <summary>
            The fixed header size. This should not be changed even in future versions of the format.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.SignatureValue">
            <summary>
            The header must start with this signature. This number will
            appear as the eight-byte sequence "XPOSEDDV" if encoded in
            little-endian. (XPOSEDDV is meant to suggest transposed DataView).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.TailSignatureValue">
            <summary>
            The file must end with this value. Is is simply the
            byte-order-reversed version of the head signature.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.WriterVersion">
            <summary>
            The current version of the format this software can write.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.Signature">
            <summary>
            The magic number of this file.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.Version">
            <summary>
            Indicates the version of the data file.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.CompatibleVersion">
            <summary>
            Indicates the minimum reader version that can interpret this file, possibly
            with some data loss.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.SubIdvTableOffset">
            <summary>
            The offset to the list of the directory of the sub-IDV structures.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.TailOffset">
            <summary>
            The eight-byte tail signature starts at this offset. So, the entire dataset
            stream should be considered to have eight plus this value bytes.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.RowCount">
            <summary>
            The number of rows.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Header.ColumnCount">
            <summary>
            The number of columns. There will be this + 1 entries in the sub-IDV table
            offset structure.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry">
            <summary>
            A sub-IDV entry corresponds to an offset and length within the transposed file, that points
            either to a block binary-IDV formatted data if the offset is positive, or indicates that there
            is no corresponding IDV entry if the offset is zero.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.HasDataView">
            <summary>
            Is true when this sub-IDV appears to exist, without actually loading that sub-IDV.
            If this returns true, <see cref="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.GetViewOrNull"/> will either return a non-null
            value, or throw some sort of formatting error.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.#ctor(Microsoft.ML.Runtime.Data.IO.TransposeLoader,System.IO.BinaryReader)">
            <summary>
            Reads the table of contents entry from the file, advancing the binary loader stream.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.#ctor(Microsoft.ML.Runtime.Data.IO.TransposeLoader)">
            <summary>
            Constructs an empty table of contents entry, with no offset.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.GetViewOrNull">
            <summary>
            Gets the dataview corresponding to this sub-IDV entry. This will
            lazily load the file, if it has not previously been requested. This
            will return <c>null</c> if the offset is 0.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.VerifyView(Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Called once, to verify that the lazily read dataview is "correct." Called by
            <see cref="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.GetViewOrNull"/> once it has been read. Any problems with the data-view
            should be handle with <see cref="M:Microsoft.ML.Runtime.Contracts.CheckDecode(System.Boolean)"/> or by throwing
            <see cref="M:Microsoft.ML.Runtime.Contracts.ExceptDecode"/>, as we consider the views not adhering to
            standards to be a file formatting issue. Note that this will never be called if
            the offset field is zero.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.SchemaSubIdv">
            <summary>
            This is the entry corresponding to the first IDV entry in the file, which will hold
            at least the schema information for all columns. There should be one of these per
            file. Optionally, this file can also hold the row-wise data stored as well, in case
            the user wanted to have the hybrid row/slotwise store. For this one, it is illegal
            for the offset to be zero.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.TransposedSubIdv">
            <summary>
            This is the entry corresponding to the transposed columns. There will be one of
            these per column, though some entries will not actually have a corresponding
            dataview (e.g., they will have an offset of 0) if the column was not one selected
            for slot-wise transposition.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SubIdvEntry.TransposedSubIdv.#ctor(Microsoft.ML.Runtime.Data.IO.TransposeLoader,System.Int32)">
            <summary>
            Returns an empty sub-IDV entry for the no-file case.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.ReaderFirstVersion">
            <summary>
            Lower inclusive bound of versions this reader can read.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.IO.TransposeLoader.ReaderVersion">
            <summary>
            Upper inclusive bound of versions this reader can read.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IO.TransposeLoader.HasRowData">
            <summary>
            Whether the master schema sub-IDV has the actual data.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.SaveSchema(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelSaveContext,Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Save a zero-row dataview that will be used to infer schema information, used in the case
            where the tranpsose loader is instantiated with no input streams.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeLoader.Cursor.Init(System.Int32)">
            <summary>
            Initializes the transpose cursors and getters for a column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IO.TransposeSaver">
            <summary>
            Saver for a format that can be loaded using the <see cref="T:Microsoft.ML.Runtime.Data.IO.TransposeLoader"/>.
            </summary>
            <seealso cref="T:Microsoft.ML.Runtime.Data.IO.TransposeLoader"/>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IO.TransposeSaver.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IO.TransposeSaver.Arguments)">
            <summary>
            Constructs a saver for a data view.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CompositeDataLoader">
            <summary>
            A data loader that wraps an underlying loader plus a sequence of transforms.
            It is not valid to have nested <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/>'s: if a <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/>
            is an underlying loader, the resulting loader will 'flatten' the structure.
            The family of <c>Create</c> methods only instantiate <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/>'s
            when there are transforms to keep, otherwise they just return underlying loaders.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.CompositeDataLoader.View">
            <summary>
            Returns the underlying data view of the composite loader.
            This can be used to programmatically explore the chain of transforms that's inside the composite loader.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.CompositeDataLoader.Arguments,Microsoft.ML.Runtime.Data.IMultiStreamSource)">
            <summary>
            Creates a loader according to the specified <paramref name="args"/>.
            If there are transforms, then the result will be a <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/>,
            otherwise, it'll be whatever <see cref="T:Microsoft.ML.Runtime.Data.IDataLoader"/> is specified in <c>args.loader</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataLoader,System.Collections.Generic.KeyValuePair{System.String,Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.IDataTransform}}[])">
            <summary>
            Creates a <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/> that starts with the <paramref name="srcLoader"/>,
            and follows with transforms created from the <paramref name="transformArgs"/> array.
            If there are no transforms, the <paramref name="srcLoader"/> is returned.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.ApplyTransforms(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataLoader,System.Collections.Generic.KeyValuePair{System.String,System.String}[],System.Func{Microsoft.ML.Runtime.IHostEnvironment,System.Int32,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.IDataView})">
            <summary>
            Appends transforms to the <paramref name="srcLoader"/> and returns a loader that contains these new transforms.
            If there are no transforms to append, returns <paramref name="srcLoader"/> intact, otherwise creates a
            <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/>. The transforms are created by sequentially invoking the provided lambda,
            one time for each element of <paramref name="tagData"/>.
            </summary>
            <param name="env">The host environment.</param>
            <param name="srcLoader">The source loader.</param>
            <param name="tagData">The array of (tag, creationInfo) pairs. Can be an empty array or null, in which case
            the function returns <paramref name="srcLoader"/>.</param>
            <param name="createTransform">The delegate to invoke at each transform creation.
            Delegate parameters are: host environment, transform index (0 to <c>tagData.Length</c>), source data view.
            It should return the <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> that should share the same loader as the source data view.</param>
            <returns>The resulting data loader.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.ApplyTransform(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataLoader,System.String,System.String,System.Func{Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.IDataView})">
            <summary>
            Apply one transform to the data loader, and returns a (composite) data loader that contains the result.
            The transform is created by invoking the lambda for a data source, and it should return an
            <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> that shares the same loader as the provided source.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IMultiStreamSource)">
            <summary>
            Loads the entire composite data loader (loader + transforms) from the context.
            If there are no transforms, the underlying loader is returned.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataLoader,System.Func{System.String,System.Boolean})">
            <summary>
            Creates a <see cref="T:Microsoft.ML.Runtime.Data.IDataLoader"/> from the specified source loader, followed by
            the transforms that are loaded from the <paramref name="ctx"/>, tags filtered by
            by the <paramref name="isTransformTagAccepted"/>.
            If the <paramref name="ctx"/> contains no accepted transforms, the <paramref name="srcLoader"/> is
            returned intact.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.LoadSelectedTransforms(Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Func{System.String,System.Boolean})">
            <summary>
            Loads all transforms from the <paramref name="ctx"/> that pass the <paramref name="isTransformTagAccepted"/> test,
            applies them sequentially to the <paramref name="srcView"/>, and returns the resulting data view.
            If there are no transforms in <paramref name="ctx"/> that are accepted, returns the original <paramref name="srcView"/>.
            The difference from the <c>Create</c> method above is that:
            - it doesn't wrap the results into a loader, just returns the last transform in the chain.
            - it accepts <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> as input, not necessarily a loader.
            - it throws away the tag information.
            - it doesn't throw if the context is not representing a <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/>: in this case it's assumed that no transforms
              meet the test, and the <paramref name="srcView"/> is returned.
            Essentially, this is a helper method for the LoadTransform class.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.LoadTransforms(Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataLoader,Microsoft.ML.Runtime.IHost,System.Func{System.String,System.Boolean})">
            <summary>
            Loads all transforms from the <paramref name="ctx"/> that pass the <paramref name="isTransformTagAccepted"/> test,
            applies them sequentially to the <paramref name="srcLoader"/>, and returns the (composite) data loader.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataLoader.SavePipe(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelSaveContext,System.Action{Microsoft.ML.Runtime.Model.ModelSaveContext},System.Collections.Generic.IList{Microsoft.ML.Runtime.Data.IDataTransform})">
            <summary>
            Save the loader and transforms (if any) to the repository.
            This is intended to be used by API, where the components are not part of the same
            <see cref="T:Microsoft.ML.Runtime.Data.CompositeDataLoader"/>.
            </summary>
            <param name="env">Environment context</param>
            <param name="ctx">The context to write to.</param>
            <param name="loaderSaveAction">The code to save the loader.</param>
            <param name="transforms">The transforms. Empty list and null are both allowed.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CompositeDataReader`2">
            <summary>
            This class represents a data reader that applies a transformer chain after reading.
            It also has methods to save itself to a repository.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.CompositeDataReader`2.Reader">
            <summary>
            The underlying data reader.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.CompositeDataReader`2.Transformer">
            <summary>
            The chain of transformers (possibly empty) that are applied to data upon reading.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataReader`2.AppendTransformer``1(``0)">
            <summary>
            Append a new transformer to the end.
            </summary>
            <returns>The new composite data reader</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataReader`2.SaveTo(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Save the contents to a stream, as a "model file".
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CompositeDataReader">
            <summary>
            Utility class to facilitate loading from a stream.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataReader.SaveTo``1(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Save the contents to a stream, as a "model file".
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeDataReader.LoadFrom(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Load the pipeline from stream.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CompositeReaderEstimator`2">
            <summary>
            An estimator class for composite data reader.
            It can be used to build a 'trainable smart data reader', although this pattern is not very common.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeReaderEstimator`2.Append``1(Microsoft.ML.Core.Data.IEstimator{``0})">
            <summary>
            Append another estimator to the end.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.EstimatorChain`1">
            <summary>
            Represents a chain (potentially empty) of estimators that end with a <typeparamref name="TLastTransformer"/>.
            If the chain is empty, <typeparamref name="TLastTransformer"/> is always <see cref="T:Microsoft.ML.Core.Data.ITransformer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EstimatorChain`1.#ctor">
            <summary>
            Create an empty estimator chain.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.LearningPipelineExtensions">
            <summary>
            Extension methods that allow chaining estimator and transformer pipes together.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReaderEstimator{``0,Microsoft.ML.Core.Data.IDataReader{``0}},Microsoft.ML.Core.Data.IEstimator{``1})">
            <summary>
            Create a composite reader estimator by appending an estimator to a reader estimator.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},Microsoft.ML.Core.Data.IEstimator{``1})">
            <summary>
            Create a composite reader estimator by appending an estimator to a reader.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},Microsoft.ML.Core.Data.IEstimator{``0},Microsoft.ML.Runtime.Data.TransformerScope)">
            <summary>
            Create an estimator chain by appending an estimator to an estimator.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``2(Microsoft.ML.Core.Data.IDataReader{``0},``1)">
            <summary>
            Create a composite reader by appending a transformer to a data reader.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.Append``1(Microsoft.ML.Core.Data.ITransformer,``0)">
            <summary>
            Create a transformer chain by appending a transformer to a transformer.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LearningPipelineExtensions.WithOnFitDelegate``1(Microsoft.ML.Core.Data.IEstimator{``0},System.Action{``0})">
            <summary>
            Given an estimator, return a wrapping object that will call a delegate once <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)"/>
            is called. It is often important for an estimator to return information about what was fit, which is why the
            <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)"/> method returns a specifically typed object, rather than just a general
            <see cref="T:Microsoft.ML.Core.Data.ITransformer"/>. However, at the same time, <see cref="T:Microsoft.ML.Core.Data.IEstimator`1"/> are often formed into pipelines
            with many objects, so we may need to build a chain of estimators via <see cref="T:Microsoft.ML.Runtime.Data.EstimatorChain`1"/> where the
            estimator for which we want to get the transformer is buried somewhere in this chain. For that scenario, we can through this
            method attach a delegate that will be called once fit is called.
            </summary>
            <typeparam name="TTransformer">The type of <see cref="T:Microsoft.ML.Core.Data.ITransformer"/> returned by <paramref name="estimator"/></typeparam>
            <param name="estimator">The estimator to wrap</param>
            <param name="onFit">The delegate that is called with the resulting <typeparamref name="TTransformer"/> instances once
            <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)"/> is called. Because <see cref="M:Microsoft.ML.Core.Data.IEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)"/>
            may be called multiple times, this delegate may also be called multiple times.</param>
            <returns>A wrapping estimator that calls the indicated delegate whenever fit is called</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MultiFileSource">
            <summary>
            Wraps a potentially compound path as an IMultiStreamSource. Expands wild cards and supports
            multiple paths separated by +.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.FileHandleSource">
            <summary>
            Wraps an <see cref="T:Microsoft.ML.Runtime.IFileHandle"/> as an IMultiStreamSource.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.PartitionedFileLoader">
             <summary>
             Loads a set of directory partitioned files into an IDataView.
             The directories of the file will treated as column data and the underlying files are loaded using the data loader.
             The first file will be used as the basis for all follow-up file paths and schemas. Any files that don't match
             the expected path or schema will be skipped.
             </summary>
             <example>
             Sample directory structure:
            
             Data/
                 Year=2017/
                     Month=01/
                         data1.parquet
                         data1.parquet
                     Month=02/
                         data1.parquet
                         data1.parquet
                 Year=2018/
                     Month=01/
                         data1.parquet
                         data1.parquet
             </example>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PartitionedFileLoader.CreateSchema(Microsoft.ML.Runtime.IExceptionContext,Microsoft.ML.Runtime.Data.PartitionedFileLoader.Column[],Microsoft.ML.Runtime.Data.IDataLoader)">
            <summary>
            Create a composite schema of both the partitioned columns and the underlying loader columns.
            </summary>
            <param name="ectx">The exception context.</param>
            <param name="cols">The partitioned columns.</param>
            <param name="subLoader">The sub loader.</param>
            <returns>The resulting schema.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PartitionedFileLoader.Cursor.TryTruncatePath(System.Int32,System.String,System.String@)">
            <summary>
            Truncate path to the specified number of trailing directories.
            </summary>
            <param name="dirCount">Number of directories to retain.</param>
            <param name="path">Path to truncate.</param>
            <param name="truncPath">The resulting truncated path.</param>
            <returns>true if the truncation was successful.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PartitionedFileLoader.Cursor.TryParseValuesFromPath(System.String,System.Collections.Generic.List{System.String}@)">
            <summary>
            Parse all column values from the directory path.
            </summary>
            <param name="path">The directory path to parse for name/value pairs.</param>
            <param name="results">The resulting name value pairs.</param>
            <returns>true if the parsing was successfull.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PartitionedFileLoader.GetRelativePath(System.String,Microsoft.ML.Runtime.Data.IMultiStreamSource)">
            <summary>
            Get a path relative to the base path.
            </summary>
            <param name="basepath">A base path.</param>
            <param name="files">A list of files under the base path.</param>
            <returns>A realtive file path.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PartitionedFileLoader.ParseColumns(System.String)">
            <summary>
            Parse the column definitions using a path parser.
            </summary>
            <param name="path">The path to a file.</param>
            <returns>The resulting Columns.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PartitionedFileLoader.GetDirectoryCount(System.String)">
            <summary>
            Get the number of directories in the file path.
            </summary>
            <param name="path">A file path.</param>
            <returns>The number of directories</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.PartitionedPathParser">
            <summary>
            Delegate signature for a partitioned path parser.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IPartitionedPathParser">
            <summary>
            Supports extracting column names and values from a path string.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IPartitionedPathParser.ParseColumns(System.String)">
            <summary>
            Extract the column definitions from a file path.
            </summary>
            <param name="path">The file path.</param>
            <returns>The resulting column definitions.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when parsing fails.</exception>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IPartitionedPathParser.ParseValues(System.String)">
            <summary>
            Extract the column values from a file path.
            </summary>
            <param name="path">The file path.</param>
            <returns>The resulting column values.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when parsing fails.</exception>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ParquetPartitionedPathParser.TryParseNameValueFromDir(System.String,System.String@,System.String@)">
            <summary>
            Parse the name/value pair from a partitioned directory name.
            </summary>
            <param name="dir">The directory name.</param>
            <param name="name">The resulting name.</param>
            <param name="value">The resulting value.</param>
            <returns>true if the parsing was successfull.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader">
            <summary>
            Loads a text file into an IDataView. Supports basic mapping from input columns to IDataView columns.
            Should accept any file that TlcTextInstances accepts.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.Column">
             <example>
             Scalar column of <seealso cref="T:Microsoft.ML.Runtime.Data.DataKind"/> I4 sourced from 2nd column
                  col=ColumnName:I4:1
            
             Vector column of <seealso cref="T:Microsoft.ML.Runtime.Data.DataKind"/> I4 that contains values from columns 1, 3 to 10
                 col=ColumnName:I4:1,3-10
            
             Key range column of KeyType with underlying storage type U4 that contains values from columns 1, 3 to 10, that can go from 1 to 100 (0 reserved for out of range)
                 col=ColumnName:U4[1-100]:1,3-10
             </example>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Column.IsValid">
            <summary>
             Returns <c>true</c> iff the ranges are disjoint, and each range satisfies 0 &lt;= min &lt;= max.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Range.#ctor(System.Int32)">
            <summary>
            A range representing a single value. Will result in a scalar column.
            </summary>
            <param name="index">The index of the field of the text file to read.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Range.#ctor(System.Int32,System.Nullable{System.Int32})">
            <summary>
            A range representing a set of values. Will result in a vector column.
            </summary>
            <param name="min">The minimum inclusive index of the column.</param>
            <param name="max">The maximum-inclusive index of the column. If <c>null</c>
            indicates that the <see cref="T:Microsoft.ML.Runtime.Data.TextLoader"/> should auto-detect the legnth
            of the lines, and read till the end.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.ArgumentsCore.IsValid">
            <summary>
            Checks that all column specifications are valid (that is, ranges are disjoint and have min&lt;=max).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.Segment">
            <summary>
            Used as an input column range.
            A variable length segment (extending to the end of the input line) is represented by Lim == SrcLim.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Segment.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Be careful with this ctor. lim == SrcLim means that this segment extends to
            the end of the input line. If that is not the intent, pass in Min(lim, SrcLim - 1).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Segment.#ctor(System.Int32)">
            <summary>
            Defines a segment that extends from min to the end of input.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.ColInfo">
            <summary>
            Information for an output column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.Options">
            <summary>
            Option flags. These values are serialized, so changing the values requires
            bumping the version number.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.FileContainsValidSchema(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IMultiStreamSource,Microsoft.ML.Runtime.Data.TextLoader.Arguments@)">
            <summary>
            Checks whether the source contains the valid TextLoader.Arguments depiction.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.ReadFile(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.TextLoader.Arguments,Microsoft.ML.Runtime.Data.IMultiStreamSource)">
            <summary>
            Convenience method to create a <see cref="T:Microsoft.ML.Runtime.Data.TextLoader"/> and use it to read a specified file.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Cursor.GetEmbeddedArgs(Microsoft.ML.Runtime.Data.IMultiStreamSource)">
            <summary>
            Look in the first file for args embedded as comments. This gathers comments
            that come before any data line that start with #@.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.Cursor.Consolidator">
            <summary>
            The consolidator object. This simply records the number of threads and checks
            that they match at the end.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.ValueCreatorCache">
            <summary>
            This type exists to provide efficient delegates for creating a ColumnValue specific to a DataKind.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.ParseStats">
            <summary>
            Basic statistics and reporting of unparsable stuff.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.RowSet.#ctor(Microsoft.ML.Runtime.Data.TextLoader.ParseStats,System.Int32,System.Int32)">
            <summary>
            Takes the number of blocks, number of rows per block, and number of columns.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo">
            <summary>
            This is info tracked while scanning a line to find "fields". For each line, the first
            several values, Path, Line, LineText, IchMinText, and IchLimText, are unchanging, but the
            remaining values are updated for each field processed.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.Path">
            <summary>
            Path for the input file containing the given line (may be null).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.Line">
            <summary>
            Line number.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.TextBuf">
            <summary>
            The current text for the entire line (all fields), and possibly more.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.IchMinBuf">
            <summary>
            The min position in <see cref="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.TextBuf"/> to consider (all fields).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.IchLimBuf">
            <summary>
            The lim position in <see cref="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.TextBuf"/> to consider (all fields).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.IchMinNext">
            <summary>
            Where to start for the next field. This is both an input and
            output to the code that fetches the next field.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.Span">
            <summary>
            The (unquoted) text of the field.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.QuotingError">
            <summary>
            Whether there was a quoting error in the field.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.Index">
            <summary>
            For sparse encoding, this is the index of the field. Otherwise, -1.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.IchMin">
            <summary>
            The start character location in <see cref="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.TextBuf"/>, including the sparse index
            and quoting, if present. Used for logging.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.IchLim">
            <summary>
            The end character location in <see cref="F:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.TextBuf"/>, including the sparse index
            and quoting, if present. Used for logging.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.ScanInfo.#ctor(System.ReadOnlyMemory{System.Char}@,System.String,System.Int64)">
            <summary>
            Initializes the ScanInfo.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.Parser.FieldSet">
            <summary>
            This holds a set of raw text fields. This is the input into the parsing
            of the individual typed values.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Parser.FieldSet.EnsureSpace">
            <summary>
            Make sure there is enough space to add one more item.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Parser.TrimEndWhiteSpace(System.ReadOnlyMemory{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Returns a <see cref="T:System.ReadOnlyMemory`1"/> of <see cref="T:System.Char"/> with trailing whitespace trimmed.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.Parser.Helper">
            <summary>
            This is an abstraction containing all the useful stuff for splitting a raw line of text
            into a FieldSet. A cursor has one of these that it passes in whenever it wants a line
            parsed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Parser.HelperImpl.IsSep(System.Char)">
            <summary>
            Check if the given char is a separator.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Parser.HelperImpl.GatherFields(System.ReadOnlyMemory{System.Char},System.ReadOnlySpan{System.Char},System.String,System.Int64)">
            <summary>
            Process the line of text into fields, stored in the Fields field. Ensures that sparse
            don't precede non-sparse. Returns the lim of the src columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.CreateReader``1(Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.Runtime.Data.TextLoader.Context,``0},Microsoft.ML.Runtime.Data.IMultiStreamSource,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Configures a reader for text files.
            </summary>
            <typeparam name="TTupleShape">The type shape parameter, which must be</typeparam>
            <param name="env"></param>
            <param name="func">The delegate that describes what fields to read from the text file, as well as
            describing their input type. The way in which it works is that the delegate is fed a <see cref="T:Microsoft.ML.Runtime.Data.TextLoader.Context"/>,
            and the user composes a value-tuple with <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> instances out of that <see cref="T:Microsoft.ML.Runtime.Data.TextLoader.Context"/>.
            The resulting data will have columns with the names corresponding to their names in the value-tuple.</param>
            <param name="files">Input files. If <c>null</c> then no files are read, but this means that options or
            configurations that require input data for initialization (e.g., <paramref name="hasHeader"/> or
            <see cref="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadFloat(System.Int32,System.Nullable{System.Int32})"/>) with a <c>null</c> second argument.</param>
            <param name="hasHeader">Data file has header with feature names.</param>
            <param name="separator">Text field separator.</param>
            <param name="allowQuoting">Whether the input -may include quoted values, which can contain separator
            characters, colons, and distinguish empty values from missing values. When true, consecutive separators
            denote a missing value and an empty value is denoted by <c>""</c>. When false, consecutive separators
            denote an empty value.</param>
            <param name="allowSparse">Whether the input may include sparse representations.</param>
            <param name="trimWhitspace">Remove trailing whitespace from lines.</param>
            <returns>A configured statically-typed reader for text files.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.IPipelineArgColumn.Create">
            <summary>
            Creates a <see cref="T:Microsoft.ML.Runtime.Data.TextLoader.Column"/> object corresponding to the <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/>, with everything
            filled in except <see cref="F:Microsoft.ML.Runtime.Data.TextLoader.ColInfo.Name"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextLoader.Context">
            <summary>
            Context object by which a user can indicate what fields they want to read from a text file, and what data type they ought to have.
            Instances of this class are never made but the user, but rather are fed into the delegate in
            <see cref="M:Microsoft.ML.Runtime.Data.TextLoader.CreateReader``1(Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.Runtime.Data.TextLoader.Context,``0},Microsoft.ML.Runtime.Data.IMultiStreamSource,System.Boolean,System.Char,System.Boolean,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadBool(System.Int32)">
            <summary>
            Reads a scalar Boolean column from a single field in the text file.
            </summary>
            <param name="ordinal">The zero-based index of the field to read from.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadBool(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Reads a vector Boolean column from a range of fields in the text file.
            </summary>
            <param name="minOrdinal">The zero-based inclusive lower index of the field to read from.</param>
            <param name="maxOrdinal">The zero-based inclusive upper index of the field to read from.
            Note that if this is <c>null</c>, it will read to the end of the line. The file(s)
            will be inspected to get the length of the type.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadFloat(System.Int32)">
            <summary>
            Reads a scalar single-precision floating point column from a single field in the text file.
            </summary>
            <param name="ordinal">The zero-based index of the field to read from.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadFloat(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Reads a vector single-precision column from a range of fields in the text file.
            </summary>
            <param name="minOrdinal">The zero-based inclusive lower index of the field to read from.</param>
            <param name="maxOrdinal">The zero-based inclusive upper index of the field to read from.
            Note that if this is <c>null</c>, it will read to the end of the line. The file(s)
            will be inspected to get the length of the type.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadDouble(System.Int32)">
            <summary>
            Reads a scalar double-precision floating point column from a single field in the text file.
            </summary>
            <param name="ordinal">The zero-based index of the field to read from.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadDouble(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Reads a vector double-precision column from a range of fields in the text file.
            </summary>
            <param name="minOrdinal">The zero-based inclusive lower index of the field to read from.</param>
            <param name="maxOrdinal">The zero-based inclusive upper index of the field to read from.
            Note that if this is <c>null</c>, it will read to the end of the line. The file(s)
            will be inspected to get the length of the type.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadText(System.Int32)">
            <summary>
            Reads a scalar textual column from a single field in the text file.
            </summary>
            <param name="ordinal">The zero-based index of the field to read from.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TextLoader.Context.LoadText(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Reads a vector textual column from a range of fields in the text file.
            </summary>
            <param name="minOrdinal">The zero-based inclusive lower index of the field to read from.</param>
            <param name="maxOrdinal">The zero-based inclusive upper index of the field to read from.
            Note that if this is <c>null</c>, it will read to the end of the line. The file(s)
            will be inspected to get the length of the type.</param>
            <returns>The column representation.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TransformerScope">
            <summary>
            This enum allows for 'tagging' the estimators (and subsequently transformers) in the chain to be used
            'only for training', 'for training and evaluation' etc.
            Most notable example is, transformations over the label column should not be used for scoring, so the scope
            should be <see cref="F:Microsoft.ML.Runtime.Data.TransformerScope.Training"/> or <see cref="F:Microsoft.ML.Runtime.Data.TransformerScope.TrainTest"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TransformerChain`1">
            <summary>
            A chain of transformers (possibly empty) that end with a <typeparamref name="TLastTransformer"/>.
            For an empty chain, <typeparamref name="TLastTransformer"/> is always <see cref="T:Microsoft.ML.Core.Data.ITransformer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransformerChain`1.#ctor(System.Collections.Generic.IEnumerable{Microsoft.ML.Core.Data.ITransformer},System.Collections.Generic.IEnumerable{Microsoft.ML.Runtime.Data.TransformerScope})">
            <summary>
            Create a transformer chain by specifying transformers and their scopes.
            </summary>
            <param name="transformers">Transformers to be chained.</param>
            <param name="scopes">Transformer scopes, parallel to <paramref name="transformers"/>.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransformerChain`1.#ctor(Microsoft.ML.Core.Data.ITransformer[])">
            <summary>
            Create a transformer chain by specifying all the transformers. The scopes are assumed to be
            <see cref="F:Microsoft.ML.Runtime.Data.TransformerScope.Everything"/>.
            </summary>
            <param name="transformers"></param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransformerChain`1.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext)">
            <summary>
            The loading constructor of transformer chain. Reverse of <see cref="M:Microsoft.ML.Runtime.Data.TransformerChain`1.Save(Microsoft.ML.Runtime.Model.ModelSaveContext)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TransformerChain">
            <summary>
            Saving/loading routines for transformer chains.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransformerChain.SaveTo(Microsoft.ML.Core.Data.ITransformer,Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Save any transformer to a stream by wrapping it into a transformer chain.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TrainedWrapperEstimatorBase">
            <summary>
            Estimator for trained wrapped transformers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TrivialWrapperEstimator">
            <summary>
            Estimator for untrained wrapped transformers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TrivialEstimator`1">
             <summary>
             The trivial implementation of <see cref="T:Microsoft.ML.Core.Data.IEstimator`1"/> that already has
             the transformer and returns it on every call to <see cref="M:Microsoft.ML.Runtime.Data.TrivialEstimator`1.Fit(Microsoft.ML.Runtime.Data.IDataView)"/>.
            
             Concrete implementations still have to provide the schema propagation mechanism, since
             there is no easy way to infer it from the transformer.
             </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TrivialReaderEstimator`2">
            <summary>
            The trivial wrapper for a <see cref="T:Microsoft.ML.Core.Data.IDataReader`1"/> that acts as an estimator and ignores the source.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.AppendRowsDataView">
             <summary>
             This class provides the functionality to combine multiple IDataView objects which share the same schema
             All sources must contain the same number of columns and their column names, sizes, and item types must match.
             The row count of the resulting IDataView will be the sum over that of each individual.
            
             An AppendRowsDataView instance is shuffleable iff all of its sources are shuffleable and their row counts are known.
             </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.AppendRowsDataView.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.IDataView[])">
             <summary>
             Create a dataview by appending the rows of the sources.
            
             All sources must be consistent with the passed-in schema in the number of columns, column names,
             and column types. If schema is null, the first source's schema will be used.
             </summary>
             <param name="env">The host environment.</param>
             <param name="schema">The schema for the result. If this is null, the first source's schema will be used.</param>
             <param name="sources">The sources to be appended.</param>
             <returns>The resulting IDataView.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.AppendRowsDataView.Cursor">
            <summary>
            The deterministic cursor. It will scan through the sources sequentially.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.AppendRowsDataView.RandCursor">
            <summary>
             A RandCursor will ask each subordinate cursor to shuffle itself.
            Then, at each step, it randomly calls a subordinate to move next with probability (roughly) proportional to
            the number of the subordinate's remaining rows.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.AppendRowsDataView.MultinomialWithoutReplacementSampler">
             <summary>
             Given k classes with counts (N_0, N_2, N_3, ...,  N_{k-1}), the goal of this sampler is to select the i-th
             class with probability N_i/M, where M = N_0 + N_1 + ... + N_{k-1}.
             Once the i-th class is selected, its count will be updated to N_i - 1.
            
             For efficiency consideration, the sampling distribution is only an approximation of the desired distribution.
             </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder">
            <summary>
            This is a class for composing an in memory IDataView.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.CheckLength``1(System.String,``0[])">
            <summary>
            Verifies that the input array to one of the add routines is of the same length
            as previously added arrays, assuming there were any.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn``1(System.String,Microsoft.ML.Runtime.Data.PrimitiveType,``0[])">
            <summary>
            Constructs a new column from an array where values are copied to output simply
            by being assigned. Output values are returned simply by being assigned, so the
            type <typeparamref name="T"/> should be a type where assigning to a different
            value does not compromise the immutability of the source object (so, for example,
            a scalar, string, or <c>ReadOnlyMemory</c> would be perfectly acceptable, but a
            <c>HashSet</c> or <c>VBuffer</c> would not be).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn(System.String,Microsoft.ML.Runtime.Data.ValueGetter{Microsoft.ML.Runtime.Data.VBuffer{System.ReadOnlyMemory{System.Char}}},System.UInt64,System.Int32,System.UInt32[])">
            <summary>
            Constructs a new key column from an array where values are copied to output simply
            by being assigned.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn``1(System.String,Microsoft.ML.Runtime.Data.ValueGetter{Microsoft.ML.Runtime.Data.VBuffer{System.ReadOnlyMemory{System.Char}}},Microsoft.ML.Runtime.Data.PrimitiveType,``0[][])">
            <summary>
            Creates a column with slot names from arrays. The added column will be re-interpreted as a buffer.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn``1(System.String,Microsoft.ML.Runtime.Data.PrimitiveType,``0[][])">
            <summary>
            Creates a column from arrays. The added column will be re-interpreted as a buffer.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn``1(System.String,Microsoft.ML.Runtime.Data.ValueGetter{Microsoft.ML.Runtime.Data.VBuffer{System.ReadOnlyMemory{System.Char}}},Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.Combiner{``0},``0[][])">
            <summary>
            Creates a column with slot names from arrays. The added column will be re-interpreted as a buffer and possibly sparsified.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn``1(System.String,Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.Combiner{``0},``0[][])">
            <summary>
            Creates a column from arrays. The added column will be re-interpreted as a buffer and possibly sparsified.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn``1(System.String,Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.VBuffer{``0}[])">
            <summary>
            Adds a VBuffer{T} valued column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn``1(System.String,Microsoft.ML.Runtime.Data.ValueGetter{Microsoft.ML.Runtime.Data.VBuffer{System.ReadOnlyMemory{System.Char}}},Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.VBuffer{``0}[])">
            <summary>
            Adds a VBuffer{T} valued column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AddColumn(System.String,System.String[])">
            <summary>
            Adds a <c>ReadOnlyMemory</c> valued column from an array of strings.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.GetDataView(System.Nullable{System.Int32})">
            <summary>
            Constructs a data view from the columns added so far. Note that it is perfectly acceptable
            to continue adding columns to the builder, but these additions will not be reflected in the
            returned dataview.
            </summary>
            <param name="rowCount"></param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.Column`1.CopyOut(System.Int32,`0@)">
            <summary>
            Produce the output value given the index.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.Column`2.CopyOut(`0@,`1@)">
            <summary>
            Assigns dst in such a way that the caller has ownership of <c>dst</c> without
            compromising this object's ownership of <c>src</c>. What that operation will be
            will depend on the types.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.Column`2.CopyOut(System.Int32,`1@)">
            <summary>
            Produce the output value given the index. This overload utilizes the <c>CopyOut</c>
            helper function.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.AssignmentColumn`1">
            <summary>
            A column where the input and output types are the same, and simple assignment does
            not compromise ownership of the internal vlaues.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.StringToTextColumn">
            <summary>
            A convenience column for converting strings into textspans.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.VectorColumn`2.InferType(Microsoft.ML.Runtime.Data.PrimitiveType,`0[],System.Func{`0,System.Int32})">
            <summary>
            A utility function for subclasses that want to get the type with a dimension based
            on the input value array and some length function over the input type.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ArrayDataViewBuilder.VBufferColumn`1">
            <summary>
            A column of buffers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView">
            <summary>
            This is a dataview that wraps another dataview, and does on-demand caching of the
            input columns. When constructed, it caches no data. Whenever a cursor is constructed
            that requests a column that has not yet been cached, any requested uncached columns
            become cached through a background thread worker. A user can provide a hint to the
            constructor to indicate that some columns should be pre-cached. A cursor over this
            dataview will block when moved to a row until such time as all requested columns
            have that row in cache.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.CacheDataView._cacheLock">
            <summary>
            Cursors can be opened from multiple threads simultaneously, so this is used to
            synchronize both at the level of ensuring that only one cache is created per
            column.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.CacheDataView._cacheFillerThreads">
            <summary>
            Filler threads. Currently nothing is done with them. Possibly it may be good
            practice to join against them somehow, but IDataViews as this stage are not
            disposed, so it's unclear what would actually have the job of joining against
            them.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.CacheDataView._caches">
            <summary>
            One cache per column. If this column is not being cached or has been cached,
            this column will be null.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.CacheDataView._cacheDefaultWaiter">
            <summary>
            A waiter used for cursors where no columns are actually requested but it's still
            necesssary to wait to determine the number of rows.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int32[])">
            <summary>
            Constructs an on demand cache for the input.
            </summary>
            <param name="env">The host environment</param>
            <param name="input">The input dataview to cache. Note that if we do not know
            how to cache some columns, these columns will not appear in this dataview.</param>
            <param name="prefetch">A list of column indices the cacher should frontload,
            prior to any cursors being requested. This can be null to indicate no
            prefetching.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.SelectCachableColumns(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Int32[]@,System.Int32[]@)">
            <summary>
            Since shuffling requires serving up items potentially out of order we need to know
            how to save and then copy out values that we read. This transform knows how to save
            and copy out only primitive and vector valued columns, but nothing else, so any
            other columns are dropped.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.MapInputToCacheColumnIndex(System.Int32)">
            <summary>
            While in typical cases the cache data view will know how to cache all columns,
            the cache data view may not know how to cache certain custom types. User code
            may require a mapping from input data view to cache data view column index space.
            </summary>
            <param name="inputIndex">An input data column index</param>
            <returns>The column index of the corresponding column in the cache data view
            if this was cachable, or else -1 if the column was not cachable</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.GetPermutationOrNull(Microsoft.ML.Runtime.IRandom)">
            <summary>
            Returns a permutation or null. This function will return null if either <paramref name="rand"/>
            is null, or if the row count of this cache exceeds the maximum array size.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.Consolidator">
            <summary>
            Minimal consolidator.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.KickoffFiller(System.Int32[])">
            <summary>
            This is a helper method that, given a list of columns, determines the subset
            that are uncached, and if there are any uncached kicks off a filler worker to
            fill them in, over a row cursor over this subset of columns.
            </summary>
            <param name="columns">The requested set of columns</param>
            <seealso cref="M:Microsoft.ML.Runtime.Data.CacheDataView.Filler(Microsoft.ML.Runtime.Data.IRowCursor,Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache[],Microsoft.ML.Runtime.Internal.Utilities.OrderedWaiter)"/>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.Filler(Microsoft.ML.Runtime.Data.IRowCursor,Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache[],Microsoft.ML.Runtime.Internal.Utilities.OrderedWaiter)">
            <summary>
            The actual body of the filler worker. The filler worker works fairly simply:
            for each row, it tells each <see cref="T:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache"/> instance in
            <paramref name="caches"/> to fill in the value at the current position,
            then increments the <paramref name="waiter"/>, then moves to the next row.
            When it's done, it tells <see cref="T:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache"/> to "freeze" itself, since
            there should be no more rows.
            <param name="cursor">The cursor over the rows to cache</param>
            <param name="caches">The caches we must fill and, at the end of the cursor, freeze</param>
            <param name="waiter">The waiter to increment as we cache each additional row</param>
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.Wait">
            <summary>
            Joins all the cache filler threads. This method is currently supposed to be called only by tests.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.IWaiter.Wait(System.Int64)">
             <summary>
             Blocks until that position is either available, or it has been
             determined no such position exists. Implicit in a true return value
             for this is that any values of <paramref name="pos"/> less than are
             also true, that is, if one waits on <c>i</c>, when this returns it
             is equivalent to also having waited on <c>i-1</c>, <c>i-2</c>, etc.
             Note that this is position within the cache, that is, a row index,
             as opposed to position within the cursor.
            
             This method should be thread safe because in the parallel cursor
             case it will be used by multiple threads.
             </summary>
             <param name="pos">The position to wait for, must be positive</param>
             <returns>True if the position can be accessed, false if not</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.TrivialWaiter">
            <summary>
            A waiter for use in situations where there is no real waiting, per se, just a row limit.
            This should be instantiated only if the analogous <see cref="P:Microsoft.ML.Runtime.Data.CacheDataView.WaiterWaiter.IsTrivial"/>
            returned true.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.WaiterWaiter">
            <summary>
            A waiter that determines the necessary waiters for a set of active columns, and waits
            on all of them.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.CacheDataView.WaiterWaiter.IsTrivial">
            <summary>
            If this is true, then a <see cref="T:Microsoft.ML.Runtime.Data.CacheDataView.TrivialWaiter"/> could be used instead.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.IIndex">
            <summary>
            A collection of different simple objects that track the index into the cache at
            particular location. Note that this index is, in the shuffled or parallel case,
            very different from the position of the cursor that keeps this indexer.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.IIndex.GetIndex">
            <summary>
            The index. Callers should never call this either before one of the move
            methods has returned true, or ever after either has returned false.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.IIndex.GetIdGetter">
            <summary>
            An ID getter, which should be based on the value that would be returned
            from <see cref="M:Microsoft.ML.Runtime.Data.CacheDataView.IIndex.GetIndex"/>, if valid, and otherwise have undefined behavior.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.IIndex.MoveNext">
            <summary>
            Moves to the next index. Once this or <see cref="M:Microsoft.ML.Runtime.Data.CacheDataView.IIndex.MoveMany(System.Int64)"/> has returned
            false, it should never be called again. (This in constrast to public
            <see cref="T:Microsoft.ML.Runtime.Data.ICursor"/> objects, whose move methods are robust to that usage.)
            </summary>
            <returns>Whether the next index is available.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.IIndex.MoveMany(System.Int64)">
            <summary>
            Moves to the index this many forward. Once this or <see cref="M:Microsoft.ML.Runtime.Data.CacheDataView.IIndex.MoveNext"/>
            has returned false, it should never be called again.
            </summary>
            <param name="count">The count.</param>
            <returns>Whether the index that many forward is available.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.SequenceIndex`1">
            <summary>
            An <see cref="T:Microsoft.ML.Runtime.Data.CacheDataView.IIndex"/> where the indices, while valid, are sequential increasing
            adjacent indices.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.JobScheduler">
             <summary>
             A simple job scheduler that assigns available jobs (batches/blocks for processing) to
             free workers (cursors/threads). This scheduler takes the ids of the completed jobs into
             account when assigning next jobs in order to minimize workers wait time as the consumer
             of the completed jobs (a.k.a consolidator, see: DataViewUtils.ConsolidateGeneric) can
             only consume jobs in order -according to their ids-. Note that workers get assigned
             next job ids before they push the completed jobs to the consumer. So the workers are
             then subject to being blocked until their current completed jobs are fully accepted
             (i.e. added to the to-consume queue).
            
             How it works:
             Suppose we have 7 workers (w0,..,w6) and 14 jobs (j0,..,j13).
             Initially, jobs get assigned to workers using a shared counter.
             Here is an example outcome of using a shared counter:
             w1->j0, w6->j1, w0->j2, w3->j3, w4->j4, w5->j5, w2->j6.
            
             Suppose workers finished jobs in the following order:
             w5->j5, w0->j2, w6->j1, w4->j4, w3->j3,w1->j0, w2->j6.
            
             w5 finishes processing j5 first, but will be blocked until the processing of jobs
             j0,..,j4 completes since the consumer can consume jobs in order only.
             Therefore, the next available job (j7) should not be assigned to w5. It should be
             assigned to the worker whose job *get consumed first* (w1 since it processes j0
             which is the first job) *not* to the worker who completes its job first (w5 in
             this example).
            
             So, a shared counter can be used to assign jobs to workers initially but should
             not be used onwards.
             </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.BlockSequenceIndex`1">
            <summary>
            An <see cref="T:Microsoft.ML.Runtime.Data.CacheDataView.IIndex"/> that shares a counter among multiple threads. The multiple threads divy up
            the work by blocks of rows rather than splitting row by row simply, both to cut down on interthread
            communication as well as increased locality of thread data access.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.BlockRandomIndex`1">
            <summary>
            An <see cref="T:Microsoft.ML.Runtime.Data.CacheDataView.IIndex"/> that shares a counter among multiple threads. The multiple threads divy up
            the work by blocks of rows rather than splitting row by row simply, to cut down on interthread
            communication.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache">
            <summary>
            A cache of values from a single column. The filler worker fills these in row
            by row, and increments the associated waiter. The consumer for the cache
            waits on the associated waiter (if non-null), then fetches values as it
            determines rows are valid.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache.Waiter">
            <summary>
            The ordered waiter on row indices, indicating when a row index is valid,
            or null if it is no longer necessary to wait on this column, that is,
            it is completely filled in. Multiple columns can share a single waiter
            since often multiple columns are being cached simultaneously, so this
            object is not unqiue to this column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache.Create(Microsoft.ML.Runtime.Data.CacheDataView,Microsoft.ML.Runtime.Data.IRowCursor,System.Int32,Microsoft.ML.Runtime.Internal.Utilities.OrderedWaiter)">
            <summary>
            Creates a cache pipe, over a particular column in a cursor.
            </summary>
            <param name="parent">The cache data view for which we are a cache</param>
            <param name="input">The cursor to read from</param>
            <param name="srcCol">The column of the cursor we are wrapping.</param>
            <param name="waiter">The waiter for the filler associated with this column</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache.CacheCurrent">
            <summary>
            Utilized by the filler worker, to fill in the cache at the current position of the cursor.
            The filler worker will have moved the cursor to the next row prior to calling this, so
            overrides will merely get the value at the current position of the cursor.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache.Freeze">
            <summary>
            Utilized by the filler worker, to indicate to the cache that it will not be receiving
            any more values through <see cref="M:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache.CacheCurrent"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache`1.Fetch(System.Int32,`0@)">
            <summary>
            Utilized by the consumer to get a value in the cache at an index. The
            consumer should coordinate with the <see cref="P:Microsoft.ML.Runtime.Data.CacheDataView.ColumnCache.Waiter"/> member to ensure
            that the row is valid.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CompositeRowToRowMapper">
            <summary>
            A row-to-row mapper that is the result of a chained application of multiple mappers.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeRowToRowMapper.#ctor(Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.IRowToRowMapper[])">
            <summary>
            Out of a series of mappers, construct a seemingly unitary mapper that is able to apply them in sequence.
            </summary>
            <param name="inputSchema">The input schema.</param>
            <param name="mappers">The sequence of mappers to wrap. An empty or <c>null</c> argument
            is legal, and counts as being a no-op application.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.CompositeSchema">
            <summary>
            A convenience class for concatenating several schemas together.
            This would be necessary when combining IDataViews through any type of combining operation, e.g. zip.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeSchema.GetInputPredicates(System.Func{System.Int32,System.Boolean})">
            <summary>
            Returns an array of input predicated for sources, corresponding to the input predicate.
            The returned array size is equal to the number of sources, but if a given source is not needed at all,
            the corresponding predicate will be null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.CompositeSchema.CheckColumnInRange(System.Int32)">
            <summary>
            Checks whether the column index is in range.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.EmptyDataView">
            <summary>
            This implements a data view that has a schema, but no rows.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.LambdaColumnMapper">
            <summary>
            This applies the user provided ValueMapper to a column to produce a new column. It automatically
            injects a standard conversion from the actual type of the source column to typeSrc (if needed).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.LambdaFilter">
            <summary>
            This applies the user provided RefPredicate to a column and drops rows that map to false. It automatically
            injects a standard conversion from the actual type of the source column to typeSrc (if needed).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.OpaqueDataView">
            <summary>
            Opaque IDataView implementation to provide a barrier for data pipe optimizations.
            Used in cross validatation to generate the train/test pipelines for each fold.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IRowMapper">
            <summary>
            This interface is used to create a <see cref="T:Microsoft.ML.Runtime.Data.RowToRowMapperTransform"/>.
            Implementations should be given an <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/> in their constructor, and should have a
            ctor or Create method with <see cref="T:Microsoft.ML.Runtime.Data.SignatureLoadRowMapper"/>, along with a corresponding
            <see cref="T:Microsoft.ML.Runtime.LoadableClassAttribute"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IRowMapper.GetDependencies(System.Func{System.Int32,System.Boolean})">
            <summary>
            Returns the input columns needed for the requested output columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IRowMapper.CreateGetters(Microsoft.ML.Runtime.Data.IRow,System.Func{System.Int32,System.Boolean},System.Action@)">
            <summary>
            Returns the getters for the output columns given an active set of output columns. The length of the getters
            array should be equal to the number of columns added by the IRowMapper. It should contain the getter for the
            i'th output column if activeOutput(i) is true, and null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IRowMapper.GetOutputColumns">
            <summary>
            Returns information about the output columns, including their name, type and any metadata information.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowToRowMapperTransform">
            <summary>
            This class is a transform that can add any number of output columns, that depend on any number of input columns.
            It does so with the help of an <see cref="T:Microsoft.ML.Runtime.Data.IRowMapper"/>, that is given a schema in its constructor, and has methods
            to get the dependencies on input columns and the getters for the output columns, given an active set of output columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowMapperTransform.Bindings.GetActive(System.Func{System.Int32,System.Boolean},System.Func{System.Int32,System.Boolean}@)">
            <summary>
            Produces the set of active columns for the data view (as a bool[] of length bindings.ColumnCount),
            a predicate for the needed active input columns, and a predicate for the needed active
            output columns.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SimpleRow">
            <summary>
            An implementation of <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> that gets its <see cref="P:Microsoft.ML.Runtime.Data.ICounted.Position"/>, <see cref="P:Microsoft.ML.Runtime.Data.ICounted.Batch"/>,
            and <see cref="M:Microsoft.ML.Runtime.Data.ICounted.GetIdGetter"/> from an input row. The constructor requires a schema and array of getter
            delegates. A null delegate indicates an inactive column. The delegates are assumed to be of the appropriate type
            (this does not validate the type).
            REVIEW: Should this validate that the delegates are of the appropriate type? It wouldn't be difficult
            to do so.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SimpleSchemaBase">
            <summary>
            An <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/> that takes all column names and types as constructor parameters.
            The columns do not have metadata.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SimpleSchema">
            <summary>
            An <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/> that takes all column names and types as constructor parameters.
            The columns can optionally have text <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer">
            <summary>
            This provides a scalable method of getting a "transposed" view of a subset of columns from an
            <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. Instances of <see cref="T:Microsoft.ML.Runtime.Data.Transposer"/> act like a wrapped version of
            the input dataview, except that an indicated set of columns will be transposable, even if they
            were not transposable before. Note that transposition is a somewhat slow and resource intensive
            operation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,System.String[])">
            <summary>
            Creates an instance given a list of column names.
            </summary>
            <param name="env">The host environment</param>
            <param name="view">The view whose columns we want to transpose</param>
            <param name="forceSave">Whether the internal transposer should always unconditionally
            save the column we are transposing. Can be useful if the original dataview is possibly
            slow to iterate over that column.</param>
            <param name="columns">The non-empty list of columns to transpose</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,System.Int32[])">
            <summary>
            Creates an instance given a list of column indices.
            </summary>
            <param name="env">The host environment</param>
            <param name="view">The view whose columns we want to transpose</param>
            <param name="forceSave">Whether the internal transposer should always unconditionally
            save the column we are transposing. Can be useful if the original dataview is possibly
            slow to iterate over that column.</param>
            <param name="columns">The non-empty list of columns to transpose</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.SlotCursorVec`1.#ctor(Microsoft.ML.Runtime.Data.Transposer,System.Int32)">
            <summary>
            Constructs a slot cursor.
            </summary>
            <param name="parent">The transposer.</param>
            <param name="col">The index of the transposed column.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.SlotCursorVec`1.EnsureValid">
            <summary>
            Ensures that the column from the source data view stored in our intermediate buffers is the
            current column requested.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer">
            <summary>
            This takes an input data view, and presents a dataset with "sliced" up columns
            that are partitionings of the original columns. Scalar columns and sufficiently
            small vector columns are just served up as themselves. The idea is that each of
            those slices should be small enough that storing an entire column in memory.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.InColToOutRange(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Given the index of a column we were told to split, get the corresponding range out output
            ranges.
            </summary>
            <param name="incol">The index into the array of column indices.</param>
            <param name="outMin">The minimum output column index corresponding to that split column</param>
            <param name="outLim">The exclusive limit of the output column index corresponding to that
            split column</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.CreateInputPredicate(System.Func{System.Int32,System.Boolean},System.Boolean[]@)">
            <summary>
            Given a possibly null predicate for this data view, produce the dependency predicate for the sources,
            as well as a list of all the splitters for which we should produce rowsets.
            </summary>
            <param name="pred">The predicate input into the <see cref="M:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.GetRowCursor(System.Func{System.Int32,System.Boolean},Microsoft.ML.Runtime.IRandom)"/> method.</param>
            <param name="activeSplitters">A boolean indicator array of length equal to the number of splitters,
            indicating whether that splitter has any active columns in its outputs or not</param>
            <returns>The predicate to use when constructing the row cursor from the source</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.SchemaImpl">
            <summary>
            This collates the schemas of all the columns from the <see cref="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter"/> instances.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.NoMetadataSchema">
            <summary>
            Very simple schema base that surfaces no metadata, since I have a couple schema
            implementations neither of which I care about surfacing metadata.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter">
            <summary>
            There is one instance of these per column, implementing the possible splitting
            of one column from a <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> into multiple columns. The instance
            describes the resulting split columns through its implementation of
            <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/>, and then can be bound to an <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> to provide
            that splitting functionality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter.Create(Microsoft.ML.Runtime.Data.IDataView,System.Int32)">
            <summary>
            Creates a splitter for a given row.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter.Bind(Microsoft.ML.Runtime.Data.IRow,System.Func{System.Int32,System.Boolean})">
            <summary>
            Given an input <see cref="T:Microsoft.ML.Runtime.Data.IRow"/>, create the <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> containing the split
            version of the columns.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter.NoSplitter`1">
            <summary>
            A splitter that doesn't split, just passes through the column contents.
            Useful for when we've been told to "split" a column that we don't need
            to split.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter.ColumnSplitter`1">
            <summary>
            This splitter enables the partition of a single column into two or more
            columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter.ColumnSplitter`1.#ctor(Microsoft.ML.Runtime.Data.IDataView,System.Int32,System.Int32[])">
            <summary>
            Provide a column partitioner that partitions a vector column into multiple
            vector columns.
            </summary>
            <param name="view">The view where we are slicing one column</param>
            <param name="col">The column we are slicing</param>
            <param name="lims">Equal in length to the number of slices, this is
            the limit of the indices of each slice, where the successive slice
            starts with that limit as its minimum index. So slice i comes from
            source slot indices from <c><paramref name="lims"/>[i-1]</c> inclusive to
            <c><paramref name="lims"/>[i]</c> exclusive, with slice 0 starting at 0.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Cursor">
            <summary>
            The cursor implementation creates the <see cref="T:Microsoft.ML.Runtime.Data.IRow"/>s using <see cref="M:Microsoft.ML.Runtime.Data.Transposer.DataViewSlicer.Splitter.Bind(Microsoft.ML.Runtime.Data.IRow,System.Func{System.Int32,System.Boolean})"/>,
            then collates the results from those rows as effectively one big row.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransposerUtils.GetSingleSlotValue``1(Microsoft.ML.Runtime.Data.ITransposeDataView,System.Int32,Microsoft.ML.Runtime.Data.VBuffer{``0}@)">
            <summary>
            This is a convenience method that extracts a single slot value's vector,
            while simultaneously verifying that there is exactly one value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransposerUtils.GetGetterWithVectorType``1(Microsoft.ML.Runtime.Data.ISlotCursor,Microsoft.ML.Runtime.IExceptionContext)">
            <summary>
            The <see cref="M:Microsoft.ML.Runtime.Data.ISlotCursor.GetGetter``1"/> is parameterized by a type that becomes the
            type parameter for a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/>, and this is generally preferable and more
            sensible but for various reasons it's often a lot simpler to have a get-getter be over
            the actual type returned by the getter, that is, parameterize this by the actual
            <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/> type.
            </summary>
            <typeparam name="TValue">The type, must be a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/> generic type,
            though enforcement of this has to be done only at runtime for practical reasons</typeparam>
            <param name="cursor">The cursor to get the getter for</param>
            <param name="ctx">The exception contxt</param>
            <returns>The value getter</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransposerUtils.GetRowCursorShim(Microsoft.ML.Runtime.IChannelProvider,Microsoft.ML.Runtime.Data.ISlotCursor)">
            <summary>
            Given a slot cursor, construct a single-column equivalent row cursor, with the single column
            active and having the same type. This is useful to exploit the many utility methods that exist
            to handle <see cref="T:Microsoft.ML.Runtime.Data.IRowCursor"/> and <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> but that know nothing about
            <see cref="T:Microsoft.ML.Runtime.Data.ISlotCursor"/>, without having to rewrite all of them. This is, however, rather
            something of a hack; whenever possible or reasonable the slot cursor should be used directly.
            The name of this column is always "Waffles".
            </summary>
            <param name="provider">The channel provider used in creating the wrapping row cursor</param>
            <param name="cursor">The slot cursor to wrap</param>
            <returns>A row cursor with a single active column with the same type as the slot type</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TransposerUtils.SlotDataView">
            <summary>
            Presents a single transposed column as a single-column dataview.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TransposerUtils.SimpleTransposeSchema">
            <summary>
            This <see cref="T:Microsoft.ML.Runtime.Data.ITransposeSchema"/> implementation wraps an <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/>,
            while indicating that no columns are actually transposed. This is useful for
            <see cref="T:Microsoft.ML.Runtime.Data.ITransposeDataView"/> implementations that are wrapping a data view
            that might not implement that interface.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ZipDataView">
            <summary>
            This is a data view that is a 'zip' of several data views.
            The length of the zipped data view is equal to the shortest of the lengths of the components.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ZipDataView.GetMinimumCursor(Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Create an <see cref="T:Microsoft.ML.Runtime.Data.IRowCursor"/> with no requested columns on a data view.
            Potentially, this can be optimized by calling GetRowCount(lazy:true) first, and if the count is not known,
            wrapping around GetCursor().
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.BufferBuilder`1">
            <summary>
            Helper base class for building feature vectors (sparse or dense). Note that this is abstract
            with some of the esoteric stuff "protected" instead of "public". This is so callees can't
            abuse an instance of it.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BufferBuilder`1.ResetImpl(System.Int32,System.Boolean)">
            <summary>
            This resets the FeatureSet to be used again. This functionality is for memory
            efficiency - we can keep pools of these to be re-used.
            Dense indicates whether this should start out dense. It can, of course,
            become dense when it makes sense to do so.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BufferBuilder`1.SetActiveRangeImpl(System.Int32,System.Int32)">
            <summary>
            This sets the active sub-range of the feature index space. For example, when asking
            a feature handler to add features, we call this so the feature handler can use zero-based
            indexing for the features it is generating. This also prohibits the feature handler from
            messing with a different index range. Note that this is protected so a non-abstract derived
            type can choose how to use it, but a feature handler can't directly mess with the active
            range.
            </summary>
            <param name="ifeat">The min feature index of the active range</param>
            <param name="cfeat">The number of feature indices in the active range</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BufferBuilder`1.AddFeature(System.Int32,`0)">
            <summary>
            Adds a feature to the current active range. If the index is a duplicate, this adds the
            given value to any previously provided value(s).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BufferBuilder`1.SortAndSumDups">
            <summary>
            Sort the indices/values (by index) and sum the values for duplicate indices. This asserts that
            _sorted is false and _dense is false. It also asserts that _count > 1.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BufferBuilder`1.MakeDense">
            <summary>
            Convert a sorted non-dense representation to dense.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BufferBuilder`1.TryGetFeature(System.Int32,`0@)">
            <summary>
            Try to get the value for the given feature. Returns false if the feature index is not found.
            Note that this respects the "active range", just as AddFeature does.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Conversion.Conversions">
            <summary>
            This type exists to provide efficient delegates for conversion between standard ColumnTypes,
            as discussed in the IDataView Type System Specification. This is a singleton class.
            Some conversions are "standard" conversions, conforming to the details in the spec.
            Others are auxilliary conversions. The use of auxilliary conversions should be limited to
            situations that genuinely require them and have been well designed in the particular context.
            For example, this contains non-standard conversions from the standard primitive types to
            text (and StringBuilder). These are needed by the standard TextSaver, which handles
            differences between sparse and dense inputs in a semantically invariant way.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.GetStandardConversion``2(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.ColumnType,System.Boolean@)">
            <summary>
            Return a standard conversion delegate from typeSrc to typeDst. If there is no such standard
            conversion, this throws an exception.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryGetStandardConversion``2(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.ValueMapper{``0,``1}@,System.Boolean@)">
            <summary>
            Determine whether there is a standard conversion from typeSrc to typeDst and if so,
            set conv to the conversion delegate. The type parameters TSrc and TDst must match
            the raw types of typeSrc and typeDst.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.GetStandardConversion(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            Return a standard conversion delegate from typeSrc to typeDst. If there is no such standard
            conversion, this throws an exception.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryGetStandardConversion(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.ColumnType,System.Delegate@,System.Boolean@)">
            <summary>
            Determine whether there is a standard conversion from typeSrc to typeDst and if so,
            set conv to the conversion delegate.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.GetNAOrDefault``1(Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            Returns the NA value of the given type, if it has one, otherwise, it returns
            default of the type. This only knows about NA values of standard scalar types
            and key types.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.GetNAOrDefault``1(Microsoft.ML.Runtime.Data.ColumnType,System.Boolean@)">
            <summary>
            Returns the NA value of the given type, if it has one, otherwise, it returns
            default of the type. This only knows about NA values of standard scalar types
            and key types. Returns whether the returned value is the default value or not.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.GetNAOrDefaultGetter``1(Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            Returns a ValueGetter{T} that produces the NA value of the given type, if it has one,
            otherwise, it produces default of the type. This only knows about NA values of standard
            scalar types and key types.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.Byte@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.UInt16@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.UInt32@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.UInt64@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,Microsoft.ML.Runtime.Data.UInt128@)">
            <summary>
            A parse method that transforms a 34-length string into a <see cref="T:Microsoft.ML.Runtime.Data.UInt128"/>.
            </summary>
            <param name="src">What should be a 34-length hexadecimal representation, including a 0x prefix,
            of the 128-bit number</param>
            <param name="dst">The result</param>
            <returns>Whether the input string was parsed successfully, that is, it was exactly length 32
            and had only digits and the letters 'a' through 'f' or 'A' through 'F' as characters</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.IsStdMissing(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Return true if the span contains a standard text representation of NA
            other than the standard TX missing representation - callers should
            have already dealt with that case and the case of empty.
            The standard representations are any casing of:
               ?  NaN  NA  N/A
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParseKey(System.ReadOnlyMemory{System.Char}@,System.UInt64,System.UInt64,System.UInt64@)">
            <summary>
            Utility to assist in parsing key-type values. The min and max values define
            the legal input value bounds. The output dst value is "normalized" so min is
            mapped to 1, max is mapped to 1 + (max - min).
            Exception is thrown for missing values.
            Unparsable or out of range values are mapped to zero with a false return.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.SByte@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            On failure, it sets dst to the default value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.Int16@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            On failure, it sets dst to the default value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.Int32@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            On failure, it sets dst to the defualt value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.Int64@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable or overflows.
            On failure, it sets dst to the default value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParseNonNegative(System.ReadOnlySpan{System.Char},System.Int64@)">
            <summary>
            Returns false if the text is not parsable as an non-negative long or overflows.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParseSigned(System.Int64,System.ReadOnlyMemory{System.Char}@,System.Nullable{System.Int64}@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable as a signed integer
            or the result overflows. The min legal value is -max. The NA value null.
            When it returns false, result is set to the NA value. The result can be NA on true return,
            since some representations of NA are not considered parse failure.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.Single@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable.
            On failure, it sets dst to the NA value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.Double@)">
            <summary>
            This produces zero for empty. It returns false if the text is not parsable.
            On failure, it sets dst to the NA value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.TryParse(System.ReadOnlyMemory{System.Char}@,System.Boolean@)">
            <summary>
            Try parsing a TX to a BL. This returns false for NA (span.IsMissing).
            Otherwise, it trims the span, then succeeds on all casings of the strings:
            * false, f, no, n, 0, -1, - => false
            * true, t, yes, y, 1, +1, + => true
            Empty string (but not missing string) succeeds and maps to false.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnName(Microsoft.ML.Runtime.Data.ISchema,System.String)">
            <summary>
            Generate a unique temporary column name for the given schema.
            Use tag to independently create multiple temporary, unique column
            names for a single transform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.GetTempColumnNames(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.String)">
            <summary>
            Generate n unique temporary column names for the given schema.
            Use tag to independently create multiple temporary, unique column
            names for a single transform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.ComputeRowCount(Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Get the row count from the input view by any means necessary, even explicit enumeration
            and counting if <see cref="M:Microsoft.ML.Runtime.Data.IDataView.GetRowCount(System.Boolean)"/> insists on returning <c>null</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.GetThreadCount(Microsoft.ML.Runtime.IHost,System.Int32,System.Boolean)">
            <summary>
            Get the target number of threads to use, given a host and another indicator of thread count.
            When num > 0, this uses num limited to twice what the host says. Otherwise, if preferOne
            is true, it returns 1. Otherwise, it returns what the host says.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.TryCreateConsolidatingCursor(Microsoft.ML.Runtime.Data.IRowCursor@,Microsoft.ML.Runtime.Data.IDataView,System.Func{System.Int32,System.Boolean},Microsoft.ML.Runtime.IHost,Microsoft.ML.Runtime.IRandom)">
            <summary>
            Try to create a cursor set from upstream and consolidate it here. The host determines
            the target cardinality of the cursor set.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.CreateSplitCursors(Microsoft.ML.Runtime.Data.IRowCursorConsolidator@,Microsoft.ML.Runtime.IChannelProvider,Microsoft.ML.Runtime.Data.IRowCursor,System.Int32)">
            <summary>
            From the given input cursor, split it into a cursor set with the given
            cardinality. If not all the active columns are cachable, this will only
            produce the given input cursor.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.AllCachable(Microsoft.ML.Runtime.Data.ISchema,System.Func{System.Int32,System.Boolean})">
            <summary>
            Return whether all the active columns, as determined by the predicate, are
            cachable - either primitive types or vector types.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.IsCachable(Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            Determine whether the given type is cachable - either a primitive type or a vector type.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.SameSchemaAndActivity(Microsoft.ML.Runtime.Data.IRowCursor[])">
            <summary>
            Tests whether the cursors are mutually compatible for consolidation,
            that is, they all are non-null, have the same schemas, and the same
            set of columns are active.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.ConsolidateGeneric(Microsoft.ML.Runtime.IChannelProvider,Microsoft.ML.Runtime.Data.IRowCursor[],System.Int32)">
            <summary>
            Given a parallel cursor set, this consolidates them into a single cursor. The batchSize
            is a hint used for efficiency.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter">
             <summary>
             A convenience class to facilitate the creation of a split, as well as a convenient
             place to store shared resources that can be reused among multiple splits of a cursor
             with the same schema. Since splitting also returns a consolidator, this also contains
             a consolidating logic.
            
             In a very rough sense, both the splitters and consolidators are written in the same way:
             For all input cursors, and all active columns, an "in pipe" is created. A worker thread
             per input cursor busily retrieves values from the cursors and stores them in the "in
             pipe." At appropriate times, "batch" objects are synthesized from the inputs consumed
             thusfar, and inserted into a blocking collection. The output cursor or cursors likewise
             have a set of "out pipe" instances, one per each of the active columns, through which
             successive batches are presented for consumption by the user of the output cursors. Of
             course, both split and consolidate have many details from which they differ, e.g., the
             consolidator must accept batches as they come and reconcile them among multiple inputs,
             while the splitter is more free.
            
             It is ideal if a data view that could be split retains one of these objects itself,
             so that multiple splittings will have the capability of sharing buffers from cursoring
             to cursoring, but this is not required.
             </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.ExtraIndex">
            <summary>
            Pipes, in addition to column values, will also communicate extra information
            enumerated within this. This enum serves the purpose of providing nice readable
            indices to these "extra" information in pipes.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.CreateInPipe``1(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            An in pipe creator intended to be used from the splitter only.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.CreateIdInPipe(Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            An in pipe creator intended to be used from the splitter only.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.InPipe">
            <summary>
            There is one of these created per input cursor, per "channel" of information
            (necessary channels include values from active columns, as well as additional
            side information), in both splitting and consolidating. This is a running buffer
            of the input cursor's values. It is used to create <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn"/> objects.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.InPipe.CreateOutPipe(Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            Creates an out pipe corresponding to the in pipe. This is useful for the splitter,
            when we are creating an in pipe.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn">
            <summary>
            These are objects continuously created by the <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.InPipe"/> to spin off the
            values they have collected. They are collected into a <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch"/>
            object, and eventually one is consumed by an <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe"/> instance.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch">
             <summary>
             This holds a collection of <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn"/> objects, which together hold all
             the values from a set of rows from the input cursor. These are produced as needed
             by the input cursor reader, and consumed by each of the output cursors.
            
             This class also serves a secondary role in marshalling exceptions thrown in the workers
             producing batches, into the threads consuming these batches.
             <see cref="P:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch.HasException"/> lets us know if this is one of these "special" batches.
             If it is, then the <see cref="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch.SetAll(Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe[])"/> method will throw whenever it is called, by the
             consumer of the batches.
             </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch.#ctor(Microsoft.ML.Runtime.Internal.Utilities.MadeObjectPool{Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn[]},Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn[],System.Int32,System.Int64)">
            <summary>
            Construct a batch object to communicate the <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn"/> objects to consumers.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch.#ctor(System.Exception)">
            <summary>
            Construct a batch object to communicate that something went wrong. In this case all other fields
            will have default values.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch.SetAll(Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe[])">
             <summary>
             Gives all of the batch columns to the output pipes. This should be called only once,
             per batch object, because the the batch columns will be returned to the pool.
            
             If this was an exception bearing batch, that exception will be propagated and thrown
             in this.
             </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe">
            <summary>
            This helps a cursor present the results of a <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn"/>. Practically its role
            really is to just provide a stable delegate for the <see cref="M:Microsoft.ML.Runtime.Data.IRow.GetGetter``1(System.Int32)"/>.
            There is one of these created per column, per output cursor, i.e., in splitting
            there are <c>n</c> of these created per column, and when consolidating only one of these
            is created per column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe.CreateInPipe(System.Delegate)">
            <summary>
            Creates an in pipe corresponding to this out pipe. Useful for the consolidator,
            when we are creating many in pipes from a single out pipe.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe.Set(Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.BatchColumn)">
            <summary>
            Sets this <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe"/> to start presenting the output of a batch column.
            Note that this positions the output on the first item, not before the first item,
            so it is not necessary to call <see cref="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe.MoveNext"/> to get the first value.
            </summary>
            <param name="batchCol">The batch column whose values we should start presenting.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe.MoveNext">
            <summary>
            Moves to the next value. Note that this should be called only when we are certain that
            we have a next value to move to, that is, when <see cref="P:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe.Remaining"/> is non-zero.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Cursor">
            <summary>
            A cursor used by both the splitter and consolidator, that iteratively consumes
            <see cref="P:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Cursor.Batch"/> objects from the input blocking collection, and yields the
            values stored therein through the help of <see cref="T:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe"/> objects.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Cursor.#ctor(Microsoft.ML.Runtime.IChannelProvider,Microsoft.ML.Runtime.Data.ISchema,System.Int32[],System.Int32[],Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.OutPipe[],System.Collections.Concurrent.BlockingCollection{Microsoft.ML.Runtime.Data.DataViewUtils.Splitter.Batch},System.Action)">
            <summary>
            Constructs one of the split cursors.
            </summary>
            <param name="provider">The channel provider.</param>
            <param name="schema">The schema.</param>
            <param name="activeToCol">The mapping from active indices, to input column indices.</param>
            <param name="colToActive">The reverse mapping from input column indices to active indices,
            where -1 is present if this column is not active.</param>
            <param name="pipes">The output pipes, one per channel of information</param>
            <param name="batchInputs"></param>
            <param name="quitAction"></param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DataViewUtils.SynchronousConsolidatingCursor">
            <summary>
            This is a consolidating cursor that is usable even with cursors that are uncachable,
            at the cost of being totally synchronous, that is, there is no parallel benefit from
            having split the input cursors.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IColumn">
             <summary>
             This interface is an analogy to <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> that encapsulates the contents of a single
             column.
            
             Note that in the same sense that <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> is not thread safe, implementors of this interface
             by similar token must not be considered thread safe by users of the interface, and by the same token
             implementors should feel free to write their implementations with the expectation that only one thread
             will be calling it at a time.
            
             Similarly, in the same sense that an <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> can have its values "change under it" by having
             the underlying cursor move, so too might this item have its values change under it, and they will if
             they were directly instantiated from a row.
            
             Generally actual implementors of this interface should not implement this directly, but instead implement
             <see cref="T:Microsoft.ML.Runtime.Data.IColumn`1"/>.
             </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IColumn.Name">
            <summary>
            The name of a column. This string should always be non-empty.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IColumn.Type">
            <summary>
            The type of the column.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IColumn.Metadata">
            <summary>
            The metadata for a column, or <c>null</c> if this column has no metadata.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IColumn.IsActive">
            <summary>
            Whether the column should be considered active or not.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IColumn.GetGetter">
            <summary>
            The value getter, as a <see cref="T:System.Delegate"/>. Implementators should just pass through
            <see cref="M:Microsoft.ML.Runtime.Data.IColumn`1.GetGetter"/>.
            </summary>
            <returns>The generic getter delegate</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IColumn`1">
            <summary>
            The type specific interface for a <see cref="T:Microsoft.ML.Runtime.Data.IColumn"/>.
            </summary>
            <typeparam name="T">The type of values in this column. This should agree with the <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.RawType"/>
            field of <see name="IRowColumn.Type"/>.</typeparam>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowColumnUtils.GetColumn(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            Exposes a single column in a row.
            </summary>
            <param name="row">The row to wrap</param>
            <param name="col">The column to expose</param>
            <returns>A row column instance</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowColumnUtils.GetColumn(Microsoft.ML.Runtime.Data.ISchema,System.Int32)">
            <summary>
            Exposes a single column in a schema. The column is considered inactive.
            </summary>
            <param name="schema">The schema to get the data for</param>
            <param name="col">The column to get</param>
            <returns>A column with <see cref="P:Microsoft.ML.Runtime.Data.IColumn.IsActive"/> false</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowColumnUtils.GetMetadataAsRow(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Func{System.String,System.Boolean})">
            <summary>
            Wraps the metadata of a column as a row.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowColumnUtils.GetColumn``1(System.String,Microsoft.ML.Runtime.Data.ColumnType,``0@,Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Constructs a column out of a value. This will store the input value, not make a copy.
            </summary>
            <typeparam name="T">The type of the value</typeparam>
            <param name="name">The column name, which must be non-empty</param>
            <param name="type">The type of the column, whose raw type must be <typeparamref name="T"/></param>
            <param name="value">The value to store in the column</param>
            <param name="meta">Optionally, metadata for the column</param>
            <returns>A column with this value</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowColumnUtils.GetColumn``1(System.String,Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.ValueGetter{``0},Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Constructs a column out of a getter.
            </summary>
            <typeparam name="T">The type of the value</typeparam>
            <param name="name">The column name, which must be non-empty</param>
            <param name="type">The type of the column, whose raw type must be <typeparamref name="T"/></param>
            <param name="getter">The getter for the column</param>
            <param name="meta">Optionally, metadata for the column</param>
            <returns>A column with this getter</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowColumnUtils.GetRow(Microsoft.ML.Runtime.Data.ICounted,Microsoft.ML.Runtime.Data.IColumn[])">
            <summary>
            Wraps a set of row columns as a row.
            </summary>
            <param name="counted">The counted object that the output row will wrap for its own implementation of
            <see cref="T:Microsoft.ML.Runtime.Data.ICounted"/>, or if null, the output row will yield default values for those implementations,
            that is, a totally static row</param>
            <param name="columns">A set of row columns</param>
            <returns>A row with items derived from <paramref name="columns"/></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowColumnUtils.CloneColumn(Microsoft.ML.Runtime.Data.IColumn)">
            <summary>
            Given a column, returns a deep-copied memory-materialized version of it. Note that
            it is acceptable for the column to be inactive: the returned column will likewise
            be inactive.
            </summary>
            <param name="column"></param>
            <returns>A memory materialized version of <paramref name="column"/> which may be,
            under appropriate circumstances, the input object itself</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowColumnUtils.RowWrap`1">
            <summary>
            The implementation for a simple wrapping of an <see cref="T:Microsoft.ML.Runtime.Data.IRow"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowColumnUtils.DefaultCounted">
            <summary>
            The base class for a few <see cref="T:Microsoft.ML.Runtime.Data.ICounted"/> implementations that do not "go" anywhere.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowColumnUtils.SchemaWrap`1">
            <summary>
            Simple wrapper for a schema column, considered inctive with no getter.
            </summary>
            <typeparam name="T">The type of the getter</typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowColumnUtils.MetadataRow">
            <summary>
            This class exists to present metadata as stored in an <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/> for one particular
            column as an <see cref="T:Microsoft.ML.Runtime.Data.IRow"/>. This class will cease to be necessary at the point when all
            metadata implementations are just simple <see cref="T:Microsoft.ML.Runtime.Data.IRow"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowColumnUtils.SimpleColumnBase`1">
            <summary>
            This is used for a few <see cref="T:Microsoft.ML.Runtime.Data.IColumn"/> implementations that need to store their own name,
            metadata, and type themselves.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowColumnUtils.RowColumnRow">
            <summary>
            An <see cref="T:Microsoft.ML.Runtime.Data.IRow"/> that is an amalgation of multiple <see cref="T:Microsoft.ML.Runtime.Data.IColumn"/> implementers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IMultiStreamSource">
            <summary>
            An interface for exposing some number of items that can be opened for reading.
            REVIEW: Reconcile this with the functionality exposed by IHostEnvironment. For example,
            we could simply replace this with an array of IFileHandle.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.IMultiStreamSource.Count">
            <summary>
            Gets the number of items.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IMultiStreamSource.GetPathOrNull(System.Int32)">
            <summary>
            Return a string representing the "path" to the index'th stream. May return null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IMultiStreamSource.Open(System.Int32)">
            <summary>
            Opens the indicated item and returns a readable stream on it.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IMultiStreamSource.OpenTextReader(System.Int32)">
            <summary>
            Opens the indicated item and returns a text stream reader on it.
            REVIEW: Consider making this an extension method.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SignatureDataLoader">
            <summary>
            Signature for creating an <see cref="T:Microsoft.ML.Runtime.Data.IDataLoader"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SignatureLoadDataLoader">
            <summary>
            Signature for loading an <see cref="T:Microsoft.ML.Runtime.Data.IDataLoader"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IDataLoader">
            <summary>
            Interface for a data loader. An <see cref="T:Microsoft.ML.Runtime.Data.IDataLoader"/> can save its model information
            and is instantiatable from arguments and an <see cref="T:Microsoft.ML.Runtime.Data.IMultiStreamSource"/> .
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IDataSaver.IsColumnSavable(Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            Check if the column can be saved.
            </summary>
            <returns>True if the column is savable.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IDataSaver.SaveData(System.IO.Stream,Microsoft.ML.Runtime.Data.IDataView,System.Int32[])">
            <summary>
            Save the data into the given stream. The stream should be kept open.
            </summary>
            <param name="stream">The stream that the data will be written.</param>
            <param name="data">The data to be saved.</param>
            <param name="cols">The list of column indices to be saved.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SignatureDataTransform">
            <summary>
            Signature for creating an <see cref="T:Microsoft.ML.Runtime.Data.IDataTransform"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SignatureLoadDataTransform">
            <summary>
            Signature for loading an <see cref="T:Microsoft.ML.Runtime.Data.IDataTransform"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IDataTransform">
            <summary>
            Interface for a data transform. An <see cref="T:Microsoft.ML.Runtime.Data.IDataTransform"/> can save its model information
            and is instantiatable from arguments and an input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ITransformTemplate">
            <summary>
            Data transforms need to be able to apply themselves to a different input IDataView.
            This interface allows them to implement custom rebinding logic.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IRowSeekable">
            <summary>
            Represents a data view that supports random access to a specific row.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IRowSeeker">
            <summary>
            Represents a row seeker with random access that can retrieve a specific row by the row index.
            For IRowSeeker, when the state is valid (that is when MoveTo() returns true), it returns the
            current row index. Otherwise it's -1.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IRowSeeker.MoveTo(System.Int64)">
            <summary>
            Moves the seeker to a row at a specific row index.
            If the row index specified is out of range (less than zero or not less than the
            row count), it returns false and sets its Position property to -1.
            </summary>
            <param name="rowIndex">The row index to move to.</param>
            <returns>True if a row with specified index is found; false otherwise.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ITransposeDataView">
             <summary>
             A view of data where columns can optionally be accessed slot by slot, as opposed to row
             by row in a typical dataview. A slot-accessible column can be accessed with a slot-by-slot
             cursor via an <see cref="T:Microsoft.ML.Runtime.Data.ISlotCursor"/> (naturally, as opposed to row-by-row through an
             <see cref="T:Microsoft.ML.Runtime.Data.IRowCursor"/>). This interface is intended to be implemented by classes that
             want to provide an option for an alternate way of accessing the data stored in a
             <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>.
            
             The interface only advertises that columns may be accessible in slot-wise fashion. A column
             is accessible in this fashion iff <see cref="P:Microsoft.ML.Runtime.Data.ITransposeDataView.TransposeSchema"/>'s
             <see cref="M:Microsoft.ML.Runtime.Data.ITransposeSchema.GetSlotType(System.Int32)"/> returns a non-null value.
             </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.ITransposeDataView.TransposeSchema">
            <summary>
            An enhanced schema, containing information on the transposition properties, if any,
            of each column. Note that there is no contract or suggestion that this property
            should be equal to <see cref="P:Microsoft.ML.Runtime.Data.ISchematized.Schema"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ITransposeDataView.GetSlotCursor(System.Int32)">
            <summary>
            Presents a cursor over the slots of a transposable column, or throws if the column
            is not transposable.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ISlotCursor">
            <summary>
            A cursor that allows slot-by-slot access of data.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ISlotCursor.GetSlotType">
            <summary>
            The slot type for this cursor. Note that this should equal the
            <see cref="M:Microsoft.ML.Runtime.Data.ITransposeSchema.GetSlotType(System.Int32)"/> for the column from which this slot cursor
            was created.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ISlotCursor.GetGetter``1">
            <summary>
            A getter delegate for the slot values. The type <typeparamref name="TValue"/> must correspond
            to the item type from <see cref="M:Microsoft.ML.Runtime.Data.ITransposeSchema.GetSlotType(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ITransposeSchema">
            <summary>
            The transpose schema returns the schema information of the view we have transposed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ITransposeSchema.GetSlotType(System.Int32)">
            <summary>
            Analogous to <see cref="M:Microsoft.ML.Runtime.Data.ISchema.GetColumnType(System.Int32)"/>, except instead of returning the type of value
            accessible through the <see cref="T:Microsoft.ML.Runtime.Data.IRowCursor"/>, returns the item type of value accessible
            through the <see cref="T:Microsoft.ML.Runtime.Data.ISlotCursor"/>. This will return <c>null</c> iff this particular
            column is not transposable, that is, it cannot be viewed in a slotwise fashion. Observe from
            the return type that this will always be a vector type. This vector type should be of fixed
            size and one dimension.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetGetterAsDelegate(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            Returns an appropriate <see cref="T:Microsoft.ML.Runtime.Data.ValueGetter`1"/> for a row given an active column
            index, but as a delegate. The type parameter for the delegate will correspond to the
            raw type of the column.
            </summary>
            <param name="row">The row to get the getter for</param>
            <param name="col">The column index, which must be active on that row</param>
            <returns>The getter as a delegate</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetGetterAs(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            Given a destination type, IRow, and column index, return a ValueGetter for the column
            with a conversion to typeDst, if needed. This is a weakly typed version of
            <see cref="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetGetterAs``1(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.IRow,System.Int32)"/>.
            </summary>
            <seealso cref="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetGetterAs``1(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.IRow,System.Int32)"/>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetGetterAs``1(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            Given a destination type, IRow, and column index, return a ValueGetter{TDst} for the column
            with a conversion to typeDst, if needed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetGetterAsStringBuilder(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            Given an IRow, and column index, return a function that utilizes the
            <see cref="M:Microsoft.ML.Runtime.Data.Conversion.Conversions.GetStringConversion``1(Microsoft.ML.Runtime.Data.ColumnType)"/> on the input
            rows to map the values in the column, whatever type they may be, into a string
            builder. This method will obviously succeed only if there is a string conversion
            into the required type. This method can be useful if you want to output a value
            as a string in a generic way, but don't really care how you do it.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetVecGetterAs(Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            Given the item type, typeDst, a row, and column index, return a ValueGetter for the vector-valued
            column with a conversion to a vector of typeDst, if needed. This is the weakly typed version of
            <see cref="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetVecGetterAs``1(Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.IRow,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetVecGetterAs``1(Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            Given the item type, typeDst, a row, and column index, return a ValueGetter{VBuffer{TDst}} for the
            vector-valued column with a conversion to a vector of typeDst, if needed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetVecGetterAs``1(Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.ISlotCursor)">
            <summary>
            Given the item type, typeDst, and a slot cursor, return a ValueGetter{VBuffer{TDst}} for the
            vector-valued column with a conversion to a vector of typeDst, if needed.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowCursorUtils.GetterFactory">
            <summary>
            A convenience wrapper to generalize the operation of fetching a <see cref="T:Microsoft.ML.Runtime.Data.ValueGetter`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.GetIsNewGroupDelegate(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            This method returns a small helper delegate that returns whether we are at the start
            of a new group, that is, we have just started, or the key-value at indicated column
            is different than it was, in the last call. This is practically useful for determining
            group boundaries. Note that the delegate will return true on the first row.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.CloneRow(Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Returns a row that is a deep in-memory copy of an input row. Note that inactive
            columns are allowed in this row, and their activity or inactivity will be reflected
            in the output row. Note that the deep copy includes a copy of the metadata as well.
            </summary>
            <param name="row">The input row</param>
            <returns>A deep in-memory copy of the input row</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.Fetch``1(Microsoft.ML.Runtime.IExceptionContext,Microsoft.ML.Runtime.Data.IRow,System.String)">
            <summary>
            Fetches the value of the column by name, in the given row.
            Used by the evaluators to retrieve the metrics from the results IDataView.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowCursorUtils.RowAsDataView(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Given a row, returns a one-row data view. This is useful for cases where you have a row, and you
            wish to use some facility normally only exposed to dataviews. (E.g., you have an <see cref="T:Microsoft.ML.Runtime.Data.IRow"/>
            but want to save it somewhere using a <see cref="T:Microsoft.ML.Runtime.Data.IO.BinarySaver"/>.)
            Note that it is not possible for this method to ensure that the input <paramref name="row"/> does not
            change, so users of this convenience must take care of what they do with the input row or the data
            source it came from, while the returned dataview is potentially being used; if this is somehow
            difficult it may be wise to use <see cref="M:Microsoft.ML.Runtime.Data.RowCursorUtils.CloneRow(Microsoft.ML.Runtime.Data.IRow)"/> to first have a deep copy of the resulting row.
            </summary>
            <param name="env">An environment used to create the host for the resulting data view</param>
            <param name="row">A row, whose columns must all be active</param>
            <returns>A single-row data view incorporating that row</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ChooseColumnsByIndexTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ChooseColumnsByIndexTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public constructor corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.AnomalyDetectionEvaluator.TopKResults">
            <summary>
            The anomaly detection evaluator outputs a data view by this name, which contains the the examples
            with the top scores in the test set. It contains the three columns listed below, with each row corresponding
            to one test example.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.EvaluatorBase`1">
            <summary>
            This is a base class for TLC evaluators. It implements both of the <see cref="T:Microsoft.ML.Runtime.Data.IEvaluator"/> methods: <see cref="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.Evaluate(Microsoft.ML.Runtime.Data.RoleMappedData)"/> and
             <see cref="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.GetPerInstanceMetrics(Microsoft.ML.Runtime.Data.RoleMappedData)"/>. Note that the input <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedData"/> is assumed to contain all the column
            roles needed for evaluation, including the score column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.UnweightedAuPrcAggregator.ComputeWeightedAuPrcCore(System.Double@)">
            <summary>
            Compute the AUPRC using the "lower trapesoid" estimator, as described in the paper
            <a href="https://www.ecmlpkdd2013.org/wp-content/uploads/2013/07/aucpr_2013ecml_corrected.pdf">https://www.ecmlpkdd2013.org/wp-content/uploads/2013/07/aucpr_2013ecml_corrected.pdf</a>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.WeightedAuPrcAggregator.ComputeWeightedAuPrcCore(System.Double@)">
            <summary>
            Compute the AUPRC using the "lower trapesoid" estimator, as described in the paper
            <a href="https://www.ecmlpkdd2013.org/wp-content/uploads/2013/07/aucpr_2013ecml_corrected.pdf">https://www.ecmlpkdd2013.org/wp-content/uploads/2013/07/aucpr_2013ecml_corrected.pdf</a>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.CheckColumnTypes(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Checks the column types of the evaluator's input columns. The base class implementation checks only the type
            of the weight column, and all other columns should be checked by the deriving classes in <see cref="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.CheckCustomColumnTypesCore(Microsoft.ML.Runtime.Data.RoleMappedSchema)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.CheckScoreAndLabelTypes(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Check that the types of the score and label columns are as expected by the evaluator. The <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedSchema"/>
            is assumed to contain the label column (if it exists) and the score column.
            Access the label column with the <see cref="P:Microsoft.ML.Runtime.Data.RoleMappedSchema.Label"/> property, and the score column with the
            <see cref="M:Microsoft.ML.Runtime.Data.RoleMappedSchema.GetUniqueColumn(Microsoft.ML.Runtime.Data.RoleMappedSchema.ColumnRole)"/> or <see cref="M:Microsoft.ML.Runtime.Data.RoleMappedSchema.GetColumns(Microsoft.ML.Runtime.Data.RoleMappedSchema.ColumnRole)"/> methods.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.CheckCustomColumnTypesCore(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Check the types of any other columns needed by the evaluator. Only override if the evaluator uses
            columns other than label, score and weight.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.GetActiveColsCore(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Used in the Evaluate() method, to get the predicate for cursoring over the data.
            The base class implementation activates the score column, the label column if it exists, the weight column if it exists
            and the stratification columns.
            Override if other input columns need to be activated.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.GetAggregator(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Get an aggregator for the specific evaluator given the current RoleMappedSchema.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.GetAggregatorDictionaries(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            For each stratification column, get an aggregator dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.GetAggregatorConsolidationFuncs(`0,Microsoft.ML.Runtime.Data.EvaluatorBase{`0}.AggregatorDictionaryBase[],System.Action{System.UInt32,System.ReadOnlyMemory{System.Char},`0}@,System.Func{System.Collections.Generic.Dictionary{System.String,Microsoft.ML.Runtime.Data.IDataView}}@)">
            <summary>
            This method returns two functions used to create the data views of metrics computed by the different
            aggregators (the overall one, and any stratified ones if they exist). The <paramref name="addAgg"/>
            function is called for every aggregator, and it is where the aggregators should finish their aggregations
            and the aggregator results should be stored. The <paramref name="consolidate"/> function
            is called after <paramref name="addAgg"/> has been called on all the aggregators, and it returns
            the dictionary of metric data views.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase">
            <summary>
            This is a helper class for evaluators deriving from EvaluatorBase, used for computing aggregate metrics.
            Aggregators should keep track of the number of passes done. The <see cref="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase.InitializeNextPass(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)"/> method should get
            the input getters of the given IRow that are needed for the current pass, assuming that all the needed column
            information is stored in the given <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedSchema"/>.
            In <see cref="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase.ProcessRow"/> the aggregator should call the getters once, and process the input as needed.
            <see cref="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase.FinishPass"/> increments the pass count after each pass.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase.InitializeNextPass(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            This method should get the getters of the new IRow that are needed for the next pass.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase.ProcessRow">
            <summary>
            Call the getters once, and process the input as necessary.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase.FinishPass">
            <summary>
            Increment the pass count. Return true if additional passes are needed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorBase.GetWarnings(System.Collections.Generic.Dictionary{System.String,Microsoft.ML.Runtime.Data.IDataView},Microsoft.ML.Runtime.IHostEnvironment)">
            <summary>
            Returns a dictionary from metric kinds to data views containing the metrics.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorDictionaryBase.Reset(Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Gets the stratification column getter for the new IRow.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorDictionaryBase.Get">
            <summary>
            This method calls the getter of the stratification column, and returns the aggregator corresponding to
            the stratification value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorBase`1.AggregatorDictionaryBase.GetAll">
            <summary>
            This method returns the aggregators corresponding to all the stratification values seen so far.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.PrCurve">
            <summary>
            Binary classification evaluator outputs a data view with this name, which contains the p/r data.
            It contains the columns listed below, and in case data also contains a weight column, it contains
            also columns for the weighted values.
            and false positive rate.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result">
            <summary>
            Evaluation results for binary classifiers, excluding probabilistic metrics.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.Auc">
            <summary>
            Gets the area under the ROC curve.
            </summary>
            <remarks>
            The area under the ROC curve is equal to the probability that the classifier ranks
            a randomly chosen positive instance higher than a randomly chosen negative one
            (assuming 'positive' ranks higher than 'negative').
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.Accuracy">
            <summary>
            Gets the accuracy of a classifier which is the proportion of correct predictions in the test set.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.PositivePrecision">
            <summary>
            Gets the positive precision of a classifier which is the proportion of correctly predicted
            positive instances among all the positive predictions (i.e., the number of positive instances
            predicted as positive, divided by the total number of instances predicted as positive).
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.PositiveRecall">
            <summary>
            Gets the positive recall of a classifier which is the proportion of correctly predicted
            positive instances among all the positive instances (i.e., the number of positive instances
            predicted as positive, divided by the total number of positive instances).
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.NegativePrecision">
            <summary>
            Gets the negative precision of a classifier which is the proportion of correctly predicted
            negative instances among all the negative predictions (i.e., the number of negative instances
            predicted as negative, divided by the total number of instances predicted as negative).
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.NegativeRecall">
            <summary>
            Gets the negative recall of a classifier which is the proportion of correctly predicted
            negative instances among all the negative instances (i.e., the number of negative instances
            predicted as negative, divided by the total number of negative instances).
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.F1Score">
            <summary>
            Gets the F1 score of the classifier.
            </summary>
            <remarks>
            F1 score is the harmonic mean of precision and recall: 2 * precision * recall / (precision + recall).
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Result.Auprc">
            <summary>
            Gets the area under the precision/recall curve of the classifier.
            </summary>
            <remarks>
            The area under the precision/recall curve is a single number summary of the information in the
            precision/recall curve. It is increasingly used in the machine learning community, particularly
            for imbalanced datasets where one class is observed more frequently than the other. On these
            datasets, AUPRC can highlight performance differences that are lost with AUC.
            </remarks>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult">
            <summary>
            Evaluation results for binary classifiers, including probabilistic metrics.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult.LogLoss">
            <summary>
            Gets the log-loss of the classifier.
            </summary>
            <remarks>
            The log-loss metric, is computed as follows:
            LL = - (1/m) * sum( log(p[i]))
            where m is the number of instances in the test set.
            p[i] is the probability returned by the classifier if the instance belongs to class 1,
            and 1 minus the probability returned by the classifier if the instance belongs to class 0.
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult.LogLossReduction">
            <summary>
            Gets the log-loss reduction (also known as relative log-loss, or reduction in information gain - RIG)
            of the classifier.
            </summary>
            <remarks>
            The log-loss reduction is scaled relative to a classifier that predicts the prior for every example:
            (LL(prior) - LL(classifier)) / LL(prior)
            This metric can be interpreted as the advantage of the classifier over a random prediction.
            E.g., if the RIG equals 20, it can be interpreted as &quot;the probability of a correct prediction is
            20% better than random guessing.&quot;
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.CalibratedResult.Entropy">
            <summary>
            Gets the test-set entropy (prior Log-Loss/instance) of the classifier.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String,System.String)">
            <summary>
            Evaluates scored binary classification data.
            </summary>
            <param name="data">The scored data.</param>
            <param name="label">The name of the label column in <paramref name="data"/>.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="probability">The name of the probability column in <paramref name="data"/>, the calibrated version of <paramref name="score"/>.</param>
            <param name="predictedLabel">The name of the predicted label column in <paramref name="data"/>.</param>
            <returns>The evaluation results for these calibrated outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String)">
            <summary>
            Evaluates scored binary classification data, without probability-based metrics.
            </summary>
            <param name="data">The scored data.</param>
            <param name="label">The name of the label column in <paramref name="data"/>.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="predictedLabel">The name of the predicted label column in <paramref name="data"/>.</param>
            <returns>The evaluation results for these uncalibrated outputs.</returns>
            <seealso cref="M:Microsoft.ML.Runtime.Data.BinaryClassifierEvaluator.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ClusteringEvaluator.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String)">
            <summary>
            Evaluates scored clustering data.
            </summary>
            <param name="data">The scored data.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="label">The name of the optional label column in <paramref name="data"/>.</param>
            <param name="features">The name of the optional feature column in <paramref name="data"/>.</param>
            <returns>The evaluation results.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result">
            <summary>
            The metrics generated after evaluating the clustering predictions.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result.Nmi">
            <summary>
            Normalized Mutual Information
            NMI is a measure of the mutual dependence of the variables.
            <a href="http://en.wikipedia.org/wiki/Mutual_information#Normalized_variants">Normalized variants</a> work on data that already has cluster labels.
            Its value ranged from 0 to 1, where higher numbers are better.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result.AvgMinScore">
            <summary>
            Average Score. For the K-Means algorithm, the 'score' is the distance from the centroid to the example.
            The average score is, therefore, a measure of proximity of the examples to cluster centroids.
            In other words, it's the 'cluster tightness' measure.
            Note however, that this metric will only decrease if the number of clusters is increased,
            and in the extreme case (where each distinct example is its own cluster) it will be equal to zero.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result.Dbi">
            <summary>
            <a href="https://en.wikipedia.org/wiki/DaviesBouldin_index">Davies-Bouldin Index</a>
            DBI is a measure of the how much scatter is in the cluster and the cluster separation.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.PerInstanceEvaluatorBase">
            <summary>
            This is a helper class for creating the per-instance IDV.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions">
            <summary>
            Extension methods for evaluation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})">
            <summary>
            Evaluates scored binary classification data.
            </summary>
            <typeparam name="T">The shape type for the input data.</typeparam>
            <param name="ctx">The binary classification context.</param>
            <param name="data">The data to evaluate.</param>
            <param name="label">The index delegate for the label column.</param>
            <param name="pred">The index delegate for columns from calibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
            <returns>The evaluation results for these calibrated outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Boolean}}})">
            <summary>
            Evaluates scored binary classification data, if the predictions are not calibrated.
            </summary>
            <typeparam name="T">The shape type for the input data.</typeparam>
            <param name="ctx">The binary classification context.</param>
            <param name="data">The data to evaluate.</param>
            <param name="label">The index delegate for the label column.</param>
            <param name="pred">The index delegate for columns from uncalibrated prediction of a binary classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
            <returns>The evaluation results for these uncalibrated outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.ClusteringContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Func{``0,Microsoft.ML.StaticPipe.Vector{System.Single}})">
            <summary>
            Evaluates scored clustering prediction data.
            </summary>
            <typeparam name="T">The shape type for the input data.</typeparam>
            <param name="ctx">The clustering context.</param>
            <param name="data">The data to evaluate.</param>
            <param name="score">The index delegate for the predicted score column.</param>
            <param name="label">The optional index delegate for the label column.</param>
            <param name="features">The optional index delegate for the features column.</param>
            <returns>The evaluation metrics.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``2(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Key{System.UInt32,``1}},System.Func{``0,System.ValueTuple{Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Key{System.UInt32,``1}}},System.Int32)">
            <summary>
            Evaluates scored multiclass classification data.
            </summary>
            <typeparam name="T">The shape type for the input data.</typeparam>
            <typeparam name="TKey">The value type for the key label.</typeparam>
            <param name="ctx">The multiclass classification context.</param>
            <param name="data">The data to evaluate.</param>
            <param name="label">The index delegate for the label column.</param>
            <param name="pred">The index delegate for columns from the prediction of a multiclass classifier.
            Under typical scenarios, this will just be the same tuple of results returned from the trainer.</param>
            <param name="topK">If given a positive value, the <see cref="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.TopKAccuracy"/> will be filled with
            the top-K accuracy, that is, the accuracy assuming we consider an example with the correct class within
            the top-K values as being stored "correctly."</param>
            <returns>The evaluation metrics.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluatorStaticExtensions.Evaluate``1(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Func{``0,Microsoft.ML.StaticPipe.Scalar{System.Single}},Microsoft.ML.Runtime.IRegressionLoss)">
            <summary>
            Evaluates scored regression data.
            </summary>
            <typeparam name="T">The shape type for the input data.</typeparam>
            <param name="ctx">The regression context.</param>
            <param name="data">The data to evaluate.</param>
            <param name="label">The index delegate for the label column.</param>
            <param name="score">The index delegate for predicted score column.</param>
            <param name="loss">Potentially custom loss function. If left unspecified defaults to <see cref="T:Microsoft.ML.Runtime.SquaredLoss"/>.</param>
            <returns>The evaluation metrics.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.GetScoreColumnInfo(Microsoft.ML.Runtime.IExceptionContext,Microsoft.ML.Runtime.Data.ISchema,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Find the score column to use. If name is specified, that is used. Otherwise, this searches for the
            most recent score set of the given kind. If there is no such score set and defName is specifed it
            uses defName. Otherwise, it throws.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.GetOptAuxScoreColumnInfo(Microsoft.ML.Runtime.IExceptionContext,Microsoft.ML.Runtime.Data.ISchema,System.String,System.String,System.Int32,System.String,System.Func{Microsoft.ML.Runtime.Data.ColumnType,System.Boolean})">
            <summary>
            Find the optional auxilliary score column to use. If name is specified, that is used.
            Otherwise, if colScore is part of a score set, this looks in the score set for a column
            with the given valueKind. If none is found, it returns null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.GetColName(System.String,Microsoft.ML.Runtime.Data.ColumnInfo,System.String)">
            <summary>
            If str is non-empty, returns it. Otherwise if info is non-null, returns info.Name.
            Otherwise, returns def.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.GetMetrics(Microsoft.ML.Runtime.Data.IDataView,System.Boolean)">
            <summary>
            Helper method to get an IEnumerable of double metrics from an overall metrics IDV produced by an evaluator.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.AddFoldIndex(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int32)">
            <summary>
            Add a text column containing a fold index to a data view.
            </summary>
            <param name="env">The host environment.</param>
            <param name="input">The data view to which we add the column</param>
            <param name="curFold">The current fold this data view belongs to.</param>
            <returns>The input data view with an additional text column containing the current fold index.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.AddFoldIndex(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int32,System.Int32)">
            <summary>
            Add a key type column containing a fold index to a data view.
            </summary>
            <param name="env">The host environment.</param>
            <param name="input">The data view to which we add the column</param>
            <param name="curFold">The current fold this data view belongs to.</param>
            <param name="numFolds">The total number of folds.</param>
            <returns>The input data view with an additional key type column containing the current fold index.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.ReconcileSlotNames``1(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView[],System.String,Microsoft.ML.Runtime.Data.PrimitiveType,``0)">
            <summary>
            This method takes an array of data views and a specified input vector column, and adds a new output column to each of the data views.
            First, we find the union set of the slot names in the different data views. Next we define a new vector column for each
            data view, indexed by the union of the slot names. For each data view, every slot value is the value in the slot corresponding
            to its slot name in the original column. If a reconciled slot name does not exist in an input column, the value in the output
            column is def.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.ReconcileKeyValues(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView[],System.String,Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            This method takes an array of data views and a specified input key column, and adds a new output column to each of the data views.
            First, we find the union set of the key values in the different data views. Next we define a new key column for each
            data view, with the union of the key values as the new key values. For each data view, the value in the output column is the value
            corresponding to the key value in the original column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.ReconcileKeyValuesWithNoNames(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView[],System.String,System.Int32)">
            <summary>
            This method takes an array of data views and a specified input key column, and adds a new output column to each of the data views.
            First, we find the union set of the key values in the different data views. Next we define a new key column for each
            data view, with the union of the key values as the new key values. For each data view, the value in the output column is the value
            corresponding to the key value in the original column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.ReconcileVectorKeyValues(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView[],System.String,Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            This method is similar to <see cref="M:Microsoft.ML.Runtime.Data.EvaluateUtils.ReconcileKeyValues(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView[],System.String,Microsoft.ML.Runtime.Data.ColumnType)"/>, but it reconciles the key values over vector
            input columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.ConcatenatePerInstanceDataViews(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IMamlEvaluator,System.Boolean,System.Boolean,Microsoft.ML.Runtime.Data.RoleMappedData[],System.String[]@)">
            <summary>
            This method gets the per-instance metrics from multiple scored data views and either returns them as an
            array or combines them into a single data view, based on user specifications.
            </summary>
            <param name="env">A host environment.</param>
            <param name="eval">The evaluator to use for getting the per-instance metrics.</param>
            <param name="collate">If true, data views are combined into a single data view. Otherwise, data views
            are returned as an array.</param>
            <param name="outputFoldIndex">If true, a column containing the fold index is added to the returned data views.</param>
            <param name="perInstance">The array of scored data views to evaluate. These are passed as <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedData"/>
            so that the evaluator can know the role mappings it needs.</param>
            <param name="variableSizeVectorColumnNames">A list of column names that are not included in the combined data view
            since their types do not match.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.ConcatenateOverallMetrics(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView[])">
            <summary>
            Create an output data view that is the vertical concatenation of the metric data views.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.EvaluateUtils.CombineFoldMetricsDataViews(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int32)">
            <summary>
            Takes a data view containing one or more rows of metrics, and returns a data view containing additional
            rows with the average and the standard deviation of the metrics in the input data view.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetricWriter.GetConfusionTable(Microsoft.ML.Runtime.IHost,Microsoft.ML.Runtime.Data.IDataView,System.String@,System.Boolean,System.Int32)">
            <summary>
            Get the confusion tables as strings to be printed to the Console.
            </summary>
            <param name="host">The host is used for getting the random number generator for sampling classes</param>
            <param name="confusionDataView">The data view containing the confusion matrix. It should contain a text column
            with the label names named "LabelNames", and an R8 vector column named "Count" containing the counts: in the row
            corresponding to label i, slot j should contain the number of class i examples that were predicted as j by the predictor.</param>
            <param name="weightedConfusionTable">If there is an R8 vector column named "Weight" containing the weighted counts, this parameter
            is assigned the string representation of the weighted confusion table. Otherwise it is assigned null.</param>
            <param name="binary">Indicates whether the confusion table is for binary classification.</param>
            <param name="sample">Indicates how many classes to sample from the confusion table (-1 indicates no sampling)</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetricWriter.GetPerFoldResults(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String@)">
            <summary>
            This method returns the per-fold metrics as a string. If weighted metrics are present they are returned in a separate string.
            </summary>
            <param name="env">An IHostEnvironment.</param>
            <param name="fold">The data view containing the per-fold metrics. Each row in the data view represents a set of metrics
            calculated either on the whole dataset or on a subset of it defined by a stratification column. If the data view contains
            stratified metrics, it must contain two text columns named "StratCol" and "StratVal", containing the stratification column
            name, and a text description of the value. In this case, the value of column StratVal in the row corresponding to the entire
            dataset should contain the text "overall", and the value of column StratCol should be DvText.NA. If weighted metrics are present
            then the data view should also contain a bool column named "IsWeighted".</param>
            <param name="weightedMetrics">If the IsWeighted column exists, this is assigned the string representation of the weighted
            metrics. Otherwise it is assigned null.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetricWriter.PrintOverallMetrics(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,System.String,Microsoft.ML.Runtime.Data.IDataView,System.Int32)">
            <summary>
            Print the overall results to the Console. The overall data view should contain rows from all the folds being averaged.
            If filename is not null then also save the results to the specified file. The first row in the file is the averaged
            results, followed by the results of each fold.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetricWriter.PrintWarnings(Microsoft.ML.Runtime.IChannel,System.Collections.Generic.Dictionary{System.String,Microsoft.ML.Runtime.Data.IDataView})">
            <summary>
            Searches for a warning dataview in the given dictionary, and if present, prints the warnings to the given channel. The warning dataview
            should contain a text column named "WarningText".
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetricWriter.SavePerInstance(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,System.String,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,System.Boolean)">
            <summary>
             Save the given data view using text saver.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetricWriter.GetNonStratifiedMetrics(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Filter out the stratified results from overall and drop the stratification columns.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetricKinds">
            <summary>
            This is a list of string constants denoting 'standard' metric kinds.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.MetricKinds.ConfusionMatrix">
            <summary>
            This data view contains the confusion matrix for N-class classification. It has N rows, and each row has
            the following columns:
            * Count (vector indicating how many examples of this class were predicted as each one of the classes). This column
            should have metadata containing the class names.
            * (Optional) Weight (vector with the total weight of the examples of this class that were predicted as each one of the classes).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.MetricKinds.OverallMetrics">
            <summary>
            This is a data view with 'global' dataset-wise metrics in its columns. It has one row containing the overall metrics,
            and optionally more rows for weighted metrics, and stratified metrics.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.MetricKinds.Warnings">
            <summary>
            This data view contains a single text column, with warnings about bad input values encountered by the evaluator during
            the aggregation of metrics. Each warning is in a separate row.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetricKinds.ColumnNames">
            <summary>
            Names for the columns in the data views output by evaluators.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IMamlEvaluator">
            <summary>
            This interface is used by Maml components (the <see cref="T:Microsoft.ML.Runtime.Data.EvaluateCommand"/>, the <see cref="T:Microsoft.ML.Runtime.Data.CrossValidationCommand"/>
            and the <see cref="T:Microsoft.ML.Runtime.Data.EvaluateTransform"/> to evaluate, print and save the results.
            The input <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedData"/> to the <see cref="M:Microsoft.ML.Runtime.Data.IEvaluator.Evaluate(Microsoft.ML.Runtime.Data.RoleMappedData)"/> and the <see cref="M:Microsoft.ML.Runtime.Data.IEvaluator.GetPerInstanceMetrics(Microsoft.ML.Runtime.Data.RoleMappedData)"/> methods
            should be assumed to contain only the following column roles: label, group, weight and name. Any other columns needed for
            evaluation should be searched for by name in the <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IMamlEvaluator.PrintFoldResults(Microsoft.ML.Runtime.IChannel,System.Collections.Generic.Dictionary{System.String,Microsoft.ML.Runtime.Data.IDataView})">
            <summary>
            Print the aggregate metrics to the console.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IMamlEvaluator.GetOverallResults(Microsoft.ML.Runtime.Data.IDataView[])">
            <summary>
            Combine the overall metrics from multiple folds into a single data view.
            </summary>
            <param name="metrics"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IMamlEvaluator.PrintAdditionalMetrics(Microsoft.ML.Runtime.IChannel,System.Collections.Generic.Dictionary{System.String,Microsoft.ML.Runtime.Data.IDataView}[])">
            <summary>
            Handles custom metrics (such as p/r curves for binary classification, or group summary results for ranking) from one
            or more folds. Implementations of this method typically creates a single data view for the custom metric and saves it
            to a user specified file.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IMamlEvaluator.GetPerInstanceDataViewToSave(Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Create a data view containing only the columns that are saved as per-instance results by Maml commands.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MamlEvaluatorBase">
            <summary>
            A base class implementation of <see cref="T:Microsoft.ML.Runtime.Data.IMamlEvaluator"/>. The <see cref="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.Evaluate(Microsoft.ML.Runtime.Data.RoleMappedData)"/> and <see cref="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.GetPerInstanceMetrics(Microsoft.ML.Runtime.Data.RoleMappedData)"/>
            methods create a new <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedData"/> containing all the columns needed for evaluation, and call the corresponding
            methods on an <see cref="T:Microsoft.ML.Runtime.Data.IEvaluator"/> of the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.GetInputColumnRolesCore(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            All the input columns needed by an evaluator should be added here.
            The base class ipmlementation gets the score column, the label column (if exists) and the weight column (if exists).
            Override if additional columns are needed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.PrintFoldResultsCore(Microsoft.ML.Runtime.IChannel,System.Collections.Generic.Dictionary{System.String,Microsoft.ML.Runtime.Data.IDataView})">
            <summary>
            This method simply prints the overall metrics using EvaluateUtils.PrintConfusionMatrixAndPerFoldResults.
            Override if something else is needed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.PrintAdditionalMetricsCore(Microsoft.ML.Runtime.IChannel,System.Collections.Generic.Dictionary{System.String,Microsoft.ML.Runtime.Data.IDataView}[])">
            <summary>
            This method simply prints the overall metrics using EvaluateUtils.PrintOverallMetrics.
            Override if something else is needed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.GetPerInstanceMetricsCore(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            The perInst dataview contains all a name column (called Instance), the FoldId, Label and Weight columns if
            they exist, and all the columns returned by <see cref="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.GetPerInstanceColumnsToSave(Microsoft.ML.Runtime.Data.RoleMappedSchema)"/>.
            It should be overridden only if additional processing is needed, such as dropping slots in the "top k scores" column
            in the multi-class case.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MamlEvaluatorBase.GetPerInstanceColumnsToSave(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Returns the names of the columns that should be saved in the per-instance results file. These can include
            the columns generated by the corresponding <see cref="T:Microsoft.ML.Runtime.Data.IRowMapper"/>, or any of the input columns used by
            it. The Name and Weight columns should not be included, since the base class includes them automatically.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.AccuracyMicro">
             <summary>
             Gets the micro-average accuracy of the model.
             </summary>
             <remarks>
             The micro-average is the fraction of instances predicted correctly.
            
             The micro-average metric weighs each class according to the number of instances that belong
             to it in the dataset.
             </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.AccuracyMacro">
             <summary>
             Gets the macro-average accuracy of the model.
             </summary>
             <remarks>
             The macro-average is computed by taking the average over all the classes of the fraction
             of correct predictions in this class (the number of correctly predicted instances in the class,
             divided by the total number of instances in the class).
            
             The macro-average metric gives the same weight to each class, no matter how many instances from
             that class the dataset contains.
             </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.LogLoss">
            <summary>
            Gets the average log-loss of the classifier.
            </summary>
            <remarks>
            The log-loss metric, is computed as follows:
            LL = - (1/m) * sum( log(p[i]))
            where m is the number of instances in the test set.
            p[i] is the probability returned by the classifier if the instance belongs to class 1,
            and 1 minus the probability returned by the classifier if the instance belongs to class 0.
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.LogLossReduction">
            <summary>
            Gets the log-loss reduction (also known as relative log-loss, or reduction in information gain - RIG)
            of the classifier.
            </summary>
            <remarks>
            The log-loss reduction is scaled relative to a classifier that predicts the prior for every example:
            (LL(prior) - LL(classifier)) / LL(prior)
            This metric can be interpreted as the advantage of the classifier over a random prediction.
            E.g., if the RIG equals 20, it can be interpreted as "the probability of a correct prediction is
            20% better than random guessing".
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.TopK">
            <summary>
            If positive, this is the top-K for which the <see cref="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.TopKAccuracy"/> is calculated.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.TopKAccuracy">
            <summary>
            If <see cref="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.TopK"/> is positive, this is the relative number of examples where
            the true label is one of the top k predicted labels by the predictor.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.PerClassLogLoss">
            <summary>
            Gets the log-loss of the classifier for each class.
            </summary>
            <remarks>
            The log-loss metric, is computed as follows:
            LL = - (1/m) * sum( log(p[i]))
            where m is the number of instances in the test set.
            p[i] is the probability returned by the classifier if the instance belongs to the class,
            and 1 minus the probability returned by the classifier if the instance does not belong to the class.
            </remarks>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String)">
            <summary>
            Evaluates scored multiclass classification data.
            </summary>
            <param name="data">The scored data.</param>
            <param name="label">The name of the label column in <paramref name="data"/>.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="predictedLabel">The name of the predicted label column in <paramref name="data"/>.</param>
            <returns>The evaluation results for these outputs.</returns>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.RankerEvaluator.GroupSummary">
            <summary>
            The ranking evaluator outputs a data view by this name, which contains metrics aggregated per group.
            It contains four columns: GroupId, NDCG, DCG and MaxDCG. Each row in the data view corresponds to one
            group in the scored data.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RankerUtils.QueryMaxDcg(System.Double[],System.Int32,System.Collections.Generic.List{System.Int16},System.Collections.Generic.List{System.Single},System.Double[])">
            <summary>te
            Calculates natural-based max DCG at all truncations from 1 to trunc
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.RegressionEvaluator.Result.L1">
            <summary>
            Gets the absolute loss of the model.
            </summary>
            <remarks>
            The absolute loss is defined as
            L1 = (1/m) * sum( abs( yi - y&apos;i))
            where m is the number of instances in the test set.
            y'i are the predicted labels for each instance.
            yi are the correct labels of each instance.
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.RegressionEvaluator.Result.L2">
            <summary>
            Gets the squared loss of the model.
            </summary>
            <remarks>
            The squared loss is defined as
            L2 = (1/m) * sum(( yi - y&apos;i)^2)
            where m is the number of instances in the test set.
            y'i are the predicted labels for each instance.
            yi are the correct labels of each instance.
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.RegressionEvaluator.Result.Rms">
            <summary>
            Gets the root mean square loss (or RMS) which is the square root of the L2 loss.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.RegressionEvaluator.Result.LossFn">
            <summary>
            Gets the user defined loss function.
            </summary>
            <remarks>
            This is the average of a loss function defined by the user,
            computed over all the instances in the test set.
            </remarks>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.RegressionEvaluator.Result.RSquared">
            <summary>
            Gets the R squared value of the model, which is also known as
            the coefficient of determination.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RegressionEvaluator.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String)">
            <summary>
            Evaluates scored regression data.
            </summary>
            <param name="data">The data to evaluate.</param>
            <param name="label">The name of the label column.</param>
            <param name="score">The name of the predicted score column.</param>
            <returns>The evaluation metrics for these outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BinaryClassifierScorer.WrapIfNeeded(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            This function performs a number of checks on the inputs and, if appropriate and possible, will produce
            a mapper with slots names on the output score column properly mapped. If this is not possible for any
            reason, it will just return the input bound mapper.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BinaryClassifierScorer.CanWrap(Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            This is a utility method used to determine whether <see cref="T:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.LabelNameBindableMapper"/>
            can or should be used to wrap <paramref name="mapper"/>. This will not throw, since the
            desired behavior in the event that it cannot be wrapped, is to just back off to the original
            "unwrapped" bound mapper.
            </summary>
            <param name="mapper">The mapper we are seeing if we can wrap</param>
            <param name="labelNameType">The type of the label names from the metadata (either
            originating from the key value metadata of the training label column, or deserialized
            from the model of a bindable mapper)</param>
            <returns>Whether we can call <see cref="M:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.LabelNameBindableMapper.CreateBound``1(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper,Microsoft.ML.Runtime.Data.VectorType,System.Delegate,System.String,System.Func{Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.ColumnType,System.Boolean})"/> with
            this mapper and expect it to succeed</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.GenericScorer">
            <summary>
            This class is a scorer that passes through all the ISchemaBound columns without adding any "derived columns".
            It also passes through all metadata (except for possibly changing the score column kind), and adds the
            score set id metadata.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.Bindings.#ctor(Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper,System.String,System.Boolean)">
            <summary>
            The one and only constructor for Bindings.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.Bindings.Create(Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper,System.String,System.Boolean)">
            <summary>
            Create the bindings given the input schema, bound mapper, and column name suffix.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.Bindings.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBindableMapper,Microsoft.ML.Runtime.Data.ISchema,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ML.Runtime.Data.RoleMappedSchema.ColumnRole,System.String}},System.String,System.Boolean)">
            <summary>
            Create the bindings given the env, bindable, input schema, column roles, and column name suffix.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.Bindings.ApplyToSchema(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Create a new Bindings from this one, but based on a potentially different schema.
            Used by the ITransformTemplate.ApplyToData implementation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.Bindings.Create(Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBindableMapper,Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Deserialize the bindings, given the env, bindable and input schema.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ScorerArgumentsBase,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            The <see cref="T:Microsoft.ML.Runtime.Data.SignatureDataScorer"/> entry point for creating a <see cref="T:Microsoft.ML.Runtime.Data.GenericScorer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.GenericScorer,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Constructor for <see cref="M:Microsoft.ML.Runtime.Data.GenericScorer.ApplyToData(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.#ctor(Microsoft.ML.Runtime.IHost,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Constructor for deserialization.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenericScorer.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            <see cref="T:Microsoft.ML.Runtime.Data.SignatureLoadDataTransform"/> entry point - for deserialization.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.LabelNameBindableMapper">
            <summary>
            This bindable mapper facilitates the serialization and rebinding of the special bound
            mapper that attaches the label metadata to the slot names of the output score column.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.LabelNameBindableMapper.Bound`1._mapper">
            <summary>The mapper we are wrapping.</summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.LabelNameBindableMapper.Bound`1.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper,Microsoft.ML.Runtime.Data.VectorType,Microsoft.ML.Runtime.Data.ValueGetter{Microsoft.ML.Runtime.Data.VBuffer{`0}},System.String,System.Func{Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.ColumnType,System.Boolean})">
            <summary>
            This is the constructor called for the initial wrapping.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.WrapIfNeeded(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            This function performs a number of checks on the inputs and, if appropriate and possible, will produce
            a mapper with slots names on the output score column properly mapped. If this is not possible for any
            reason, it will just return the input bound mapper.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.CanWrap(Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.ColumnType)">
            <summary>
            This is a utility method used to determine whether <see cref="T:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.LabelNameBindableMapper"/>
            can or should be used to wrap <paramref name="mapper"/>. This will not throw, since the
            desired behavior in the event that it cannot be wrapped, is to just back off to the original
            "unwrapped" bound mapper.
            </summary>
            <param name="mapper">The mapper we are seeing if we can wrap</param>
            <param name="labelNameType">The type of the label names from the metadata (either
            originating from the key value metadata of the training label column, or deserialized
            from the model of a bindable mapper)</param>
            <returns>Whether we can call <see cref="M:Microsoft.ML.Runtime.Data.MultiClassClassifierScorer.LabelNameBindableMapper.CreateBound``1(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper,Microsoft.ML.Runtime.Data.VectorType,System.Delegate,System.String,System.Func{Microsoft.ML.Runtime.Data.ISchemaBoundMapper,Microsoft.ML.Runtime.Data.ColumnType,System.Boolean})"/> with
            this mapper and expect it to succeed</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.PredictedLabelScorerBase">
            <summary>
            Class for scorers that compute on additional "PredictedLabel" column from the score column.
            Currently, this scorer is used for binary classification, multi-class classification, and clustering.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.PredictionTransformerBase`2">
            <summary>
            Base class for transformers with no feature column, or more than one feature columns.
            </summary>
            <typeparam name="TModel"></typeparam>
            <typeparam name="TScorer">The Scorer used by this <see cref="T:Microsoft.ML.Runtime.IPredictionTransformer`1"/></typeparam>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.PredictionTransformerBase`2.Model">
            <summary>
            The model.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PredictionTransformerBase`2.GetOutputSchema(Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Gets the output schema resulting from the <see cref="M:Microsoft.ML.Runtime.Data.PredictionTransformerBase`2.Transform(Microsoft.ML.Runtime.Data.IDataView)"/>
            </summary>
            <param name="inputSchema">The <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/> of the input data.</param>
            <returns>The resulting <see cref="T:Microsoft.ML.Runtime.Data.ISchema"/>.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PredictionTransformerBase`2.Transform(Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Transforms the input data.
            </summary>
            <param name="input">The input data.</param>
            <returns>The transformed <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PredictionTransformerBase`2.GetRowToRowMapper(Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Gets a IRowToRowMapper instance.
            </summary>
            <param name="inputSchema"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SingleFeaturePredictionTransformerBase`2">
            <summary>
            The base class for all the transformers implementing the <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/>.
            Those are all the transformers that work with one feature column.
            </summary>
            <typeparam name="TModel">The model used to transform the data.</typeparam>
            <typeparam name="TScorer">The scorer used on this PredictionTransformer.</typeparam>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.SingleFeaturePredictionTransformerBase`2.FeatureColumn">
            <summary>
            The name of the feature column used by the prediction transformer.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.SingleFeaturePredictionTransformerBase`2.FeatureColumnType">
            <summary>
            The type of the prediction transformer
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SingleFeaturePredictionTransformerBase`2.#ctor(Microsoft.ML.Runtime.IHost,`0,Microsoft.ML.Runtime.Data.ISchema,System.String)">
            <summary>
            Initializes a new reference of <see cref="T:Microsoft.ML.Runtime.Data.SingleFeaturePredictionTransformerBase`2"/>.
            </summary>
            <param name="host">The local instance of <see cref="T:Microsoft.ML.Runtime.IHost"/>.</param>
            <param name="model">The model used for scoring.</param>
            <param name="trainSchema">The schema of the training data.</param>
            <param name="featureColumn">The feature column name.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.AnomalyPredictionTransformer`1">
            <summary>
            Base class for the <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/> working on anomaly detection tasks.
            </summary>
            <typeparam name="TModel">An implementation of the <see cref="T:Microsoft.ML.Runtime.IPredictorProducing`1"/></typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.BinaryPredictionTransformer`1">
            <summary>
            Base class for the <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/> working on binary classification tasks.
            </summary>
            <typeparam name="TModel">An implementation of the <see cref="T:Microsoft.ML.Runtime.IPredictorProducing`1"/></typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MulticlassPredictionTransformer`1">
            <summary>
            Base class for the <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/> working on multi-class classification tasks.
            </summary>
            <typeparam name="TModel">An implementation of the <see cref="T:Microsoft.ML.Runtime.IPredictorProducing`1"/></typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RegressionPredictionTransformer`1">
            <summary>
            Base class for the <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/> working on regression tasks.
            </summary>
            <typeparam name="TModel">An implementation of the <see cref="T:Microsoft.ML.Runtime.IPredictorProducing`1"/></typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RankingPredictionTransformer`1">
            <summary>
            Base class for the <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/> working on ranking tasks.
            </summary>
            <typeparam name="TModel">An implementation of the <see cref="T:Microsoft.ML.Runtime.IPredictorProducing`1"/></typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ClusteringPredictionTransformer`1">
            <summary>
            Base class for the <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/> working on clustering tasks.
            </summary>
            <typeparam name="TModel">An implementation of the <see cref="T:Microsoft.ML.Runtime.IPredictorProducing`1"/></typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowToRowScorerBase">
            <summary>
            Base class for scoring rows independently. This assumes that all columns produced by the
            underlying <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper"/> should be exposed, as well as zero or more
            "derived" columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.SaveCore(Microsoft.ML.Runtime.Model.ModelSaveContext)">
            <summary>
            The main save method handles saving the _bindable. This should do everything else.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.ApplyToData(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            For the ITransformTemplate implementation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.GetBindings">
            <summary>
            Derived classes provide the specific bindings object.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.GetActive(Microsoft.ML.Runtime.Data.RowToRowScorerBase.BindingsBase,System.Func{System.Int32,System.Boolean},System.Func{System.Int32,System.Boolean}@,System.Func{System.Int32,System.Boolean}@)">
            <summary>
            Produces the set of active columns for the scorer (as a bool[] of length bindings.ColumnCount),
            a predicate for the needed active input columns, and a predicate for the needed active
            mapper columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.ShouldUseParallelCursors(System.Func{System.Int32,System.Boolean})">
            <summary>
            This produces either "true" or "null" according to whether <see cref="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.WantParallelCursors(System.Func{System.Int32,System.Boolean})"/>
            returns true or false. Note that this will never return false. Any derived class
            must support (but not necessarily prefer) parallel cursors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.WantParallelCursors(System.Func{System.Int32,System.Boolean})">
            <summary>
            This should return true iff parallel cursors are advantageous. Typically, this
            will return true iff some columns added by this scorer are active.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RowToRowScorerBase.GetGetters(Microsoft.ML.Runtime.Data.IRow,System.Func{System.Int32,System.Boolean})">
            <summary>
            Create and fill an array of getters of size InfoCount. The indices of the non-null entries in the
            result should be exactly those for which predicate(iinfo) is true.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ScorerBindingsBase">
            <summary>
            Base bindings for a scorer based on an ISchemaBoundMapper. This assumes that input schema columns
            are echoed, followed by zero or more derived columns, followed by the mapper generated columns.
            The names of the derived columns and mapper generated columns have an optional suffix appended.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.ScorerBindingsBase.Mapper">
            <summary>
            The schema bound mapper.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.ScorerBindingsBase.Suffix">
            <summary>
            The column name suffix. Non-null, but may be empty.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.ScorerBindingsBase.DerivedColumnCount">
            <summary>
            The number of derived columns. InfoCount == DerivedColumnCount + Mapper.OutputSchema.ColumnCount.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScorerBindingsBase.GetActiveMapperColumns(System.Boolean[])">
            <summary>
            Returns a predicate indicating which Mapper columns are active based on the active scorer columns.
            This is virtual so scorers with computed columns can do the right thing.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SchemaBindablePredictorWrapperBase">
            <summary>
            This is a base class for wrapping <see cref="T:Microsoft.ML.Runtime.IPredictor"/>s in an <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBindableMapper"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SchemaBindablePredictorWrapperBase.SingleValueRowMapper">
            <summary>
            The <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper"/> implementation for predictor wrappers that produce a
            single output column. Note that the Bindable wrapper should do any input schema validation.
            This class doesn't care. It DOES care that the role mapped schema specifies a unique Feature column.
            It also requires that the output schema has ColumnCount == 1.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SchemaBindablePredictorWrapper">
            <summary>
            This class is a wrapper for all <see cref="T:Microsoft.ML.Runtime.IPredictor"/>s except for quantile regression predictors,
            and calibrated binary classification predictors.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SchemaBindableBinaryPredictorWrapper">
            <summary>
            This is an <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBindableMapper"/> wrapper for calibrated binary classification predictors.
            They need a separate wrapper because they return two values instead of one: the raw score and the probability.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SchemaBindableBinaryPredictorWrapper.CalibratedRowMapper">
            <summary>
            The <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBoundRowMapper"/> implementation for distribution predictor wrappers that produce
            two Float-valued output columns. Note that the Bindable wrapper does input schema validation.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SchemaBindableQuantileRegressionPredictor">
            <summary>
            This is an <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBindableMapper"/> wrapper for quantile regression predictors. They need a separate
            wrapper because they need the quantiles to create the ISchemaBound.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ScoreMapperSchemaBase">
            <summary>
            A base class for schemas for ISchemaBoundMappers. Takes care of all the metadata that has to do with
            the score column. If the predictor schema has more than one output column, then the GetColumnType(),
            TryGetColumnIndex() and GetColumnName() methods should be overridden. If additional metadata is
            needed, the metadata methods can also be overridden.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreMapperSchemaBase.TryGetColumnIndex(System.String,System.Int32@)">
            <summary>
            This only knows about column zero, the Score column. Derived classes should handle all others.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreMapperSchemaBase.GetColumnName(System.Int32)">
            <summary>
            This only knows about column zero, the Score column. Derived classes should handle all others.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreMapperSchemaBase.GetMetadataTypes(System.Int32)">
            <summary>
            Assumes all columns have ScoreColumnKind and ScoreValueKind.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreMapperSchemaBase.GetMetadataTypeOrNull(System.String,System.Int32)">
            <summary>
            Assumes all columns have ScoreColumnKind and ScoreValueKind of type Text.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreMapperSchemaBase.GetMetadata``1(System.String,System.Int32,``0@)">
            <summary>
            Assumes all columns have ScoreColumnKind and ScoreValueKind.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ScoreMapperSchema">
            <summary>
            Schema implementation for an ISchemaBoundMapper that produces a single column named Score.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.BinaryClassifierSchema">
            <summary>
            The base class handles the score column (index zero). This class handles the probability column (index one).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SequencePredictorSchema.#ctor(Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.VBuffer{System.ReadOnlyMemory{System.Char}}@,System.String)">
            <summary>
            Constructs an <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBoundMapper"/> with one column of a given type, called PredictedLabel.
            If the input <paramref name="keyNames"/> has positive length, it is exposed as
            <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata. Note that we do not copy
            the input key names, but instead take a reference to it.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.BindingsWrappedRowCursor">
            <summary>
            A class for mapping an input to an output cursor assuming no output columns
            are requested, given a bindings object. This can be useful for transforms
            utilizing the <see cref="T:Microsoft.ML.Runtime.Data.ColumnBindingsBase"/>, but for which it is
            inconvenient or inefficient to handle the "no output selected" case in their
            own implementation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.BindingsWrappedRowCursor.#ctor(Microsoft.ML.Runtime.IChannelProvider,Microsoft.ML.Runtime.Data.IRowCursor,Microsoft.ML.Runtime.Data.ColumnBindingsBase)">
            <summary>
            Creates a wrapped version of the cursor
            </summary>
            <param name="provider">Channel provider</param>
            <param name="input">The input cursor</param>
            <param name="bindings">The bindings object, </param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ChooseColumnsTransform.Bindings.RawColInfo">
            <summary>
            This encodes the information specified in the Arguments object and is what is persisted.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ChooseColumnsTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String[])">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="columns">Names of the columns to choose.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ChooseColumnsTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ChooseColumnsTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public constructor corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SourceNameColumnBase.TryParse(System.String)">
            <summary>
            For parsing from a string. This supports "name" and "name:source".
            Derived classes that want to provide parsing functionality to the CmdParser need to implement
            a static Parse method. That method can call this (directly or indirectly) to handle the supported
            syntax.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SourceNameColumnBase.TryParse(System.String,System.String@)">
            <summary>
            For parsing from a string. This supports "name" and "name:source" and "name:extra:source". For the last
            form, the out extra parameter is sort accordingly. For the other forms, extra is set to null.
            Derived classes that want to provide parsing functionality to the CmdParser need to implement
            a static Parse method. That method can call this (directly or indirectly) to handle the supported
            syntax.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SourceNameColumnBase.TryUnparseCore(System.Text.StringBuilder)">
            <summary>
            The core unparsing functionality, for generating succinct command line forms "name" and "name:source".
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SourceNameColumnBase.TryUnparseCore(System.Text.StringBuilder,System.String)">
            <summary>
            The core unparsing functionality, for generating the succinct command line form "name:extra:source".
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SourceNameColumnBase.TrySanitize">
            <summary>
            If both of name and source are null or white-space, return false.
            Otherwise, if one is null or white-space, assign that one the other's value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ManyToOneColumn.TryParse(System.String)">
            <summary>
            The parsing functionality for custom parsing from a string. This supports "name" and "name:sources",
            where sources is a comma separated list of source column names.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ManyToOneColumn.TryParse(System.String,System.String@)">
            <summary>
            Parsing functionality for custom parsing from a string with an "extra" value between name and sources.
            This supports "name", "name:sources" and "name:extra:sources".
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ColumnBindingsBase">
            <summary>
            Base class that abstracts passing input columns through (with possibly different indices) and adding
            InfoCount additional columns. If an added column has the same name as a non-hidden input column, it hides
            the input column, and is placed immediately after the input column. Otherwise, the added column is placed
            at the end. By default, newly added columns have no metadata (but this can be overriden).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.#ctor(Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Constructor that takes an input schema and adds no new columns.
            This is utilized by lambda transforms if the output happens to have no columns.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.#ctor(Microsoft.ML.Runtime.Data.ISchema,System.Boolean,System.String[])">
            <summary>
            Constructor taking the input schema and new column names. Names must be non-empty and
            each name must be non-white-space. The names must be unique but can match existing names
            in schemaInput. For error reporting, this assumes that the names come from a user-supplied
            parameter named "column". This takes ownership of the params array of names.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.ColumnBindingsBase.InfoCount">
            <summary>
            The number of added columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.MapColumnIndex(System.Boolean@,System.Int32)">
            <summary>
            This maps a column index for this schema to either a source column index (when
            <paramref name="isSrcColumn"/> is true), or to an "iinfo" index of an added column
            (when <paramref name="isSrcColumn"/> is false).
            </summary>
            <param name="isSrcColumn">Whether the return index is for a source column</param>
            <param name="col">The column index for this schema</param>
            <returns>The index (either source index or iinfo index)</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.MapIinfoToCol(System.Int32)">
            <summary>
            This maps from an index to an added column "info" to a column index.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.GetActive(System.Func{System.Int32,System.Boolean})">
            <summary>
            The given predicate maps from output column index to whether the column is active.
            This builds an array of bools of length ColumnCount containing the results of calling
            predicate on each column index.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.GetActiveInput(System.Func{System.Int32,System.Boolean})">
            <summary>
            The given predicate maps from output column index to whether the column is active.
            This builds an array of bools of length Input.ColumnCount containing the results of calling
            predicate on the output column index corresponding to each input column index.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.AnyNewColumnsActive(System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether any columns generated by this transform are active.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ManyToOneColumnBindingsBase">
            <summary>
            Base type for bindings with multiple new columns, each mapping from multiple source columns.
            The column strings are parsed as D:S where D is the name of the new column and S is a comma separated
            list of source columns. A column string S with no colon is interpreted as S:S, so the destination
            column has the same name as the source column. This form requires S to not contain commas.
            Note that this base type requires columns of type typeMulti to have known size.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ManyToOneColumnBindingsBase.GetNamesAndSanitize(Microsoft.ML.Runtime.Data.ManyToOneColumn[])">
            <summary>
            Gather the names from the <see cref="T:Microsoft.ML.Runtime.Data.ManyToOneColumn"/> objects. Also, cleanse the column
            objects (propagate values that are shared).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ManyToOneColumnBindingsBase.Contents">
            <summary>
            This class is used to deserialize. We read everything into an instance of this
            and pass that to another constructor.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ColumnParsingUtils">
            <summary>
            Parsing utilities for converting between transform column argument objects and
            command line representations.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnParsingUtils.TryParse(System.String,System.String@,System.String@)">
            <summary>
            For parsing name and source from a string. This supports "name" and "name:source".
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ColumnParsingUtils.TryParse(System.String,System.String@,System.String@,System.String@)">
            <summary>
            For parsing name and source from a string. This supports "name" and "name:source" and "name:extra:source".
            For the last form, the out extra parameter is set accordingly. For the other forms, extra is set to null.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ConcatStaticExtensions">
            <summary>
            The extension methods and implementation support for concatenating columns together.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.AsVector``1(Microsoft.ML.StaticPipe.Scalar{``0})">
            <summary>
            Given a scalar vector, produce a vector of length one.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="me">The scalar column.</param>
            <returns>The vector column, whose single item has the same value as the input.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.NormVector{``0},Microsoft.ML.StaticPipe.NormVector{``0}[])">
            <summary>
            Given a bunch of normalized vectors, concatenate them together into a normalized vector.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="me">The first input column.</param>
            <param name="others">Subsequent input columns.</param>
            <returns>The result of concatenating all input columns together.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector{``0}[])">
            <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="me">The first input column.</param>
            <param name="others">Subsequent input columns.</param>
            <returns>The result of concatenating all input columns together.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector{``0}[])">
            <summary>
            Given a set of columns, concatenate them together into a vector valued column of the same type.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="me">The first input column.</param>
            <param name="others">Subsequent input columns.</param>
            <returns>The result of concatenating all input columns together.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])">
            <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="me">The first input column.</param>
            <param name="others">Subsequent input columns.</param>
            <returns>The result of concatenating all input columns together.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Vector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])">
            <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="me">The first input column.</param>
            <param name="others">Subsequent input columns.</param>
            <returns>The result of concatenating all input columns together.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.VarVector{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])">
            <summary>
            Given a set of columns including at least one variable sized vector column, concatenate them
            together into a vector valued column of the same type.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="me">The first input column.</param>
            <param name="others">Subsequent input columns.</param>
            <returns>The result of concatenating all input columns together.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector`1">
            <summary>
            A wrapping object for the implicit conversions in <see cref="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVector{``0}[])"/>
            and other related methods.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector`1">
            <summary>
            A wrapping object for the implicit conversions in <see cref="M:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ConcatWith``1(Microsoft.ML.StaticPipe.Scalar{``0},Microsoft.ML.Runtime.Data.ConcatStaticExtensions.ScalarOrVectorOrVarVector{``0}[])"/>
            and other related methods.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.ConcatStaticExtensions.Rec.Inst">
            <summary>
            For the moment the concat estimator can only do one at a time, so I want to apply these operations
            one at a time, which means a separate reconciler. Otherwise there may be problems with name overwriting.
            If that is ever adjusted, then we can make a slightly more efficient reconciler, though this is probably
            not that important of a consideration from a runtime perspective.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.ColumnInfo.#ctor(System.String,System.String[])">
            <summary>
            This denotes a concatenation of all <paramref name="inputNames"/> into column called <paramref name="outputName"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.ColumnInfo.#ctor(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.String}})">
            <summary>
            This denotes a concatenation of input columns into one column called <paramref name="outputName"/>.
            For each input column, an 'alias' can be specified, to be used in constructing the resulting slot names.
            If the alias is not specified, it defaults to be column name.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String[])">
            <summary>
            Concatename columns in <paramref name="inputNames"/> into one column <paramref name="outputName"/>.
            Original columns are also preserved.
            The column types must match, and the output column type is always a vector.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ConcatTransform.ColumnInfo[])">
            <summary>
            Concatenates multiple groups of columns, each group is denoted by one of <paramref name="columns"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext)">
            <summary>
            Constructor for SignatureLoadModel.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ConcatTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Factory method corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ConcatTransform.TaggedArguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Factory method corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Factory method for SignatureLoadDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConcatTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Factory method for SignatureLoadRowMapper.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ConcatTransform.Mapper.BoundColumn">
            <summary>
            This represents the column information bound to the schema.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ConvertTransform.ColInfoEx">
            <summary>
            Extra information for each column (in addition to ColumnInfo).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConvertTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.DataKind,System.String,System.String)">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="resultType">The expected type of the converted column.</param>
            <param name="name">Name of the output column.</param>
            <param name="source">Name of the column to be converted.  If this is null '<paramref name="name"/>' will be used.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ConvertTransform.PassThrough(System.String,System.Int32)">
            <summary>
            Returns whether metadata of the indicated kind should be passed through from the source column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DropColumnsTransform">
            <summary>
            Transform to drop columns with the given names. Note that if there are names that
            are not in the input schema, that is not an error.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DropColumnsTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String[])">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="columnsToDrop">Name of the columns to be dropped.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DropColumnsTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.DropColumnsTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public constructor corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DropColumnsTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.DropColumnsTransform.KeepArguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public constructor corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeepColumnsTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String[])">
            <summary>
            A helper method to create <see cref="T:Microsoft.ML.Runtime.Data.KeepColumnsTransform"/> for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="columnsToKeep">Name of the columns to be kept. All other columns will be removed.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DropSlotsTransform">
            <summary>
            Transform to drop slots from columns. If the column is scalar, the only slot that can be dropped is slot 0.
            If all the slots are to be dropped, a vector valued column will be changed to a vector of length 1 (a scalar column will retain its type) and
            the value will be the default value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DropSlotsTransform.Range.IsValid">
            <summary>
            Returns true if the range is valid.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.DropSlotsTransform.ColInfoEx">
            <summary>
            Extra information for each column (in addition to ColumnInfo).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DropSlotsTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.DropSlotsTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public constructor corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.DropSlotsTransform.ComputeType(Microsoft.ML.Runtime.Data.ISchema,System.Int32[],System.Int32[],System.Int32,Microsoft.ML.Runtime.Internal.Internallearn.SlotDropper,System.Boolean@,Microsoft.ML.Runtime.Data.ColumnType@,System.Int32[]@)">
            <summary>
            Computes the types (column and slotnames), the length reduction, categorical feature indices
            and whether the column is suppressed.
            The slotsMin and slotsMax arrays should be sorted and the intervals should not overlap.
            </summary>
            <param name="input">The input schema</param>
            <param name="slotsMin">The beginning indices of the ranges of slots to be dropped</param>
            <param name="slotsMax">The end indices of the ranges of slots to be dropped</param>
            <param name="iinfo">The column index in Infos</param>
            <param name="slotDropper">The slots to be dropped.</param>
            <param name="suppressed">Whether the column is suppressed (all slots dropped)</param>
            <param name="type">The column type</param>
            <param name="categoricalRanges">Categorical feature indices.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.GenerateNumberTransform">
            <summary>
            This transform adds columns containing either random numbers distributed
            uniformly between 0 and 1 or an auto-incremented integer starting at zero.
            It will be used in conjunction with a filter transform to create random
            partitions of the data, used in cross validation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenerateNumberTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.Boolean)">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="name">Name of the output column.</param>
            <param name="useCounter">Use an auto-incremented integer starting at zero instead of a random number.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.GenerateNumberTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.GenerateNumberTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public constructor corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.InvertHashUtils.ClearDst(System.Text.StringBuilder@)">
            <summary>
            Clears a destination StringBuilder. If it is currently null, allocates it.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.InvertHashUtils.GetSimpleMapper``1(Microsoft.ML.Runtime.Data.ISchema,System.Int32)">
            <summary>
            Gets the mapping from T into a StringBuilder representation, using various heuristics.
            This StringBuilder representation will be a component of the composed KeyValues for the
            hash outputs.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.InvertHashCollector`1.Pair">
            <summary>
            This is a small struct that is meant to compare akin to the value,
            but also maintain the order in which it was inserted, assuming that
            we're using something like a hashset where order is not preserved.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.InvertHashCollector`1.#ctor(System.Int32,System.Int32,Microsoft.ML.Runtime.Data.ValueMapper{`0,System.Text.StringBuilder},System.Collections.Generic.IEqualityComparer{`0},Microsoft.ML.Runtime.Data.ValueMapper{`0,`0})">
            <summary>
            Constructs an invert hash collector that collects unique keys per slot, then is able
            to build a textual description out of that.
            </summary>
            <param name="slots">The maximum number of slots</param>
            <param name="maxCount">The number of distinct keys we can accumulate per slot</param>
            <param name="mapper">Utilized in composing the final description, once we have done
            collecting the distinct keys.</param>
            <param name="comparer">For detecting uniqueness of the keys we're collecting per slot.</param>
            <param name="copier">For copying input values into a value to actually store. Useful for
            types of objects where it is possible to do a comparison relatively quickly on some sort
            of "unsafe" object, but for which when we decide to actually store it we need to provide
            a "safe" version of the object. Utilized in the ngram hash transform, for example.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TextModelHelper">
            <summary>
            Simple utility class for saving a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/> of ReadOnlyMemory
            as a model, both in a binary and more easily human readable form.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.KeyToValueTransform">
            <summary>
            KeyToValueTransform utilizes KeyValues metadata to map key indices to the corresponding values in the KeyValues metadata.
            Notes:
            * Output columns utilize the KeyValues metadata.
            * Maps zero values of the key type to the NA of the output type.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.String)">
            <summary>
            Create a <see cref="T:Microsoft.ML.Runtime.Data.KeyToValueTransform"/> that takes and transforms one column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.ValueTuple{System.String,System.String}[])">
            <summary>
            Create a <see cref="T:Microsoft.ML.Runtime.Data.KeyToValueTransform"/> that takes multiple pairs of columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.KeyToValueTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Factory method for SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext)">
            <summary>
            Factory method for SignatureLoadModel.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Factory method for SignatureLoadDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Factory method for SignatureLoadRowMapper.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.KeyToValueTransform.Mapper.KeyToValueMap">
            <summary>
            A map is an object capable of creating the association from an input type, to an output
            type. This mapping is constructed from key metadata, with the input type being the key type
            and the output type being the type specified by the key metadata.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.KeyToValueTransform.Mapper.KeyToValueMap.TypeOutput">
            <summary>
            The item type of the output type, that is, either the output type or,
            if a vector, the item type of that type.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.KeyToValueTransform.Mapper.KeyToValueMap.InfoIndex">
            <summary>
            The column index in Infos.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.KeyToValueTransform.Mapper.KeyToValueMap.Parent">
            <summary>
            The parent transform.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions">
            <summary>
            Extension methods for the static-pipeline over <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> objects.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,Microsoft.ML.StaticPipe.Key{``1}})">
            <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Key{``0,``1})">
            <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})">
            <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToValueStaticExtensions.ToValue``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})">
            <summary>
            Convert a key column to a column containing the corresponding value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorTransform.Mapper.MakeGetterOne(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            This is for the singleton case. This should be equivalent to both Bag and Ord over
            a vector of size one.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorTransform.Mapper.MakeGetterBag(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            This is for the bagging case - vector input and outputs should be added.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorTransform.Mapper.MakeGetterInd(Microsoft.ML.Runtime.Data.IRow,System.Int32)">
            <summary>
            This is for the indicator (non-bagging) case - vector input and outputs should be concatenated.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.KeyToVectorExtensions">
            <summary>
            Extension methods for the static-pipeline over <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> objects.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.Key{``0,``1})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,``1}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``2(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,``1}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.Key{``0})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.KeyToVectorExtensions.ToBaggedVector``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0}})">
            <summary>
            Takes a column of key type of known cardinality and produces an indicator vector of floats.
            Each key value of the input is used to create an indicator vector: the indicator vector is the length of the key cardinality,
            where all values are 0, except for the entry corresponding to the value of the key, which is 1.
            If the key value is missing, then all values are 0. Naturally this tends to generate very sparse vectors.
            In this case then the indicator vectors for all values in the column will be simply added together,
            to produce the final vector with type equal to the key cardinality; so, in all cases, whether vector or scalar,
            the output column will be a vector type of length equal to that cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LabelConvertTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.String)">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="name">Name of the output column.</param>
            <param name="source">Name of the input column.  If this is null '<paramref name="name"/>' will be used.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LabelConvertTransform.PassThrough(System.String,System.Int32)">
            <summary>
            Returns whether metadata of the indicated kind should be passed through from the source column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.LabelIndicatorTransform">
            <summary>
            Remaps multiclass labels to binary T,F labels, primarily for use with OVA.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LabelIndicatorTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int32,System.String,System.String)">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="classIndex">Label of the positive class.</param>
            <param name="name">Name of the output column.</param>
            <param name="source">Name of the input column.  If this is null '<paramref name="name"/>' will be used.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcherBase">
            <summary>
            Base class for handling the schema metadata API.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.ColInfo">
            <summary>
            Information for a column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetterInfo">
            <summary>
            Base class for metadata getters.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetterInfo`1">
            <summary>
            Strongly typed base class for metadata getters. Introduces the abstract Get method.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetterInfoDelegate`1">
            <summary>
            A delegate based metadata getter.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetterInfoPrimitive`1">
            <summary>
            A primitive value based metadata getter.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.ColCount">
            <summary>
            The number of columns.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.CreateInfo(Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Func{System.String,System.Int32,System.Boolean})">
            <summary>
            Create a ColInfo with the indicated information and no GetterInfos. This doesn't
            register a column, only creates a ColInfo. Note that multiple columns can share
            the same ColInfo, if desired. Simply call RegisterColumn multiple times, passing
            the same ColInfo but different index values. This can only be called before Seal is called.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.RegisterColumn(System.Int32,Microsoft.ML.Runtime.Data.MetadataDispatcherBase.ColInfo)">
            <summary>
            Register the given ColInfo as the metadata handling information for the given
            column index. Throws if the given column index already has a ColInfo registered for it.
            This can only be called before Seal is called.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.Seal">
            <summary>
            Seals this dispatcher from further column registrations. This must be called before any
            metadata methods are called, otherwise an exception is thrown.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetColInfoOrNull(System.Int32)">
            <summary>
            Returns the ColInfo registered for the given column index, if there is one. This may be called
            before or after Seal is called.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetMetadataTypes(System.Int32)">
            <summary>
            Gets the metadata kinds and types for the given column index.
            This can only be called after Seal is called.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetMetadataTypeOrNull(System.String,System.Int32)">
            <summary>
            Gets the metadata type for the given metadata kind and column index, if there is one.
            This can only be called after Seal is called.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcherBase.GetMetadata``1(Microsoft.ML.Runtime.IExceptionContext,System.String,System.Int32,``0@)">
            <summary>
            Gets the metadata for the given metadata kind and column index. Throws if there isn't any.
            This can only be called after Seal is called.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcher">
            <summary>
            For handling the schema metadata API. Call one of the BuildMetadata methods to get
            a builder for a particular column. Wrap the return in a using statement. Disposing the builder
            records the metadata for the column. Call Seal() once all metadata is constructed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.BuildMetadata(System.Int32)">
            <summary>
            Start building metadata for a column that doesn't pass through any metadata from
            a source column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.BuildMetadata(System.Int32,Microsoft.ML.Runtime.Data.ISchema,System.Int32)">
            <summary>
            Start building metadata for a column that passes through all metadata from
            a source column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.BuildMetadata(System.Int32,Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Func{System.String,System.Int32,System.Boolean})">
            <summary>
            Start building metadata for a column that passes through metadata of certain kinds from
            a source column. The kinds that are passed through are those for which
            <paramref name="filterSrc"/> returns true.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.BuildMetadata(System.Int32,Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.String)">
            <summary>
            Start building metadata for a column that passes through metadata of the given kind from
            a source column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.BuildMetadata(System.Int32,Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.String[])">
            <summary>
            Start building metadata for a column that passes through metadata of the given kinds from
            a source column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MetadataDispatcher.Builder">
            <summary>
            The builder for metadata for a particular column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.Builder.#ctor(Microsoft.ML.Runtime.Data.MetadataDispatcher,System.Int32,Microsoft.ML.Runtime.Data.ISchema,System.Int32,System.Func{System.String,System.Int32,System.Boolean})">
            <summary>
            This should really be private to MetadataDispatcher, but C#'s accessibility model doesn't
            allow restricting to an outer class.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.Builder.AddGetter``1(System.String,Microsoft.ML.Runtime.Data.ColumnType,Microsoft.ML.Runtime.Data.MetadataUtils.MetadataGetter{``0})">
            <summary>
            Add metadata of the given kind. When requested, the metadata is fetched by calling the given delegate.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.Builder.AddPrimitive``1(System.String,Microsoft.ML.Runtime.Data.ColumnType,``0)">
            <summary>
            Add metadata of the given kind, with the given value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.MetadataDispatcher.Builder.Dispose">
            <summary>
            Close out the builder. This registers the metadata with the dispatcher.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NAFilter">
            <member name="NAFilter">
      <summary>
        Removes missing values from vector type columns.
      </summary>
      <remarks>
        This transform removes the entire row if any of the input columns have a missing value in that row.
        This preprocessing is required for many ML algorithms that cannot work with missing values.
        Useful if any missing entry invalidates the entire row.
        If the <see cref="P:Microsoft.ML.Transforms.MissingValuesRowDropper.Complement" /> is set to true, this transform would do the exact opposite,
        it will keep only the rows that have missing values.
      </remarks>
      <seealso cref="T:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.HasMissingValues" />
    </member>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NAFilter.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Boolean,System.String[])">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="complement">If true, keep only rows that contain NA values, and filter the rest.</param>
            <param name="columns">Name of the columns. Only these columns will be used to filter rows having 'NA' values.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NAFilter.RowCursor.TryGetColumnValueGetter``1(System.Int32,Microsoft.ML.Runtime.Data.ValueGetter{``0}@)">
            <summary>
            Gets the appropriate column value getter for a mapped column. If the column
            is not mapped, this returns false with the out parameters getting default values.
            If the column is mapped but the TValue is of the wrong type, an exception is
            thrown.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NopTransform">
            <summary>
            A transform that does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NopTransform.CreateIfNeeded(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Creates a NopTransform if the input is not an IDataTransform.
            Otherwise it returns the input.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizeTransform.CreateMinMaxNormalizer(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.String)">
            <summary>
            A helper method to create a MinMax normalizer.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="name">Name of the output column.</param>
            <param name="source">Name of the column to be transformed. If this is null '<paramref name="name"/>' will be used.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizeTransform.CreateIfNeeded(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.RoleMappedData@,Microsoft.ML.Runtime.ITrainer)">
            <summary>
            Potentially apply a min-max normalizer to the data's feature column, keeping all existing role
            mappings except for the feature role mapping.
            </summary>
            <param name="env">The host environment to use to potentially instantiate the transform</param>
            <param name="data">The role-mapped data that is potentially going to be modified by this method.</param>
            <param name="trainer">The trainer to query as to whether it wants normalization. If the
            <see cref="P:Microsoft.ML.Runtime.ITrainer.Info"/>'s <see cref="P:Microsoft.ML.Runtime.TrainerInfo.NeedNormalization"/> is <c>true</c></param>
            <returns>True if the normalizer was applied and <paramref name="data"/> was modified</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizeTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.NormalizeTransform.MinMaxArguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public create method corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizeTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.NormalizeTransform.MeanVarArguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public create method corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizeTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.NormalizeTransform.LogMeanVarArguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public create method corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizeTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.NormalizeTransform.BinArguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public create method corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MinMaxDblAggregator">
            <summary>
            Base class for tracking min and max values for a vector valued column.
            It tracks min, max, number of non-sparse values (vCount) and number of ProcessValue() calls (trainCount).
            NaNs are ignored when updating min and max.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MeanVarDblAggregator">
            <summary>
            Class for computing the mean and variance for a vector valued column.
            It tracks the current mean and the M2 (sum of squared diffs of the values from the mean),
            the number of NaNs and the number of non-zero elements.
            Uses the algorithm described here: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MinMaxSngAggregator">
            <summary>
            Base class for tracking min and max values for a vector valued column.
            It tracks min, max, number of non-sparse values (vCount) and number of ProcessValue() calls (trainCount).
            NaNs are ignored when updating min and max.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.MeanVarSngAggregator">
            <summary>
            Class for computing the mean and variance for a vector valued column.
            It tracks the current mean and the M2 (sum of squared diffs of the values from the mean),
            the number of NaNs and the number of non-zero elements.
            Uses the algorithm described here: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.NormalizerTransformer.ColumnFunctions">
            <summary>An accessor of the column functions within <see cref="F:Microsoft.ML.Runtime.Data.NormalizerTransformer._columns"/>.</summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NormalizerTransformer.IAffineData`1">
            <summary>
            An interface implemented by items of <see cref="F:Microsoft.ML.Runtime.Data.NormalizerTransformer.ColumnFunctions"/> corresponding to the
            <see cref="T:Microsoft.ML.Runtime.Data.NormalizeTransform.AffineColumnFunction"/> items.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.IAffineData`1.Scale">
            <summary>
            The scales. In the scalar case, this is a single value. In the vector case this is of length equal
            to the number of slots. Function is <c>(input - offset) * scale</c>.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.IAffineData`1.Offset">
            <summary>
            The offsets. In the scalar case, this is a single value. In the vector case this is of length equal
            to the number of slots, or of length zero if all the offsets are zero.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NormalizerTransformer.ICdfData`1">
            <summary>
            An interface implemented by items of <see cref="F:Microsoft.ML.Runtime.Data.NormalizerTransformer.ColumnFunctions"/> corresponding to the
            <see cref="T:Microsoft.ML.Runtime.Data.NormalizeTransform.CdfColumnFunction"/> items. The function is the value of the
            cumulative density function of the normal distribution parameterized with mean <see cref="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.ICdfData`1.Mean"/>
            and standard deviation <see cref="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.ICdfData`1.Stddev"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.ICdfData`1.Mean">
            <summary>
            The mean(s). In the scalar case, this is a single value. In the vector case this is of length equal
            to the number of slots.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.ICdfData`1.Stddev">
            <summary>
            The standard deviation(s). In the scalar case, this is a single value. In the vector case this is of
            length equal to the number of slots.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.ICdfData`1.UseLog">
            <summary>
            Whether the we ought to apply a logarithm to the input first.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NormalizerTransformer.IBinData`1">
            <summary>
            An interface implemented by items of <see cref="F:Microsoft.ML.Runtime.Data.NormalizerTransformer.ColumnFunctions"/> corresponding to the
            <see cref="T:Microsoft.ML.Runtime.Data.NormalizeTransform.BinColumnFunction"/> items.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.NormalizerTransformer.IBinData`1.UpperBounds">
            <summary>
            The standard deviation(s). In the scalar case, these are the bin upper bounds for that single value.
            In the vector case it is a jagged array of the bin upper bounds for all slots.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions">
            <summary>
            Extension methods for static pipelines for normalization of data.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})">
            <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
            <param name="input">The input column.</param>
            <param name="fixZero">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate that can be called whenever the function is fit, with the learned slopes
            and, if <paramref name="fixZero"/> is <c>false</c>, the offsets as well.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.
            Note that if values are later transformed that are lower than the minimum, or higher than the maximum,
            observed during fitting, that the output values may be outside the range of -1 to 1.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})">
            <summary>
            Learns an affine function based on the minimum and maximum, so that all values between the minimum and
            maximum observed during fitting fall into the range of -1 to 1.
            </summary>
            <param name="input">The input column.</param>
            <param name="fixZero">If set to <c>false</c>, then the observed minimum and maximum during fitting
            will map to -1 and 1 respectively, exactly. If however set to <c>true</c>, then 0 will always map to 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero"/> is <c>false</c>, the offsets as well.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.
            Note that if values are later transformed that are lower than the minimum, or higher than the maximum,
            observed during fitting, that the output values may be outside the range of -1 to 1.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})">
            <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Single}})"/>.
            </summary>
            <param name="input">The input column.</param>
            <param name="fixZero">If set to <c>true</c> then the offset will always be considered zero.</param>
            <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero"/> is ignored.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero"/> is <c>false</c>, the offsets as well.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByMeanVar(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})">
            <summary>
            Learns an affine function based on the observed mean and standard deviation. This is less susceptible
            to outliers as compared to <see cref="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.Normalize(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine{System.Collections.Immutable.ImmutableArray{System.Double}})"/>.
            </summary>
            <param name="input">The input column.</param>
            <param name="fixZero">If set to <c>true</c> then the offset will always be considered zero.</param>
            <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero"/> is ignored.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate called whenever the estimator is fit, with the learned slopes
            and, if <paramref name="fixZero"/> is <c>false</c>, the offsets as well.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Single},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Single}})">
            <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
            <param name="input">The input column.</param>
            <param name="fixZero">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
            <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero"/> is ignored.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByCumulativeDistribution(Microsoft.ML.StaticPipe.Vector{System.Double},System.Boolean,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution{System.Collections.Immutable.ImmutableArray{System.Double}})">
            <summary>
            Learns a function based on the cumulative density function of a normal distribution parameterized by
            a mean and variance as observed during fitting.
            </summary>
            <param name="input">The input column.</param>
            <param name="fixZero">If set to <c>false</c>, then the learned distributional parameters will be
            adjusted in such a way as to ensure that the input 0 maps to the output 0.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
            <param name="useLog">If set to true then we transform over the logarithm of the values, rather
            than just the raw values. If this is set to <c>true</c> then <paramref name="fixZero"/> is ignored.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate called whenever the estimator is fit, with the learned mean and standard
            deviation for all slots.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Single},System.Int32,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Single}})">
            <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (e.g., a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="fixZero"/> is true.
            </summary>
            <param name="input">The input column.</param>
            <param name="maxBins">The maximum number of discretization points to learn per slot.</param>
            <param name="fixZero">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.NormalizeByBinning(Microsoft.ML.StaticPipe.Vector{System.Double},System.Int32,System.Boolean,System.Int64,Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned{System.Collections.Immutable.ImmutableArray{System.Double}})">
            <summary>
            Learns a function based on a discretization of the input values. The observed values for each slot are
            analyzed, and the range of numbers is partitioned into monotonically increasing bins. An attempt is made
            to make these bins equal in population, but under some circumstances this may be impossible (e.g., a slot
            with a very dominant mode). The way the mapping works is, if there are <c>N</c> bins in a slot, and a value
            falls in the range of bin <c>n</c> (indexed from 0), the output value is <c>n / (N - 1)</c>, and then possibly
            subtracting off the binned value for what 0 would have been if <paramref name="fixZero"/> is true.
            </summary>
            <param name="input">The input column.</param>
            <param name="maxBins">The maximum number of discretization points to learn per slot.</param>
            <param name="fixZero">Normally the output is in the range of 0 to 1, but if set to <c>true</c>, then what
            would have been the output for a zero input is subtracted off the value.
            This is valuable for the sake of sparsity preservation, if normalizing sparse vectors.</param>
            <param name="maxTrainingExamples">When gathering statistics only look at most this many examples.</param>
            <param name="onFit">A delegate called whenever the estimator is fit, with the bin upper bounds for each slot.</param>
            <remarks>Note that the statistics gathering and normalization is done independently per slot of the
            vector values.</remarks>
            <returns>The normalized column.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitAffine`1">
            <summary>
            For user provided delegates to receive information when an affine normalizer is fitted.
            The function of the normalizer transformer is <c>(input - offset) * scale</c>.
            </summary>
            <typeparam name="TData">The data type being received, either a numeric type, or a sequence of the numeric type</typeparam>
            <param name="scale">The scales. In the scalar case, this is a single value. In the vector case this is of length equal
            to the number of slots.</param>
            <param name="offset">The offsets. In the scalar case, this is a single value. In the vector case this is of length equal
            to the number of slots, or of length zero if all the offsets are zero.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitCumulativeDistribution`1">
            <summary>
            For user provided delegates to receive information when a cumulative distribution function normalizer is fitted.
            </summary>
            <typeparam name="TData">The data type being received, either a numeric type, or a sequence of the numeric type</typeparam>
            <param name="mean">The mean value. In the scalar case, this is a single value. In the vector case this is of length equal
            to the number of slots.</param>
            <param name="standardDeviation">The standard deviation. In the scalar case, this is a single value. In the vector case
            this is of length equal to the number of slots.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.NormalizerStaticExtensions.OnFitBinned`1">
            <summary>
            For user provided delegates to receive information when a binning normalizer is fitted.
            The function fo the normalizer transformer is, given a value, find its index in the upper bounds, then divide that value
            by the number of upper bounds minus 1, so as to scale the index between 0 and 1. Then, if zero had been fixed, subtract
            off the value that would have been computed by the above procedure for the value zero.
            </summary>
            <typeparam name="TData">The data type being received, either a numeric type, or a sequence of the numeric type</typeparam>
            <param name="upperBounds">For a scalar column a single sequence of the bin upper bounds. For a vector, the same, but
            for all slots.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SignatureLoadColumnFunction">
            <summary>
            Signature for a repository based loader of a IColumnFunction
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IColumnFunctionBuilder.ProcessValue">
            <summary>
            Trains on the current value.
            </summary>
            <returns>True if it can use more values for training.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IColumnFunctionBuilder.CreateColumnFunction">
            <summary>
            Finishes training and returns a column function.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.IColumnAggregator`1">
            <summary>
            Interface to define an aggregate function over values
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IColumnAggregator`1.ProcessValue(`0@)">
            <summary>
            Updates the aggregate function with a value
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.IColumnAggregator`1.Finish">
            <summary>
            Finishes the aggregation
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.NormalizeUtils.FeaturesAreNormalized(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Returns whether the feature column in the schema is indicated to be normalized. If the features column is not
            specified on the schema, then this will return <c>null</c>.
            </summary>
            <param name="schema">The role-mapped schema to query</param>
            <returns>Returns null if <paramref name="schema"/> does not have <see cref="P:Microsoft.ML.Runtime.Data.RoleMappedSchema.Feature"/>
            defined, and otherwise returns a Boolean value as returned from <see cref="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized(Microsoft.ML.Runtime.Data.ISchema,System.Int32)"/>
            on that feature column</returns>
            <seealso cref="M:Microsoft.ML.Runtime.Data.MetadataUtils.IsNormalized(Microsoft.ML.Runtime.Data.ISchema,System.Int32)"/>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.Normalize">
            <summary>
            This contains entry-point definitions related to <see cref="T:Microsoft.ML.Runtime.Data.NormalizeTransform"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3">
            <summary>
            This is a base implementation for a transform that in order to compute its output columns, needs to look
            at an entire group of consecutive input examples. For each example in the group, it looks at the value of
            two input columns and after seeing the entire group it computes the output column values. The output values
            are the same for every example in the same group.
            </summary>
            <typeparam name="TLabel">The type of the values in the first input column</typeparam>
            <typeparam name="TScore">The type of the values in the second input column</typeparam>
            <typeparam name="TState">Each class deriving from this transform should implement a state class that knows
            how to return the current group's output column values.</typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3.BindingsBase">
            <summary>
            Deriving classes only need to implement <see cref="M:Microsoft.ML.Runtime.Data.ColumnBindingsBase.GetColumnTypeCore(System.Int32)"/>.
            If any of the output columns have metadata, then the metadata methods should be overridden.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3.CreateGetters(`2,System.Func{System.Int32,System.Boolean})">
            <summary>
            Creates the getters for the transform's output columns. It can be assumed that when the getters are called, the state
            object contains the current values of the output columns.
            </summary>
            <param name="state">The state object, containing the current group's output values.</param>
            <param name="predicate">Which output columns are active.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3.GetLabelGetter(Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Get the getter for the first input column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3.GetScoreGetter(Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Get the getter for the second input column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3.InitializeState(Microsoft.ML.Runtime.Data.IRow)">
            <summary>
            Return a new state object.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3.ProcessExample(`2,`0,`1)">
            <summary>
            Update the state object with one example.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.PerGroupTransformBase`3.UpdateState(`2)">
            <summary>
            This method is called after processing a whole group of examples. In this method the
            state object should compute the output values for the group just seen.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RangeFilter">
            <summary>
            Filters a dataview on a column of type Single, Double or Key (contiguous).
            Keeps the values that are in the specified min/max range. NaNs are always filtered out.
            If the input is a Key type, the min/max are considered percentages of the number of values.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.RangeFilter.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="column">Name of the input column.</param>
            <param name="minimum">Minimum value (0 to 1 for key types).</param>
            <param name="maximum">Maximum value (0 to 1 for key types).</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ShuffleTransform">
            <summary>
            This is a transform that, given any input dataview (even an unshufflable one) will,
            when we construct a randomized cursor attempt to perform a rude version of shuffling
            using a pool. A pool of a given number of rows will be constructed from the first
            rows in the input cursor, and then, successively, the output cursor will yield one
            of these rows and replace it with another row from the input.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="poolRows">The pool will have this many rows</param>
            <param name="poolOnly">If true, the transform will not attempt to shuffle the input cursor but only shuffle based on the pool. This parameter has no effect if the input data was not itself shufflable.</param>
            <param name="forceShuffle">If true, the transform will always provide a shuffled view.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ShuffleTransform.Arguments,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Public constructor corresponding to SignatureDataTransform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.SelectCachableColumns(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment)">
            <summary>
            Since shuffling requires serving up items potentially out of order we need to know
            how to save and then copy out values that we read. This transform knows how to save
            and copy out only primitive and vector valued columns, but nothing else, so any
            other columns are dropped.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.CanShuffleAll(Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Utility to check whether all types in an input schema are shufflable.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.GetShuffledCursor(Microsoft.ML.Runtime.IChannelProvider,System.Int32,Microsoft.ML.Runtime.Data.IRowCursor,Microsoft.ML.Runtime.IRandom)">
            <summary>
            Utility to take a cursor, and get a shuffled version of this cursor.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor">
             <summary>
             This describes the row cursor. Let's imagine we instantiated our shuffle transform
             over a pool of size P. Logically, externally, the cursor acts as if you have this pool
             P and whenever you randomly sample and yield a row from it, that row is then discarded
             and replaced with the next row from the input source cursor.
            
             It would also be possible to implement in a way that cleaves closely to this logical
             interpretation, but this would be inefficient. We instead have a buffer of larger size
             P+B. A consumer (running presumably in the main thread) sampling and fetching items and a
             producer (running in a task, which may be running in a different thread) filling the buffer
             with items to sample, utilizing this extra space to enable an efficient possibly
             multithreaded scheme.
            
             The consumer, for its part, at any given time "owns" a contiguous portion of this buffer.
             (A contiguous portion of this buffer we consider to be able to wrap around, from the end
             to the beginning. The buffer is accessed in a "circular" fashion.) Consider that this portion
             is broken into three distinct regions: there is a sort of middle "sampling" region
             (usually of size P but possibly smaller when we've reached the end of the input and so are
             running out of rows to sample), a region before this sampling region composed of already
             sampled "dead" rows, and a "presampling" region after this sampling region composed of
             rows ready to be sampled in future iterations, but that we are not sampling yet (in order
             to behave equivalently to the simple logical model of at any given time sampling P items).
             The producer owns the complement of the portion owned by the consumer.
            
             As the cursor progresses, the producer fills in successive items in its portion of the
             buffer it owns, and passes them off to the consumer (not one item at a time, but rather in
             batches, to keep down the amount of intertask communication). The consumer in addition to
             taking ownership of these items, will also periodically pass dead items back to the producer
             (again, not one dead item at a time, but in batches when the number of dead items reaches
             a certain threshold).
            
             This communication is accomplished using a pair of BufferBlock instances, through which
             the producer and consumer are notified how many additional items they can take ownership
             of.
            
             As the consumer "selects" a row from the pool of selectable rows each time it moves to
             the next row, this randomly selected row is considered to be the "first" index, since this
             makes its subsequent transition to being a dead row much simpler. It would be inefficient to
             swap all the values in each column's buffer to accomplish this to make the selected row
             first, of course, so one rather swaps an index, so that these nicely behavior contiguous
             circular indices, get mapped in an index within the buffers, through a permutation maintained
             in the pipeIndices array.
            
             The result is something functionally equivalent to but but considerably faster than the
             simple implementation described in the first paragraph.
             </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor.ExtraIndex">
            <summary>
            Pipes, in addition to column values, will also communicate extra information
            enumerated within this. This enum serves the purpose of providing nice readable
            indices to these "extra" information in pipes.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor.ShufflePipe">
            <summary>
            There is one of these created per active column plus any extra info, and is a mechanism
            through which the producer is able to ingest and store this data from the source cursor,
            and the consumer able to fetch data stored at particular indices.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor.ShufflePipe.Create(System.Int32,Microsoft.ML.Runtime.Data.ColumnType,System.Delegate)">
            <summary>
            Creates a shuffle pipe, given a value getter.
            </summary>
            <param name="bufferSize">The size of the internal array.</param>
            <param name="type">The column type, which determines what type of pipe is created</param>
            <param name="getter">A getter that should be a value getter corresponding to the
            column type</param>
            <returns>An appropriate <see cref="T:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor.ShufflePipe`1"/></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor.ShufflePipe.Fill(System.Int32)">
            <summary>
            Reads the cursor column's current value, and store it in the indicated index,
            in the internal array.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor.ShufflePipe`1.Fetch(System.Int32,`0@)">
            <summary>
            Copies the values stored at an index through a previous <see cref="M:Microsoft.ML.Runtime.Data.ShuffleTransform.RowCursor.ShufflePipe`1.Fill(System.Int32)"/> method,
            call to a value.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.SkipTakeFilter">
            <summary>
            Allows limiting input to a subset of row at an optional offset.  Can be used to implement data paging.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SkipTakeFilter.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.ModelLoadContext,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>Creates instance of class from context.</summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SkipTakeFilter.Save(Microsoft.ML.Runtime.Model.ModelSaveContext)">
            <summary>Saves class data to context</summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.SkipTakeFilter.CanShuffle">
            <summary>
            This filter can not shuffle
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SkipTakeFilter.GetRowCount(System.Boolean)">
            <summary>
            Returns the computed count of rows remaining after skip and take operation.
            Returns null if count is unknown.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.SkipFilter.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int64)">
            <summary>
            A helper method to create <see cref="T:Microsoft.ML.Runtime.Data.SkipTakeFilter"/> transform for skipping the number of rows defined by the <paramref name="count"/> parameter.
            <see cref="T:Microsoft.ML.Runtime.Data.SkipTakeFilter"/> when created with <see cref="T:Microsoft.ML.Runtime.Data.SkipTakeFilter.SkipArguments"/> behaves as 'SkipFilter'.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">>Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="count">Number of rows to skip</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TakeFilter.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.Int64)">
            <summary>
            A helper method to create <see cref="T:Microsoft.ML.Runtime.Data.SkipTakeFilter"/> transform by taking the top rows defined by the <paramref name="count"/> parameter.
            <see cref="T:Microsoft.ML.Runtime.Data.SkipTakeFilter"/> when created with <see cref="T:Microsoft.ML.Runtime.Data.SkipTakeFilter.TakeArguments"/> behaves as 'TakeFilter'.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">>Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="count">Number of rows to take</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermEstimator.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.Int32,Microsoft.ML.Runtime.Data.TermTransform.SortOrder)">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="inputColumn">Name of the column to be transformed.</param>
            <param name="outputColumn">Name of the output column. If this is null '<paramref name="inputColumn"/>' will be used.</param>
            <param name="maxNumTerms">Maximum number of terms to keep per column when auto-training.</param>
            <param name="sort">How items should be ordered when vectorized. By default, they will be in the order encountered.
            If by value items are sorted according to their default comparison, e.g., text sorting will be case sensitive (e.g., 'A' then 'Z' then 'a').</param>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.KeyValueOrder.Occurence">
            <summary>
            Terms will be assigned ID in the order in which they appear.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.KeyValueOrder.Value">
            <summary>
            Terms will be assigned ID according to their sort via an ordinal comparison for the type.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ToKeyFitResult`1">
            <summary>
            Information on the result of fitting a to-key transform.
            </summary>
            <typeparam name="T">The type of the values.</typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ToKeyFitResult`1.OnFit">
            <summary>
            For user defined delegates that accept instances of the containing type.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.String},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.String}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.ReadOnlyMemory{System.Char}}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because the empty string is never entered into the dictionary, it will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Single},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Single}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Single}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Double},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Double}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Double}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.SByte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.SByte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.SByte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Int64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Int64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Int64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Byte},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Byte}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Byte}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt16},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt16}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt16}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt32},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt32}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt32}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
            implication in that case is that sparse input numeric vectors will map to dense output key vectors.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.UInt64},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.UInt64}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.UInt64}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.Vector{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey(Microsoft.ML.StaticPipe.VarVector{System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Key{``0,System.Boolean},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.Vector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermStaticExtensions.ToKey``1(Microsoft.ML.StaticPipe.VarVector{Microsoft.ML.StaticPipe.Key{``0,System.Boolean}},Microsoft.ML.Runtime.Data.KeyValueOrder,System.Int32,Microsoft.ML.Runtime.Data.ToKeyFitResult{System.Boolean}.OnFit)">
            <summary>
            Map values to a key-value representation, where the key type's values are those values observed in the input
            during fitting. During transformation, any values unobserved during fitting will map to the missing key.
            We are inputting a key type with values, and in that case the dictionary is considered to be built over the
            values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
            will be a subset of the key-values in the input.
            </summary>
            <param name="input">The input column.</param>
            <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
            <param name="maxItems">The maximum number of items.</param>
            <param name="onFit">Called upon fitting with the learnt enumeration on the dataset.</param>
            <returns>The key-valued column.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform">
            <summary>
        Converts input values (words, numbers, etc.) to index in a dictionary.
      </summary><remarks>
        The TextToKeyConverter transform builds up term vocabularies (dictionaries).
        The TextToKeyConverter and the <see cref="T:Microsoft.ML.Transforms.HashConverter" /> are the two one primary mechanisms by which raw input is transformed into keys.
        If multiple columns are used, each column builds/uses exactly one vocabulary.
        The output columns are KeyType-valued.
        The Key value is the one-based index of the item in the dictionary.
        If the key is not found in the dictionary, it is assigned the missing value indicator.
        This dictionary mapping values to keys is most commonly learnt from the unique values in input data,
        but can be defined through other means: either with the mapping defined directly on the command line, or as loaded from an external file.
      </remarks><seealso cref="T:Microsoft.ML.Transforms.HashConverter" /><seealso cref="T:Microsoft.ML.Transforms.KeyToTextConverter" />
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform.SortOrder">
            <summary>
            Controls how the order of the output keys.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.Int32,Microsoft.ML.Runtime.Data.TermTransform.SortOrder)">
            <summary>
            Convenience constructor for public facing API.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>. This is the output from previous transform or loader.</param>
            <param name="name">Name of the output column.</param>
            <param name="source">Name of the column to be transformed. If this is null '<paramref name="name"/>' will be used.</param>
            <param name="maxNumTerms">Maximum number of terms to keep per column when auto-training.</param>
            <param name="sort">How items should be ordered when vectorized. By default, they will be in the order encountered.
            If by value items are sorted according to their default comparison, e.g., text sorting will be case sensitive (e.g., 'A' then 'Z' then 'a').</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.CreateFileTermMap(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,System.String,System.String,Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.Data.IMultiStreamSource,Microsoft.ML.Runtime.Data.IDataLoader},Microsoft.ML.Runtime.Data.TermTransform.Builder)">
            <summary>
            Utility method to create the file-based <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.TermMap"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Train(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.TermTransform.ColInfo[],System.String,System.String,Microsoft.ML.Runtime.IComponentFactory{Microsoft.ML.Runtime.Data.IMultiStreamSource,Microsoft.ML.Runtime.Data.IDataLoader},Microsoft.ML.Runtime.Data.TermTransform.ColumnInfo[],Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            This builds the <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.TermMap"/> instances per column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform.Builder">
            <summary>
            These are objects shared by both the scalar and vector implementations of <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.Trainer"/>
            to accumulate individual scalar objects, and facilitate the creation of a <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.TermMap"/>.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TermTransform.Builder.ItemType">
            <summary>
            The item type we are building into a term map.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Data.TermTransform.Builder.Count">
            <summary>
            The number of items that would be in the map if created right now.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Builder.Finish">
            <summary>
            Called at the end of training, to get the final mapper object.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Builder.ParseAddTermArg(System.ReadOnlyMemory{System.Char}@,Microsoft.ML.Runtime.IChannel)">
            <summary>
            Handling for the "terms" arg.
            </summary>
            <param name="terms">The input terms argument</param>
            <param name="ch">The channel against which to report errors and warnings</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Builder.ParseAddTermArg(System.String[],Microsoft.ML.Runtime.IChannel)">
            <summary>
            Handling for the "term" arg.
            </summary>
            <param name="terms">The input terms argument</param>
            <param name="ch">The channel against which to report errors and warnings</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform.Builder.Impl`1">
            <summary>
            The sorted builder outputs things so that the keys are in sorted order.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Builder.Impl`1.#ctor(Microsoft.ML.Runtime.Data.PrimitiveType,Microsoft.ML.Runtime.Data.RefPredicate{`0},System.Boolean)">
            <summary>
            Instantiates.
            </summary>
            <param name="type">The type we are mapping</param>
            <param name="mapsToMissing">This indicates whether a given value will map
            to the missing value. If this returns true for a value then we do not attempt
            to store it in the map.</param>
            <param name="sort">Indicates whether to sort mapping IDs by input values.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Builder`1.TryAdd(`0@)">
            <summary>
            Ensures that the item is in the set. Returns true iff it added the item.
            </summary>
            <param name="val">The value to consider</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Builder`1.ParseAddTermArg(System.ReadOnlyMemory{System.Char}@,Microsoft.ML.Runtime.IChannel)">
            <summary>
            Handling for the "terms" arg.
            </summary>
            <param name="terms">The input terms argument</param>
            <param name="ch">The channel against which to report errors and warnings</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Builder`1.ParseAddTermArg(System.String[],Microsoft.ML.Runtime.IChannel)">
            <summary>
            Handling for the "term" arg.
            </summary>
            <param name="terms">The input terms argument</param>
            <param name="ch">The channel against which to report errors and warnings</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform.Trainer">
            <summary>
            The trainer is an object that given an <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.Builder"/> instance, maps a particular
            input, whether it be scalar or vector, into this and allows us to continue training on it.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Trainer.Create(Microsoft.ML.Runtime.Data.IRow,System.Int32,System.Boolean,System.Int32,Microsoft.ML.Runtime.Data.TermTransform.Builder)">
            <summary>
            Creates an instance of <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.Trainer"/> appropriate for the type at a given
            row and column.
            </summary>
            <param name="row">The row to fetch from</param>
            <param name="col">The column to get the getter from</param>
            <param name="count">The maximum count of items to map</param>
            <param name="autoConvert">Whether we attempt to automatically convert
            the input type to the desired type</param>
            <param name="bldr">The builder we add items to</param>
            <returns>An associated training pipe</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Trainer.ProcessRow">
            <summary>
            Indicates to the <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.Trainer"/> that we have reached a new row and should consider
            what to do with these values. Returns false if we have determined that it is no longer necessary
            to call this train, because we've already accumulated the maximum number of values.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Trainer.Finish">
            <summary>
            Returns a <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.TermMap"/> over the items in this column. Note that even if this
            was trained over a vector valued column, the particular implementation returned here
            should be a mapper over the item type.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.Bind(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.TermTransform.TermMap,Microsoft.ML.Runtime.Data.TermTransform.ColInfo[],System.Boolean[],System.Int32)">
            <summary>
            Given this instance, bind it to a particular input column. This allows us to service
            requests on the input dataset. This should throw an error if we attempt to bind this
            to the wrong type of item.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform.TermMap">
             <summary>
             A map is an object capable of creating the association from an input type, to an output
             type. The input type, whatever it is, must have <see cref="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.ItemType"/> as its input item
             type, and will produce either <see cref="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.OutputType"/>, or a vector type with that output
             type if the input was a vector.
            
             Note that instances of this class can be shared among multiple <see cref="T:Microsoft.ML.Runtime.Data.TermTransform"/>
             instances. To associate this with a particular transform, use the <see cref="M:Microsoft.ML.Runtime.Data.TermTransform.Bind(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.TermTransform.TermMap,Microsoft.ML.Runtime.Data.TermTransform.ColInfo[],System.Boolean[],System.Int32)"/> method.
            
             These are the immutable and serializable analogs to the <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.Builder"/> used in
             training.
             </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.ItemType">
            <summary>
            The item type of the input type, that is, either the input type or,
            if a vector, the item type of that type.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.OutputType">
            <summary>
            The output item type. This will always be of known cardinality. Its count is always
            equal to <see cref="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.Count"/>, unless <see cref="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.Count"/> is 0 in which case this has
            key count of 1, since a count of 0 would indicate an unbound key. If we ever improve
            key types so they are capable of distinguishing between the set they index being
            empty vs. of unknown or unbound cardinality, this should change.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.Count">
            <summary>
            The number of items in the map.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.TermMap.TextImpl.#ctor(Microsoft.ML.Runtime.Internal.Utilities.NormStr.Pool)">
            <summary>
            A pool based text mapping implementation.
            </summary>
            <param name="pool">The string pool</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform.BoundTermMap">
            <summary>
            A mapper bound to a particular transform, and a particular column. These wrap
            a <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.TermMap"/>, and facilitate mapping that object to the inputs of
            a particular column, providing both values and metadata.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.BoundTermMap.AddMetadata(Microsoft.ML.Runtime.Data.ColumnMetadataInfo)">
            <summary>
            Allows us to optionally register metadata. It is also perfectly legal for
            this to do nothing, which corresponds to there being no metadata.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.BoundTermMap.WriteTextTerms(System.IO.TextWriter)">
            <summary>
            Writes out all terms we map to a text writer, with one line per mapped term.
            The line should have the format mapped key value, then a tab, then the term
            that is mapped. The writer should not be closed, as it will be used to write
            all term maps. We should write <see cref="F:Microsoft.ML.Runtime.Data.TermTransform.TermMap.Count"/> terms.
            </summary>
            <param name="writer">The writer to which we write terms</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TermTransform.BoundTermMap.Base`1.MapDefault(Microsoft.ML.Runtime.Data.ValueMapper{`0,System.UInt32})">
            <summary>
            Returns what the default value maps to.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TermTransform.BoundTermMap.KeyImpl`1">
            <summary>
            The key-typed version is the same as <see cref="T:Microsoft.ML.Runtime.Data.TermTransform.BoundTermMap.Impl`1"/>, except the metadata
            is based off a subset of the key values metadata.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ScoreTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String)">
            <summary>
            Convenience method for creating <see cref="T:Microsoft.ML.Runtime.Data.ScoreTransform"/>.
            The <see cref="T:Microsoft.ML.Runtime.Data.ScoreTransform"/> allows for model stacking (i.e. to combine information from multiple predictive models to generate a new model)
            in the pipeline by using the scores from an already trained model.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>.</param>
            <param name="inputModelFile">The model file.</param>
            <param name="featureColumn">Role name for the features.</param>
            <param name="groupColumn">Role name for the group column.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TrainAndScoreTransform.Create(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.ITrainer,System.String,System.String,System.String)">
             <summary>
             Convenience method for creating <see cref="T:Microsoft.ML.Runtime.Data.TrainAndScoreTransform"/>.
             The <see cref="T:Microsoft.ML.Runtime.Data.TrainAndScoreTransform"/> allows for model stacking (i.e. to combine information from multiple predictive models to generate a new model)
             in the pipeline by training a model first and then using the scores from the trained model.
            
             Unlike <see cref="T:Microsoft.ML.Runtime.Data.ScoreTransform"/>, the <see cref="T:Microsoft.ML.Runtime.Data.TrainAndScoreTransform"/> trains the model on the fly as name indicates.
             </summary>
             <param name="env">Host Environment.</param>
             <param name="input">Input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>.</param>
             <param name="trainer">The <see cref="T:Microsoft.ML.Runtime.ITrainer"/> object i.e. the learning algorithm that will be used for training the model.</param>
             <param name="featureColumn">Role name for features.</param>
             <param name="labelColumn">Role name for label.</param>
             <param name="groupColumn">Role name for the group column.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TransformBase">
            <summary>
            Base class for transforms.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransformBase.ShouldUseParallelCursors(System.Func{System.Int32,System.Boolean})">
            <summary>
            This returns false when this transform cannot support parallel cursors, null when it
            doesn't care, and true when it benefits from parallel cursors. For example, a transform
            that simply affects metadata, but not column values should return null, while a transform
            that does a bunch of computation should return true (if legal).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TransformBase.GetRowCursorCore(System.Func{System.Int32,System.Boolean},Microsoft.ML.Runtime.IRandom)">
            <summary>
            Create a single (non-parallel) row cursor.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.RowToRowTransformBase">
            <summary>
            Base class for transforms that map single input row to single output row.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.FilterBase">
            <summary>
            Base class for transforms that filter out rows without changing the schema.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.OneToOneTransformBase">
            <summary>
            Base class for transforms that operate row by row with each destination column using one
            source column. It provides an extension mechanism to allow a destination column to depend
            on multiple input columns.
            This class provides the implementation of ISchema and IRowCursor.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.OneToOneTransformBase.ColInfo">
            <summary>
            Information about an added column - the name of the new column, the index of the
            source column and the type of the source column.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Data.OneToOneTransformBase.Bindings.Infos">
            <summary>
            Information about each added column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.String,Microsoft.ML.Runtime.Data.OneToOneTransformBase,Microsoft.ML.Runtime.Data.IDataView,System.Func{Microsoft.ML.Runtime.Data.ColumnType,System.String})">
            <summary>
            Re-applying constructor.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.SaveAsPfaCore(Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext,System.Int32,Microsoft.ML.Runtime.Data.OneToOneTransformBase.ColInfo,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Called by <see cref="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.SaveAsPfa(Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext)"/>. Should be implemented by subclasses that return
            <c>true</c> from <see cref="P:Microsoft.ML.Runtime.Data.OneToOneTransformBase.CanSavePfa"/>. Will be called
            </summary>
            <param name="ctx">The context. Can be used to declare cells, access other information,
            and whatnot. This method should not actually, however, declare the variable corresponding
            to the output column. The calling method will do that.</param>
            <param name="iinfo">The index of the output column whose PFA is being composed</param>
            <param name="info">The column info</param>
            <param name="srcToken">The token in the PFA corresponding to the source col</param>
            <returns>Shuold return the declaration corresponding to the value of this column. Will
            return <c>null</c> in the event that we do not know how to express this column as PFA</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.ColumnIndex(System.Int32)">
            <summary>
            Return the (destination) column index for the indicated added column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.ActivateSourceColumns(System.Int32,System.Boolean[])">
            <summary>
            Activates the source column.
            Override when you don't need the source column to generate the value for this column or when you need
            other auxiliary source columns that iinfo destination column depends on.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.GetGetterCore(Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.IRow,System.Int32,System.Action@)">
            <summary>
            Sub-classes implement this to provide, for a cursor, a getter delegate and optional disposer.
            If no action is needed when the cursor is Disposed, the override should set disposer to null,
            otherwise it should be set to a delegate to be invoked by the cursor's Dispose method. It's best
            for this action to be idempotent - calling it multiple times should be equivalent to calling it once.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.ShouldUseParallelCursors(System.Func{System.Int32,System.Boolean})">
            <summary>
            This produces either "true" or "null" according to whether <see cref="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.WantParallelCursors(System.Func{System.Int32,System.Boolean})"/>
            returns true or false. Note that this will never return false. Any derived class
            must support (but not necessarily prefer) parallel cursors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.WantParallelCursors(System.Func{System.Int32,System.Boolean})">
            <summary>
            This should return true iff parallel cursors are advantageous. The default implementation
            returns true iff some columns added by this transform are active.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.ExceptGetSlotCursor(System.Int32)">
            <summary>
            Returns a standard exception for responding to an invalid call to <see cref="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.GetSlotCursor(System.Int32)"/>,
            on a column that is not transposable.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.GetSlotCursorCore(System.Int32)">
            <summary>
            Implementors should note this only called if <see cref="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.GetSlotTypeCore(System.Int32)"/>
            returns a non-null value for this <paramref name="iinfo"/>, so in principle
            it should always return a valid value, if called. This implementation throws,
            since the default implementation of <see cref="M:Microsoft.ML.Runtime.Data.OneToOneTransformBase.GetSlotTypeCore(System.Int32)"/> will return
            null for all new columns, and so reaching this is only possible if there is a
            bug.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.ApplyTransformUtils">
            <summary>
            Utilities to rebind data transforms
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ApplyTransformUtils.ApplyTransformToData(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataTransform,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Attempt to apply the data transform to a different data view source.
            If the transform in question implements <see cref="T:Microsoft.ML.Runtime.Data.ITransformTemplate"/>, <see cref="M:Microsoft.ML.Runtime.Data.ITransformTemplate.ApplyToData(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView)"/>
            is called. Otherwise, the transform is serialized into a byte array and then deserialized.
            </summary>
            <param name="env">The host to use</param>
            <param name="transform">The transform to apply.</param>
            <param name="newSource">The data view to apply the transform to.</param>
            <returns>The resulting data view.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.ApplyTransformUtils.ApplyAllTransformsToData(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Walks back the Source chain of the <see cref="T:Microsoft.ML.Runtime.Data.IDataTransform"/> up to the <paramref name="oldSource"/>
            (or <see cref="T:Microsoft.ML.Runtime.Data.IDataLoader"/> if <paramref name="oldSource"/> is <c>null</c>),
            and reapplies all transforms in the chain, to produce the same chain but bound to the different data.
            It is valid to have no transforms: in this case the result will be equal to <paramref name="newSource"/>
            If <paramref name="oldSource"/> is specified and not found in the pipe, an exception is thrown.
            </summary>
            <param name="env">The environment to use.</param>
            <param name="chain">The end of the chain.</param>
            <param name="newSource">The new data to attach the chain to.</param>
            <param name="oldSource">The 'old source' of the pipe, that doesn't need to be reapplied. If null, all transforms are reapplied.</param>
            <returns>The resulting data view.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.LocalEnvironment">
            <summary>
            An ML.NET environment for local execution.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LocalEnvironment.#ctor(System.Nullable{System.Int32},System.Int32)">
            <summary>
            Create an ML.NET <see cref="T:Microsoft.ML.Runtime.IHostEnvironment"/> for local execution.
            </summary>
            <param name="seed">Random seed. Set to <c>null</c> for a non-deterministic environment.</param>
            <param name="conc">Concurrency level. Set to 1 to run single-threaded. Set to 0 to pick automatically.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LocalEnvironment.AddListener(System.Action{Microsoft.ML.Runtime.Data.IMessageSource,Microsoft.ML.Runtime.ChannelMessage})">
            <summary>
            Add a custom listener to the messages of ML.NET components.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.LocalEnvironment.RemoveListener(System.Action{Microsoft.ML.Runtime.Data.IMessageSource,Microsoft.ML.Runtime.ChannelMessage})">
            <summary>
            Remove a previously added a custom listener.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Utilities.PartitionedPathUtils.MakePathRelative(System.String,System.String)">
            <summary>
            Make a full path realtive to a base path.
            </summary>
            <param name="basepath">The base path, assumed to be a directory.</param>
            <param name="path">The full path.</param>
            <returns>The relative path.</returns>
            <exception cref="T:System.InvalidOperationException">If the paths are not relative.</exception>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.Utilities.PartitionedPathUtils.SplitDirectories(System.String)">
            <summary>
            Split a path string into an enumerable list of the directories.
            </summary>
            <param name="path">The path string to split.</param>
            <returns>An enumerable list of all non-empty directories.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.TypeParsingUtils">
            <summary>
            Utilities to parse command-line representations of <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> types.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TypeParsingUtils.TryParseDataKind(System.String,Microsoft.ML.Runtime.Data.DataKind@,Microsoft.ML.Runtime.Data.KeyRange@)">
            <summary>
            Attempt to parse the string into a data kind and (optionally) a key range. This method does not check whether
            the returned <see cref="T:Microsoft.ML.Runtime.Data.DataKind"/> can really be made into a key with the specified <paramref name="keyRange"/>.
            </summary>
            <param name="str">The string to parse.</param>
            <param name="dataKind">The parsed data kind.</param>
            <param name="keyRange">The parsed key range, or null if there's no key specification.</param>
            <returns>Whether the parsing succeeded or not.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Data.TypeParsingUtils.ConstructKeyType(System.Nullable{Microsoft.ML.Runtime.Data.DataKind},Microsoft.ML.Runtime.Data.KeyRange)">
            <summary>
            Construct a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> out of the data kind and the key range.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Data.KeyRange">
            <summary>
            The key range specification. It is used by <see cref="T:Microsoft.ML.Runtime.Data.TextLoader"/> and C# transform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Tools.SavePredictorCommand.CreateFile(System.String)">
            <summary>
            Create a file handle from path if it was not empty.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Tools.SavePredictorCommand.CreateStrm(Microsoft.ML.Runtime.IFileHandle)">
            <summary>
            Create the write stream from the file, if not null.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.UnsafeTypeOps`1">
            <summary>
            Represents some common global operations over a type
            including many unsafe operations.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.FeatureNameCollection.Sparse.#ctor(System.Int32,System.String[],System.Int32)">
            <summary>
            This does NOT take ownership of the names array.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.FeatureNameCollection.Sparse.#ctor(System.Int32,System.Int32,System.Int32[],System.String[])">
            <summary>
            This takes ownership of the arrays.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.PredictionUtil">
            <summary>
            Various utilities
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictionUtil.ParseArguments(Microsoft.ML.Runtime.IHostEnvironment,System.Object,System.String,System.String)">
            <summary>
            generic method for parsing arguments using CommandLine. If there's a problem, it throws an InvalidOperationException, with a message giving usage.
            </summary>
            <param name="env">The host environment</param>
            <param name="args">The argument object</param>
            <param name="settings">The settings string (e.g. "threshold-")</param>
            <param name="name">The name is used for error reporting only</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictionUtil.Array2String(System.Single[],System.String)">
            <summary>
            Make a string representation of an array
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictionUtil.SeparatorFromString(System.String)">
            <summary>
            Convert string representation of char separator(s)
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictionUtil.SepCharFromString(System.String)">
            <summary>
            Convert from a string representation of separator to a char
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.ReverseComparer`1">
            <summary>
            A generic reverse Comparer (for use in Array.Sort)
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.PredictorBase`1">
            <summary>
            A base class for predictors producing <typeparamref name="TOutput"/>.
            Note: This provides essentially no value going forward. New predictors should just
            derive from the interfaces they need.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictorBase`1.WarnOnOldNormalizer(Microsoft.ML.Runtime.Model.ModelLoadContext,System.Type,Microsoft.ML.Runtime.IChannelProvider)">
            <summary>
            This emits a warning if there is Normalizer sub-model.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.SignaturePredictorFromFile">
            <summary>
            Signature for loading from a file name.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IParameterMixer">
            <summary>
            A generic interface for models that can average parameters from multiple instance of self
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IParameterMixer`1">
            <summary>
            A generic interface for models that can average parameters from multiple instance of self
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IQuantileRegressionPredictor">
            <summary>
            Predictor that can specialize for quantile regression. It will produce a <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBindableMapper"/>, given
            an array of quantiles.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IDistribution`1">
            <summary>
            A generic interface for probability distributions
            </summary>
            <typeparam name="TResult">Type of statistics result</typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IQuantileDistribution`1">
            <summary>
            Interface for quantile distribution
            </summary>
            <typeparam name="TResult">Type of statistics result</typeparam>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.IQuantileDistribution`1.GetQuantile(System.Single)">
            <summary>
            Returns an estimate of the p-th quantile, the data value where proportionately p of the data has value
            less than or equal to the returned value.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.ISampleableDistribution`1.GetSupportSample(`0[]@)">
            <summary>
            Returns Support sample for the distribution.
            </summary>
            <param name="weights">Weights for the distribution.It will be null if the distribution is uniform.</param>
            <returns>Returns Support sample</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.ICanSaveInTextFormat">
            <summary>
            Predictors that can output themselves in a human-readable text format
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.ICanSaveInIniFormat">
            <summary>
            Predictors that can output themselves in the Bing ini format.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.ICanSaveSummary">
            <summary>
            Predictors that can output Summary.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.ICanGetSummaryInKeyValuePairs">
            <summary>
            Predictors that can output Summary in key value pairs.
            The content of value 'object' can be any type such as integer, float, string or an array of them.
            It is up the caller to check and decide how to consume the values.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.ICanGetSummaryInKeyValuePairs.GetSummaryInKeyValuePairs(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Gets model summary including model statistics (if exists) in key value pairs.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.ICanSaveInSourceCode">
            <summary>
            Predictors that can output themselves in C#/C++ code.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.SignatureFeatureScorerTrainer">
            <summary>
            Signature for trainers that produce predictors that in turn can be use to score features.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IHaveFeatureWeights">
            <summary>
            Interface implemented by components that can assign weights to features.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.IHaveFeatureWeights.GetFeatureWeights(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Returns the weights for the features.
            There should be at most as many weights as there are features.
            If there are less weights, it is implied that the remaining features have a weight of zero.
            The larger the absolute value of a weights, the more informative/important the feature.
            A weights of zero signifies that the feature is not used by the model.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IPredictorWithFeatureWeights`1">
            <summary>
            Interface implemented by predictors that can score features.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.IWhatTheFeatureValueMapper">
            <summary>
            Interface for mapping input values to corresponding feature contributions.
            This interface is commonly implemented by predictors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.IWhatTheFeatureValueMapper.GetWhatTheFeatureMapper``2(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get a delegate for mapping Contributions to Features.
            Result will contain vector with topN positive contributions(if available) and
            bottomN negative contributions (if available).
            For example linear predictor will have both negative and positive contributions.
            For trees we will not have negative contributions, so bottom param will be ignored.
            If normalization is requested that resulting values will be normalized to [-1, 1].
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.ICanGetTrainingLabelNames">
            <summary>
            Interface for predictors that can return a string array containing the label names from the label column they were trained on.
            If the training label is a key with text key value metadata, it should return this metadata. The order of the labels should be consistent
            with the key values. Otherwise, it returns null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictorUtils.SaveSummary(Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedSchema,System.IO.TextWriter)">
            <summary>
            Save the model summary
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictorUtils.SaveText(Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedSchema,System.IO.TextWriter)">
            <summary>
            Save the model in text format (if it can save itself)
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictorUtils.SaveBinary(Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.IPredictor,System.IO.BinaryWriter)">
            <summary>
            Save the model in binary format (if it can save itself)
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictorUtils.SaveIni(Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedSchema,System.IO.TextWriter)">
            <summary>
            Save the model in text format (if it can save itself)
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.PredictorUtils.SaveCode(Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedSchema,System.IO.TextWriter)">
            <summary>
            Save the model in text format (if it can save itself)
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.IEarlyStoppingCriterion.CheckScore(System.Single,System.Single,System.Boolean@)">
            <summary>
            Check if the learning should stop or not.
            </summary>
            <param name="validationScore">A non negative number. Higher score means better result unless "_lowerIsBetter" is true.</param>
            <param name="trainingScore">A non negative number. Higher score means better result unless "_lowerIsBetter" is true.</param>
            <param name="isBestCandidate">True if the current result is the best ever.</param>
            <returns>If true, the learning should stop.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.EarlyStoppingCriterion`1.CheckBestScore(System.Single)">
            <summary>
            Check if the given score is the best ever. The best score will be stored at this._bestScore.
            </summary>
            <param name="score">The latest score</param>
            <returns>True if the given score is the best ever.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.MovingWindowEarlyStoppingCriterion.GetRecentAvg(System.Collections.Generic.Queue{System.Single})">
            <summary>
            Calculate the average score in the given list of scores.
            </summary>
            <returns>The moving average.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.MovingWindowEarlyStoppingCriterion.GetRecentBest(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Get the best score in the given list of scores.
            </summary>
            <param name="recentScores">The list of scores.</param>
            <returns>The best score.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.GLEarlyStoppingCriterion">
            <summary>
            Loss of Generality (GL).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.LPEarlyStoppingCriterion">
            <summary>
            Low Progress (LP).
            This rule fires when the improvements on the score stall.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.PQEarlyStoppingCriterion">
            <summary>
            Generality to Progress Ratio (PQ).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.UPEarlyStoppingCriterion">
            <summary>
            Consecutive Loss in Generality (UP).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Internallearn.SlotDropper">
            <summary>
            Drops slots from a fixed or variable sized column based on slot ranges.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Internal.Internallearn.SlotDropper.DstLength">
            <summary>
            Returns -1 for non vector and unknown length vectors.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.SlotDropper.#ctor(System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Constructs slot dropper. It expects the slot ranges to be in sorted order and not overlap.
            </summary>
            <param name="srcLength">0 indicates variable sized vector.</param>
            <param name="slotsMin">Lower limit of ranges to be dropped.</param>
            <param name="slotsMax">Upper limit of ranges to be dropped. </param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.SlotDropper.SubsetGetter``1(Microsoft.ML.Runtime.Data.ValueGetter{Microsoft.ML.Runtime.Data.VBuffer{``0}})">
            <summary>
            Returns a getter that drops slots.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.SlotDropper.DropSlots``1(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``0}@)">
            <summary>
            Drops slots from src and populates the dst with the resulting vector. Slots are
            dropped based on min and max slots that were passed at the constructor.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Internallearn.TypeUtils.PrettyName(System.Type)">
            <summary>
            Returns a pretty representation of the type.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Utilities.StreamUtils.Expand(System.String)">
            <summary>
            Expand an extended wildcard pattern into a set of file paths.
            </summary>
            <param name="pattern">the pattern to expand</param>
            <returns>the set of file paths matching the pattern</returns>
            <remarks>
            The wildcard pattern accepts the standard "*" and "?" placeholders.
            "..." also refers to a recursive search over subdirectories.
            "+" can also be used to make a union of several filenames or patterns.
            Names of files that do not exist will be excluded.
            </remarks>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Utilities.TimerScope">
            <summary>
            A timer scope class that starts a Stopwatch when created, calculates and prints elapsed time, physical and virtual memory usages before sending these to the telemetry when disposed.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Utilities.SequencePool">
            <summary>
            A dictionary of uint sequences of variable length. Stores the sequences as
            byte sequences encoded with LEB128. Empty sequences (or null) are also valid.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Utilities.SequencePool.TryAdd(System.UInt32[],System.Int32,System.Int32,System.Int32@)">
            <summary>
            Returns true if the sequence was added, or false if it was already in the pool.
            </summary>
            <param name="sequence">The array containing the sequence to add to the pool.</param>
            <param name="min">The location in the array of the first sequence element.</param>
            <param name="lim">The exclusive end of the sequence.</param>
            <param name="id">To be populated with the id of the added sequence.</param>
            <returns>True if the sequence was added, false if the sequence was already present in the pool.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Utilities.SequencePool.Get(System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Find the given sequence in the pool. If not found, returns -1.
            </summary>
            <param name="sequence">An integer sequence</param>
            <param name="min">The starting index of the sequence to find in the pool</param>
            <param name="lim">The length of the sequence to find in the pool</param>
            <returns>The ID of the sequence if it is found, -1 otherwise</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Utilities.SequencePool.AddCore(System.UInt32[],System.Int32,System.Int32,System.UInt32)">
            <summary>
            Adds the item. Does NOT check for whether the item is already present.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Calibration.SignatureCalibrator">
            <summary>
            Signature for the loaders of calibrators.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Internal.Calibration.ICalibratorTrainer.NeedsTraining">
            <summary>
            True if the calibrator needs training, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.ICalibratorTrainer.ProcessTrainingExample(System.Single,System.Boolean,System.Single)">
            <summary> Training calibrators:  provide the  output and the class label </summary>
            <returns> True if it needs more examples, false otherwise</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.ICalibratorTrainer.FinishTraining(Microsoft.ML.Runtime.IChannel)">
            <summary> Finish up training after seeing all examples </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Calibration.ICalibrator">
            <summary>
            An interface for probability calibrators.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.ICalibrator.PredictProbability(System.Single)">
            <summary> Given a classifier output, produce the probability </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.ICalibrator.GetSummary">
            <summary> Get the summary of current calibrator settings </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Calibration.ISelfCalibratingPredictor">
            <summary>
            An interface for predictors that take care of their own calibration given an input data view.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.CalibratedPredictorBase.GetSummaryInKeyValuePairs(Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Calibration.ParameterMixingCalibratedPredictor">
            <summary>
            Encapsulates a predictor and a calibrator that implement <see cref="T:Microsoft.ML.Runtime.Internal.Internallearn.IParameterMixer"/>.
            Its implementation of <see cref="M:Microsoft.ML.Runtime.Internal.Internallearn.IParameterMixer.CombineParameters(System.Collections.Generic.IList{Microsoft.ML.Runtime.Internal.Internallearn.IParameterMixer})"/> combines both the predictors and the calibrators.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Internal.Calibration.SchemaBindableCalibratedPredictor.CanSavePfa">
            <summary>
            Whether we can save as PFA. Note that this depends on whether the underlying predictor
            can save as PFA, since in the event that this in particular does not get saved,
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.CalibratorUtils.TrainCalibratorIfNeeded(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Internal.Calibration.ICalibratorTrainer,System.Int32,Microsoft.ML.Runtime.ITrainer,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Trains a calibrator, if needed.
            </summary>
            <param name="env">The environment to use.</param>
            <param name="ch">The channel.</param>
            <param name="calibrator">The calibrator trainer.</param>
            <param name="maxRows">The maximum rows to use for calibrator training.</param>
            <param name="trainer">The trainer used to train the predictor.</param>
            <param name="predictor">The predictor that needs calibration.</param>
            <param name="data">The examples to used for calibrator training.</param>
            <returns>The original predictor, if no calibration is needed,
            or a metapredictor that wraps the original predictor and the newly trained calibrator.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.CalibratorUtils.TrainCalibrator(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Internal.Calibration.ICalibratorTrainer,System.Int32,Microsoft.ML.Runtime.IPredictor,Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Trains a calibrator.
            </summary>
            <param name="env">The environment to use.</param>
            <param name="ch">The channel.</param>
            <param name="caliTrainer">The calibrator trainer.</param>
            <param name="maxRows">The maximum rows to use for calibrator training.</param>
            <param name="predictor">The predictor that needs calibration.</param>
            <param name="data">The examples to used for calibrator training.</param>
            <returns>The original predictor, if no calibration is needed,
            or a metapredictor that wraps the original predictor and the newly trained calibrator.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Calibration.NaiveCalibrator">
            <summary>
            The naive binning-based calibrator
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.NaiveCalibrator.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.Single,System.Single,System.Single[])">
            <summary> Create a default calibrator </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.NaiveCalibrator.PredictProbability(System.Single)">
            <summary>
            Given a classifier output, produce the probability
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.NaiveCalibrator.GetSummary">
            <summary> Get the summary of current calibrator settings </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.CalibratorTrainerBase.ProcessTrainingExample(System.Single,System.Boolean,System.Single)">
            <summary>
            Training calibrators:  provide the classifier output and the class label
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Internal.Calibration.PavCalibrator">
            <summary>
            The function that is implemented by this calibrator is:
            f(x) = v_i, if minX_i &lt;= x &lt;= maxX_i
                 = linear interpolate between v_i and v_i+1, if maxX_i &lt; x &lt; minX_i+1
                 = v_0, if x &lt; minX_0
                 = v_n, if x &gt; maxX_n
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.CalibrationDataStore.GetEnumerator">
            <summary>
            An enumerator over the <see cref="T:Microsoft.ML.Runtime.Internal.Calibration.CalibrationDataStore.DataItem"/> entries sorted by score.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Internal.Calibration.Calibrate.CalibratePredictor``1(Microsoft.ML.Runtime.IHost,Microsoft.ML.Runtime.Internal.Calibration.Calibrate.CalibrateInputBase,Microsoft.ML.Runtime.Internal.Calibration.ICalibratorTrainer)">
            <summary>
            This method calibrates the specified predictor using the specified calibrator, training on the specified data.
            </summary>
            <param name="host">A host to pass to the components created in this method.</param>
            <param name="input">The input object, containing the predictor, the data and an integer indicating the maximum number
            of examples to use for training the calibrator.</param>
            <param name="calibratorTrainer">The kind of calibrator to use.</param>
            <returns>A <see cref="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.TrainerOutput"/> object, containing an <see cref="T:Microsoft.ML.Runtime.EntryPoints.IPredictorModel"/>.</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Numeric.VectorUtils">
            <summary>
            A series of vector utility functions, generally operating over arrays or <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/>
            structures. The convention is that if a array or buffer is not modified, that is, it is treated
            as a constant, it might have the name <c>a</c> or <c>b</c> or <c>src</c>, but in a situation
            where the vector structure might be changed the parameter might have the name <c>dst</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.NormSquared(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Returns the L2 norm squared of the vector (sum of squares of the components).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.NormSquared(System.Single[],System.Int32,System.Int32)">
            <summary>
            Returns the L2 norm squared of the vector (sum of squares of the components).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.Norm(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Returns the L2 norm of the vector.
            </summary>
            <returns>L2 norm of the vector</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.L1Norm(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Returns the L1 norm of the vector.
            </summary>
            <returns>L1 norm of the vector</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.MaxNorm(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Returns the L-infinity norm of the vector (i.e., the maximum absolute value).
            </summary>
            <returns>L-infinity norm of the vector</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.Sum(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Returns the sum of elements in the vector.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.ScaleBy(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single)">
            <summary>
            Scales the vector by a real value.
            </summary>
            <param name="dst">Incoming vector</param>
            <param name="c">Value to multiply vector with</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.ScaleBy(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single)">
            <summary>
            Scales the vector by a real value.
            <c><paramref name="dst"/> = <paramref name="c"/> * <paramref name="src"/></c>
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.Add(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Perform in-place vector addition <c><paramref name="dst"/> += <paramref name="src"/></c>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.AddMult(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Perform in-place scaled vector addition
            <c><paramref name="dst"/> += <paramref name="c"/> * <paramref name="src"/></c>.
            If either vector is dense, <paramref name="dst"/> will be dense, unless
            <paramref name="c"/> is 0 in which case this method does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.AddMult(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Perform scalar vector addition
            <c><paramref name="res"/> = <paramref name="c"/> * <paramref name="src"/> + <paramref name="dst"/></c>
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.AddMultInto(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Calculate
            <c><paramref name="a"/> + <paramref name="c"/> * <paramref name="b"/></c>
            and store the result in <paramref name="dst"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.AddMultWithOffset(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Int32)">
            <summary>
            Perform in-place scaled vector addition
            <c><paramref name="dst"/> += <paramref name="c"/> * <paramref name="src"/></c>,
            except that this takes place in the section of <paramref name="dst"/> starting
            at slot <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.ScaleInto(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Perform in-place scaling of a vector into another vector as
            <c><paramref name="dst"/> = <paramref name="src"/> * <paramref name="c"/></c>.
            This is more or less equivalent to performing the same operation with
            <see cref="M:Microsoft.ML.Runtime.Internal.Utilities.VBufferUtils.ApplyInto``3(Microsoft.ML.Runtime.Data.VBuffer{``0}@,Microsoft.ML.Runtime.Data.VBuffer{``1}@,Microsoft.ML.Runtime.Data.VBuffer{``2}@,System.Func{System.Int32,``0,``1,``2})"/> except perhaps more efficiently,
            with one exception: if <paramref name="c"/> is 0 and <paramref name="src"/>
            is sparse, <paramref name="dst"/> will have a count of zero, instead of the
            same count as <paramref name="src"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.SparsifyNormalize(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Int32,System.Int32,System.Boolean)">
            <summary>
             Sparsify vector A (keep at most <paramref name="top"/>+<paramref name="bottom"/> values)
            and optionally rescale values to the [-1, 1] range.
            <param name="a">Vector to be sparsified and normalized.</param>
            <param name="top">How many top (positive) elements to preserve after sparsification.</param>
            <param name="bottom">How many bottom (negative) elements to preserve after sparsification.</param>
            <param name="normalize">Whether to normalize results to [-1,1] range.</param>
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.MulElementWise(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Multiplies arrays Dst *= A element by element and returns the result in <paramref name="dst"/> (Hadamard product).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.DotProductWithOffset(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Int32,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Computes the dot product of two arrays
            Where "offset" is considered to be a's zero index
            </summary>
            <param name="a">one array</param>
            <param name="b">the second array (given as a VBuffer)</param>
            <param name="offset">offset in 'a'</param>
            <returns>the dot product</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.DotProductWithOffset(System.Single[],System.Int32,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Computes the dot product of two arrays
            Where "offset" is considered to be a's zero index
            </summary>
            <param name="a">one array</param>
            <param name="b">the second array (given as a VBuffer)</param>
            <param name="offset">offset in 'a'</param>
            <returns>the dot product</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.L1Distance(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Computes the L1 distance between two VBuffers
            </summary>
            <param name="a">one VBuffer</param>
            <param name="b">another VBuffer</param>
            <returns>L1 Distance from a to b</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.Distance(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Computes the Euclidean distance between two VBuffers
            </summary>
            <param name="a">one VBuffer</param>
            <param name="b">another VBuffer</param>
            <returns>Distance from a to b</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.L2DistSquared(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Computes the Euclidean distance squared between two VBuffers
            </summary>
            <param name="a">one VBuffer</param>
            <param name="b">another VBuffer</param>
            <returns>Distance from a to b</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.L2DistSquared(System.Single[],Microsoft.ML.Runtime.Data.VBuffer{System.Single}@)">
            <summary>
            Given two vectors a and b, calculate their L2 distance squared (|a-b|^2).
            </summary>
            <param name="a">The first vector, given as an array</param>
            <param name="b">The second vector, given as a VBuffer{Float}</param>
            <returns>The squared L2 distance between a and b</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.Add(System.Single[],System.Single[])">
            <summary>
            Perform in-place vector addition <c><paramref name="dst"/> += <paramref name="src"/></c>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.AddMult(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single[],System.Single)">
            <summary>
            Adds a multiple of a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/> to a <see cref="T:System.Single"/> array.
            </summary>
            <param name="src">Buffer to add</param>
            <param name="dst">Array to add to</param>
            <param name="c">Coefficient</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.AddMultWithOffset(Microsoft.ML.Runtime.Data.VBuffer{System.Single}@,System.Single[],System.Int32,System.Single)">
            <summary>
            Adds a multiple of a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/> to a <see cref="T:System.Single"/> array, with an offset into the destination.
            </summary>
            <param name="src">Buffer to add</param>
            <param name="dst">Array to add to</param>
            <param name="offset">The offset into <paramref name="dst"/> at which to add</param>
            <param name="c">Coefficient</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.AddMult(System.Single[],System.Single[],System.Single)">
            <summary>
            Adds a multiple of an array to a second array.
            </summary>
            <param name="src">Array to add</param>
            <param name="dst">Array to add to</param>
            <param name="c">Multiple</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.Norm(System.Single[])">
            <summary>
            Returns the L2 norm of the vector (sum of squares of the components).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.Sum(System.Single[])">
            <summary>
            Returns sum of elements in array
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Numeric.VectorUtils.ScaleBy(System.Single[],System.Single)">
            <summary>
            Multiples the array by a real value
            </summary>
            <param name="dst">The array</param>
            <param name="c">Value to multiply vector with</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.ILossFunction`2.Loss(`0,`1)">
            <summary>
            Computes the loss given the output and the ground truth.
            Note that the return value has type Double because the loss is usually accumulated over many instances.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.IScalarOutputLoss.Derivative(System.Single,System.Single)">
            <summary>
            Derivative of the loss function with respect to output
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.SignatureClassificationLoss">
            <summary>
            Delegate signature for standardized classification loss functions.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.SignatureRegressionLoss">
            <summary>
            Delegate signature for standardized regression loss functions.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs">
            <summary>
            Common output classes for trainers and transforms.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.TransformOutput">
            <summary>
            The common output class for all transforms.
            The output consists of the transformed dataset and the transformation model.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.ITransformOutput">
            <summary>
            Interface that all API transform output classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.TrainerOutput">
            <summary>
            The common output class for all trainers.
            The output is a trained predictor model.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.CalibratorOutput">
            <summary>
            The common output for calibrators.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.ICalibratorOutput">
            <summary>
            Marker interface for calibrators output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.BinaryClassificationOutput">
            <summary>
            The common output for binary classification trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IBinaryClassificationOutput">
            <summary>
            Marker interface for binary classification trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.MulticlassClassificationOutput">
            <summary>
            The common output for multiclass classification trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IMulticlassClassificationOutput">
            <summary>
            Marker interface for multiclass classification trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.RegressionOutput">
            <summary>
            The common output for regression trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IRegressionOutput">
            <summary>
            Marker interface for regression trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.MultiRegressionOutput">
            <summary>
            The common output for multi regression trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IMultiRegressionOutput">
            <summary>
            Marker interface for multi regression trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.ClusteringOutput">
            <summary>
            The common output for clustering trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IClusteringOutput">
            <summary>
            Marker interface for clustering trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.AnomalyDetectionOutput">
            <summary>
            The common output for anomaly detection trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IAnomalyDetectionOutput">
            <summary>
            Marker interface for anomaly detection trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.RankingOutput">
            <summary>
            The common output for ranking trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IRankingOutput">
            <summary>
            Marker interface for ranking trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.SequencePredictionOutput">
            <summary>
            The common output for sequence prediction trainers.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.ISequencePredictionOutput">
            <summary>
            Marker interface for sequence prediction trainer output.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.ITrainerOutput">
            <summary>
            Interface that all API trainer output classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.MacroOutput">
            <summary>
            Macro output class base.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.MacroOutput`1">
            <summary>
            The common output class for all macro entry points.
            The output class is the type parameter. The expansion must guarantee
            that the generated graph will generate all the outputs.
            </summary>
            <typeparam name="TOut">The output class of the macro.</typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.EvaluateOutputBase">
            <summary>
            The common output class for all evaluators.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.ClassificationEvaluateOutput">
            <summary>
            The output class for classification evaluators.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.CommonEvaluateOutput">
            <summary>
            The output class for regression evaluators.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IEvaluatorOutput">
            <summary>
            Interface that all API evaluator output classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonOutputs.IClassificationEvaluatorOutput">
            <summary>
            Interface that all API evaluator output classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.Var`1">
            <summary>
            Marker class for the arguments that can be used as variables
            in an entry point graph.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.ArrayVar`1">
            <summary>
            Marker class for the arguments that can be used as array output variables
            in an entry point graph.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.DictionaryVar`1">
            <summary>
            Marker class for the arguments that can be used as dictionary output variables
            in an entry point graph.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.EntryPointVariable">
            <summary>
            A descriptor of one 'variable' of the graph (input or output that is referenced as a $variable in the graph definition).
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.EntryPoints.EntryPointVariable.Value">
            <summary>
            The value. It will originally start as null, and then assigned to the value,
            once it is available. The type is one of the valid types according to <see cref="M:Microsoft.ML.Runtime.EntryPoints.EntryPointVariable.IsValidType(System.Type)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.EntryPointVariable.IsValidType(System.Type)">
            <summary>
            Whether the given type is a valid one to be a variable.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.EntryPointVariable.SetValue(System.Object)">
            <summary>
            Set the value. It is only allowed once.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.RunContext">
            <summary>
            A collection of all known variables, with an interface to add new variables, get values based on names etc.
            This is populated by individual nodes when they parse their respective JSON definitions, and then the values are updated
            during the node execution.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.RunContext.AddOutputVariable(System.String,System.Type)">
            <summary>
            Returns true if added new variable, false if variable already exists.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.EntryPointNode">
            <summary>
            A representation of one graph node.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.EntryPoints.EntryPointNode.StageId">
            <summary>
            An alphanumeric string indicating the stage of a node.
            The fact that the nodes share the same stage ID hints that they should be executed together whenever possible.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.EntryPoints.EntryPointNode.Checkpoint">
            <summary>
            Hints that the output of this node should be checkpointed.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.EntryPoints.EntryPointNode.Cost">
            <summary>
            The cost of running this node. NaN indicates unknown.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.EntryPointNode.CheckAndSetInputValue(System.Collections.Generic.KeyValuePair{System.String,Newtonsoft.Json.Linq.JToken})">
            <summary>
            Checks the given JSON object key-value pair is a valid EntryPoint input and
            extracts out any variables that need to be populated. These variables will be
            added to the EntryPoint context. Input parameters that are not set to variables
            will be immediately set using the input builder instance.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.EntryPointNode.CheckAndMarkOutputValue(System.Collections.Generic.KeyValuePair{System.String,Newtonsoft.Json.Linq.JToken})">
            <summary>
            Checks the given JSON object key-value pair is a valid EntryPoint output.
            Extracts out any variables that need to be populated and adds them to the
            EntryPoint context.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.EntryPointNode.CanStart">
            <summary>
            Whether the node can run right now.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.VariableBinding">
            <summary>
            Represents a delayed binding in a JSON graph to an <see cref="T:Microsoft.ML.Runtime.EntryPoints.EntryPointVariable"/>.
            The subclasses allow us to express that we either desire the variable itself,
            or a array-indexed or dictionary-keyed value from the variable, assuming it is
            of an Array or Dictionary type.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.VariableBinding.IsValidVariableName(Microsoft.ML.Runtime.IExceptionContext,System.String)">
            <summary>
            Verifies that the name of the graph variable is a valid one
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.ParameterBinding">
            <summary>
            Represents the l-value assignable destination of a <see cref="T:Microsoft.ML.Runtime.EntryPoints.VariableBinding"/>.
            Subclasses exist to express the needed bindinds for subslots
            of a yet-to-be-constructed array or dictionary EntryPoint input parameter
            (e.g. "myVar": ["$var1", "$var2"] would yield two <see cref="T:Microsoft.ML.Runtime.EntryPoints.ArrayIndexParameterBinding"/>: (myVar, 0), (myVar, 1))
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.TransformInputBase">
            <summary>
            The base class for all transform inputs.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.LearnerInputBase">
            <summary>
            The base class for all learner inputs.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.LearnerInputBaseWithLabel">
            <summary>
            The base class for all learner inputs that support a Label column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.LearnerInputBaseWithWeight">
            <summary>
            The base class for all learner inputs that support a weight column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.UnsupervisedLearnerInputBaseWithWeight">
            <summary>
            The base class for all unsupervised learner inputs that support a weight column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.EvaluateInputBase">
            <summary>
            The base class for all evaluators inputs.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs">
            <summary>
            Common input interfaces for TLC components.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.ITransformInput">
            <summary>
            Interface that all API transform input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.IFeaturizerInput">
            <summary>
            Interface that all API trainable featurizers will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.ITrainerInput">
            <summary>
            Interface that all API trainer input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.ITrainerInputWithLabel">
            <summary>
            Interface that all API trainer input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.IUnsupervisedTrainerWithWeight">
            <summary>
            Interface that all API trainer input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.ITrainerInputWithWeight">
            <summary>
            Interface that all API trainer input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.ITrainerInputWithGroupId">
            <summary>
            Interface that all API trainer input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.ICalibratorInput">
            <summary>
            Interface that all API calibrator input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.CommonInputs.IEvaluatorInput">
            <summary>
            Interface that all API evaluator input classes will implement.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder">
            <summary>
            The class that creates and wraps around an instance of an input object and gradually populates all fields, keeping track of missing
            required values. The values can be set from their JSON representation (during the graph parsing stage), as well as directly
            (in the process of graph execution).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.GetFieldIndex(System.String)">
            <summary>
            Retreives the field index for a field with the given alias, or -1 if
            that field alias is not found.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.GetFieldTypeOrNull(System.String)">
            <summary>
            Returns the Type of the given field, unwrapping any option
            types to be of their inner type. If the given alias doesn't exist
            this method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.GetMissingValues">
            <summary>
            Returns the array of required values that were not specified using <see cref="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.TrySetValue(System.String,System.Object)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.TrySetValueJson(System.String,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Set a value of a field specified by <paramref name="name"/> by parsing <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.TrySetValue(System.String,System.Object)">
            <summary>
            Set a value of a field specified by <paramref name="name"/> directly to <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.GetFieldAssignableValue(Microsoft.ML.Runtime.IExceptionContext,System.Type,System.Object)">
            <summary>
            Ensures that the given value can be assigned to an entry point field with
            type <paramref name="type"/>. This method will wrap the value in the option
            type if needed and throw an exception if the value isn't assignable.
            </summary>
            <param name="ectx">The exception context.</param>
            <param name="type">Type type of the field this value is to be assigned to.</param>
            <param name="value">The value, typically originates from either ParseJsonValue, or is an external, user-provided object.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.MakeOptionalIfNeeded(Microsoft.ML.Runtime.IExceptionContext,System.Object,System.Type)">
            <summary>
            If outerType is an Optional{T}, the innerValue is wrapped in a constructed, explicit
            Optional instance, otherwise the value is directly returned.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.InputBuilder.GetInstance">
            <summary>
            Returns the created instance.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.OutputHelper">
            <summary>
            This class wraps around the output object type, does not create an instance, and provides utility methods for field type checking
            and extracting values.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.JsonUtils.OutputHelper.ExtractValues(System.Object)">
            <summary>
            Extract all values of a specified output object.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.FieldNames">
            <summary>
            These are the common field names used in the JSON objects for defining the manifest.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.FieldNames.Range">
            <summary>
            Range specific field names.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.FieldNames.Deprecated">
            <summary>
            Obsolete Attribute specific field names.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.FieldNames.SweepableLongParam">
            <summary>
            SweepableLongParam specific field names.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.FieldNames.SweepableFloatParam">
            <summary>
            SweepableFloatParam specific field names.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.JsonUtils.FieldNames.SweepableDiscreteParam">
            <summary>
            SweepableDiscreteParam specific field names.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.PredictorModel">
            <summary>
            This class encapsulates the predictor and a preceding transform model.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.ScoreModel">
             <summary>
             This module handles scoring a <see cref="T:Microsoft.ML.Runtime.EntryPoints.IPredictorModel"/> against a new dataset.
             As a result, we return both the scored data and the scoring transform as a <see cref="T:Microsoft.ML.Runtime.EntryPoints.ITransformModel"/>.
            
             REVIEW: This module does not support 'exotic' scoring scenarios, like recommendation and quantile regression
             (those where the user-defined scorer settings are necessary to identify the scorer). We could resolve this by
             adding a sub-component for extra scorer args, or by creating specialized EPs for these scenarios.
             </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.EntryPoints.TransformModel">
            <summary>
            This encapsulates zero or more transform models. It does this by recording
            the initial schema, together with the sequence of transforms applied to that
            schema.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.EntryPoints.TransformModel.InputSchema">
            <summary>
            The input schema that this transform model was originally instantiated on.
            Note that the schema may have columns that aren't needed by this transform model.
            If an IDataView exists with this schema, then applying this transform model to it
            shouldn't fail because of column type issues.
            REVIEW: Would be nice to be able to trim this to the minimum needed somehow. Note
            however that doing so may cause issues for composing transform models. For example,
            if transform model A needs column X and model B needs Y, that is NOT produced by A,
            then trimming A's input schema would cause composition to fail.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.EntryPoints.TransformModel.OutputSchema">
            <summary>
            The resulting schema once applied to this model. The <see cref="P:Microsoft.ML.Runtime.EntryPoints.TransformModel.InputSchema"/> might have
            columns that are not needed by this transform and these columns will be seen in the
            <see cref="P:Microsoft.ML.Runtime.EntryPoints.TransformModel.OutputSchema"/> produced by this transform.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.TransformModel.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Create a TransformModel containing the transforms from "result" back to "input".
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.TransformModel.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.ISchema,Microsoft.ML.Runtime.Data.IDataTransform[])">
            <summary>
            Create a TransformModel containing the given (optional) transforms applied to the
            given root schema.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.TransformModel.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Load a transform model.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.TransformModel.Apply(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView)">
            <summary>
            Apply this transform model to the given input data.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.TransformModel.Apply(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.EntryPoints.ITransformModel)">
            <summary>
            Apply this transform model to the given input transform model to produce a composite transform model.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.EntryPoints.TransformModel.Save(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Save this transform model.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelHeader.SignatureValue">
            <summary>
            This spells 'ML MODEL' with zero replacing space (assuming little endian).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.BeginWrite(System.IO.BinaryWriter,System.Int64@,Microsoft.ML.Runtime.Model.ModelHeader@)">
            <summary>
            Initialize the header and writer for writing. The value of fpMin and header
            should be passed to the other utility methods here.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.EndWrite(System.IO.BinaryWriter,System.Int64,Microsoft.ML.Runtime.Model.ModelHeader@,Microsoft.ML.Runtime.Internal.Utilities.NormStr.Pool,System.String)">
            <summary>
            The current writer position should be the end of the model blob. Records the model size, writes the string table,
            completes and writes the header, and writes the tail.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.WriteHeaderAndTailCore(System.IO.BinaryWriter,System.Int64,Microsoft.ML.Runtime.Model.ModelHeader@)">
            <summary>
            The current writer position should be where the tail belongs. Writes the header and tail.
            Typically this isn't called directly unless you are doing custom string table serialization.
            In that case you should have called EndModelCore before writing the string table information.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.EndModelCore(System.IO.BinaryWriter,System.Int64,Microsoft.ML.Runtime.Model.ModelHeader@)">
            <summary>
            The current writer position should be the end of the model blob. Records the size of the model blob.
            Typically this isn't called directly unless you are doing custom string table serialization.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.SetVersionInfo(Microsoft.ML.Runtime.Model.ModelHeader@,Microsoft.ML.Runtime.Model.VersionInfo)">
            <summary>
            Sets the version information the header.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.SetLoaderSig(Microsoft.ML.Runtime.Model.ModelHeader@,System.String)">
            <summary>
            Record the given loader sig in the header. If sig is null, clears the loader sig.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.SetLoaderSigAlt(Microsoft.ML.Runtime.Model.ModelHeader@,System.String)">
            <summary>
            Record the given alternate loader sig in the header. If sig is null, clears the alternate loader sig.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.MarshalToBytes(Microsoft.ML.Runtime.Model.ModelHeader@,System.Byte[])">
            <summary>
            Low level method for copying bytes from a header structure into a byte array.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.BeginRead(System.Int64@,Microsoft.ML.Runtime.Model.ModelHeader@,System.String[]@,System.String@,System.IO.BinaryReader)">
            <summary>
            Read the model header, strings, etc from reader. Also validates the header (throws if bad).
            Leaves the reader position at the beginning of the model blob.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.EndRead(System.Int64,Microsoft.ML.Runtime.Model.ModelHeader@,System.IO.BinaryReader)">
            <summary>
            Finish reading. Checks that the current reader position is the end of the model blob.
            Seeks to the end of the entire model file (after the tail).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.CheckVersionInfo(Microsoft.ML.Runtime.Model.ModelHeader@,Microsoft.ML.Runtime.Model.VersionInfo)">
            <summary>
            Performs standard version validation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.MarshalFromBytes(Microsoft.ML.Runtime.Model.ModelHeader@,System.Byte[])">
            <summary>
            Low level method for copying bytes from a byte array to a header structure.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.TryValidate(Microsoft.ML.Runtime.Model.ModelHeader@,System.Int64,System.Exception@)">
            <summary>
            Checks the basic validity of the header, assuming the stream is at least the given size.
            Returns false (and the out exception) on failure.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.TryValidate(Microsoft.ML.Runtime.Model.ModelHeader@,System.IO.BinaryReader,System.Int64,System.String[]@,System.String@,System.Exception@)">
            <summary>
            Checks the validity of the header, reads the string table, etc.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.GetLoaderSig(Microsoft.ML.Runtime.Model.ModelHeader@)">
            <summary>
            Extract and return the loader sig from the header, trimming trailing zeros.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelHeader.GetLoaderSigAlt(Microsoft.ML.Runtime.Model.ModelHeader@)">
            <summary>
            Extract and return the alternate loader sig from the header, trimming trailing zeros.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.VersionInfo">
            <summary>
            This is used to simplify version checking boiler-plate code. It is an optional
            utility type.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.VersionInfo.#ctor(System.String,System.UInt32,System.UInt32,System.UInt32,System.String,System.String,System.String)">
            <summary>
            Construct version info with a string value for modelSignature. The string must be 8 characters
            all less than 0x100. Spaces are mapped to zero. This assumes little-endian.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.ModelLoadContext">
            <summary>
            This is a convenience context object for loading models from a repository, for
            implementors of ICanSaveModel. It is not mandated but designed to reduce the
            amount of boiler plate code. It can also be used when loading from a single stream,
            for implementors of ICanSaveInBinaryFormat.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext.Repository">
            <summary>
            When in repository mode, this is the repository we're reading from. It is null when
            in single-stream mode.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext.Directory">
            <summary>
            When in repository mode, this is the direcory we're reading from. Null means the root
            of the repository. It is always null in single-stream mode.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext.Reader">
            <summary>
            The main stream reader.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext.Strings">
            <summary>
            The strings loaded from the main stream's string table.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext.LoaderAssemblyName">
            <summary>
            The name of the assembly that the loader lives in.
            </summary>
            <remarks>
            This may be null or empty if one was never written to the model, or is an older model version.
            </remarks>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext.Header">
            <summary>
            The main stream's model header.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext.FpMin">
            <summary>
            The min file position of the main stream.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelLoadContext._ectx">
            <summary>
            Exception context provided by Repository (can be null).
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.ModelLoadContext.InRepository">
            <summary>
            Returns whether this context is in repository mode (true) or single-stream mode (false).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.#ctor(Microsoft.ML.Runtime.Model.RepositoryReader,Microsoft.ML.Runtime.Model.Repository.Entry,System.String)">
            <summary>
            Create a ModelLoadContext supporting loading from a repository, for implementors of ICanSaveModel.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.#ctor(System.IO.BinaryReader,Microsoft.ML.Runtime.IExceptionContext)">
            <summary>
            Create a ModelLoadContext supporting loading from a single-stream, for implementors of ICanSaveInBinaryFormat.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.CheckVersionInfo(Microsoft.ML.Runtime.Model.VersionInfo)">
            <summary>
            Performs version checks.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadStringOrNull">
            <summary>
            Reads an integer from the load context's reader, and returns the associated string,
            or null (encoded as -1).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadString">
            <summary>
            Reads an integer from the load context's reader, and returns the associated string.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadNonEmptyString">
            <summary>
            Reads an integer from the load context's reader, and returns the associated string.
            Throws if the string is empty or null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.Done">
            <summary>
            Commit the load operation. This completes reading of the main stream. When in repository
            mode, it disposes the Reader (but not the repository).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.Dispose">
            <summary>
            When in repository mode, this disposes the Reader (but no the repository).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.ContainsModel(System.String)">
            <summary>
            Return whether this context contains a directory and stream for a sub-model with
            the indicated name. This does not attempt to load the sub-model.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadModelOrNull``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,Microsoft.ML.Runtime.Model.RepositoryReader,System.String,System.Object[])">
            <summary>
            Load an optional object from the repository directory.
            Returns false iff no stream was found for the object, iff result is set to null.
            Throws if loading fails for any other reason.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,Microsoft.ML.Runtime.Model.RepositoryReader,System.String,System.Object[])">
            <summary>
            Load an object from the repository directory.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadModelOrNull``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,System.String,System.Object[])">
            <summary>
            Load a sub model from the given sub directory if it exists. This requires InRepository to be true.
            Returns false iff no stream was found for the object, iff result is set to null.
            Throws if loading fails for any other reason.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,System.String,System.Object[])">
            <summary>
            Load a sub model from the given sub directory. This requires InRepository to be true.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.TryLoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,Microsoft.ML.Runtime.Model.RepositoryReader,Microsoft.ML.Runtime.Model.Repository.Entry,System.String,System.Object[])">
            <summary>
            Try to load from the given repository entry using the default loader(s) specified in the header.
            Returns false iff the default loader(s) could not be bound to a compatible loadable class.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,Microsoft.ML.Runtime.Model.RepositoryReader,Microsoft.ML.Runtime.Model.Repository.Entry,System.String,System.Object[])">
            <summary>
            Load from the given repository entry using the default loader(s) specified in the header.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.TryLoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,System.IO.Stream,System.Object[])">
            <summary>
            Try to load from the given stream (non-Repository).
            Returns false iff the default loader(s) could not be bound to a compatible loadable class.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,System.IO.Stream,System.Object[])">
            <summary>
            Load from the given stream (non-Repository) using the default loader(s) specified in the header.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.TryLoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,System.IO.BinaryReader,System.Object[])">
            <summary>
            Try to load from the given reader (non-Repository).
            Returns false iff the default loader(s) could not be bound to a compatible loadable class.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.LoadModel``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,System.IO.BinaryReader,System.Object[])">
            <summary>
            Load from the given reader (non-Repository) using the default loader(s) specified in the header.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.TryLoadModelCore``2(Microsoft.ML.Runtime.IHostEnvironment,``0@,System.Object[])">
            <summary>
            Tries to load.
            Returns false iff the default loader(s) could not be bound to a compatible loadable class.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.TryProcessSubModel(System.String,System.Action{Microsoft.ML.Runtime.Model.ModelLoadContext})">
            <summary>
            Try to load a sub model from the given sub directory. This requires InRepository to be true.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.TryLoadBinaryStream(System.String,System.Action{System.IO.BinaryReader})">
            <summary>
            Try to load a binary stream from the current directory. This requires InRepository to be true.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelLoadContext.TryLoadTextStream(System.String,System.Action{System.IO.TextReader})">
            <summary>
            Try to load a text stream from the current directory. This requires InRepository to be true.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.ModelSaveContext">
            <summary>
            This is a convenience context object for saving models to a repository, for
            implementors of ICanSaveModel. It is not mandated but designed to reduce the
            amount of boiler plate code. It can also be used when saving to a single stream,
            for implementors of ICanSaveInBinaryFormat.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext.Repository">
            <summary>
            When in repository mode, this is the repository we're writing to. It is null when
            in single-stream mode.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext.Directory">
            <summary>
            When in repository mode, this is the directory we're reading from. Null means the root
            of the repository. It is always null in single-stream mode.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext.Writer">
            <summary>
            The main stream writer.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext.Strings">
            <summary>
            The strings that will be saved in the main stream's string table.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext.Header">
            <summary>
            The main stream's model header.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext.FpMin">
            <summary>
            The min file position of the main stream.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext._ent">
            <summary>
            The wrapped entry.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext._ectx">
            <summary>
            Exception context provided by Repository (can be null).
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.ModelSaveContext._loaderAssemblyName">
            <summary>
            The assembly name where the loader resides.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.ModelSaveContext.InRepository">
            <summary>
            Returns whether this context is in repository mode (true) or single-stream mode (false).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.#ctor(Microsoft.ML.Runtime.Model.RepositoryWriter,System.String,System.String)">
            <summary>
            Create a ModelSaveContext supporting saving to a repository, for implementors of ICanSaveModel.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.#ctor(System.IO.BinaryWriter,Microsoft.ML.Runtime.IExceptionContext)">
            <summary>
            Create a ModelSaveContext supporting saving to a single-stream, for implementors of ICanSaveInBinaryFormat.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.SetVersionInfo(Microsoft.ML.Runtime.Model.VersionInfo)">
            <summary>
            Set the version information in the main stream's header. This should be called before
            Done is called.
            </summary>
            <param name="ver"></param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.SaveStringOrNull(System.String)">
            <summary>
            Puts a string into the context pool, and writes the integer code of the string ID
            to the write stream. If str is null, this writes -1 and doesn't add it to the pool.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.SaveString(System.String)">
            <summary>
            Puts a string into the context pool, and writes the integer code of the string ID
            to the write stream. Checks that str is not null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.SaveNonEmptyString(System.String)">
            <summary>
            Puts a string into the context pool, and writes the integer code of the string ID
            to the write stream.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.Done">
            <summary>
            Commit the save operation. This completes writing of the main stream. When in repository
            mode, it disposes the Writer (but not the repository).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.Dispose">
            <summary>
            When in repository mode, this disposes the Writer (but not the repository).
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.SaveModel``1(``0,System.String)">
            <summary>
            Save a sub model to the given sub directory. This requires InRepository to be true.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.SaveModel``1(Microsoft.ML.Runtime.Model.RepositoryWriter,``0,System.String)">
            <summary>
            Save the object by calling TrySaveModel then falling back to .net serialization.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.Save(System.IO.BinaryWriter,System.Action{Microsoft.ML.Runtime.Model.ModelSaveContext})">
            <summary>
            Save to a single-stream by invoking the given action.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelSaveContext.SaveSubModel(System.String,System.Action{Microsoft.ML.Runtime.Model.ModelSaveContext})">
            <summary>
            Save to the given sub directory by invoking the given action. This requires InRepository to be true.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.Onnx.ICanSaveOnnx.CanSaveOnnx">
            <summary>
            Whether this object really is capable of saving itself as part of an ONNX
            pipeline. An implementor of this object might implement this interface,
            but still return <c>false</c> if there is some characteristic of this object
            only detectable during runtime that would prevent its being savable. (E.g.,
            it may wrap some other object that may or may not be savable.)
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Onnx.ISaveAsOnnx">
            <summary>
            This component know how to save himself in ONNX format.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.ISaveAsOnnx.SaveAsOnnx(Microsoft.ML.Runtime.Model.Onnx.OnnxContext)">
            <summary>
            Save as ONNX.
            </summary>
            <param name="ctx">The ONNX program being built</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Onnx.ITransformCanSaveOnnx">
            <summary>
            This data model component is savable as ONNX.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Onnx.IBindableCanSaveOnnx">
            <summary>
            This <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBindableMapper"/> is savable in ONNX. Note that this is
            typically called within an <see cref="T:Microsoft.ML.Runtime.Data.IDataScorerTransform"/> that is wrapping
            this mapper, and has already been bound to it.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.IBindableCanSaveOnnx.SaveAsOnnx(Microsoft.ML.Runtime.Model.Onnx.OnnxContext,Microsoft.ML.Runtime.Data.RoleMappedSchema,System.String[])">
            <summary>
            Save as ONNX. If <see cref="P:Microsoft.ML.Runtime.Model.Onnx.ICanSaveOnnx.CanSaveOnnx"/> is
            <c>false</c> this should not be called. This method is intended to be called
            by the wrapping scorer transform, and is intended to produce enough information
            for that purpose.
            </summary>
            <param name="ctx">The ONNX program being built</param>
            <param name="schema">The role mappings that was passed to this bindable
            object, when the <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBoundMapper"/> was created that this transform
            is wrapping</param>
            <param name="outputNames">Since this method is called from a scorer transform,
            it is that transform that controls what the output column names will be, of
            the outputs produced by this bindable mapper. This is the array that holds
            those names, so that implementors of this method know what to produce in
            <paramref name="ctx"/>.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Onnx.ISingleCanSaveOnnx">
            <summary>
            For simple mappers. Intended to be used for <see cref="T:Microsoft.ML.Runtime.Data.IValueMapper"/> and
            <see cref="T:Microsoft.ML.Runtime.Internal.Calibration.ICalibrator"/> instances.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Onnx.IDistCanSaveOnnx">
            <summary>
            For simple mappers. Intended to be used for <see cref="T:Microsoft.ML.Runtime.Data.IValueMapperDist"/>
            instances.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Onnx.OnnxContext">
            <summary>
            A context for defining a ONNX output. The context internally contains the model-in-progress being built. This
            same context object is iteratively given to exportable components via the <see cref="T:Microsoft.ML.Runtime.Model.Onnx.ICanSaveOnnx"/> interface
            and subinterfaces, that attempt to express their operations as ONNX nodes, if they can. At the point that it is
            given to a component, all other components up to that component have already attempted to express themselves in
            this context, with their outputs possibly available in the ONNX graph.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.GetNodeName(System.String)">
            <summary>
            Generates a unique name for the node based on a prefix.
            </summary>
            <param name="prefix">The prefix for the node</param>
            <returns>A name that has not yet been returned from this function, starting with <paramref name="prefix"/></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.ContainsColumn(System.String)">
            <summary>
            Looks up whether a given data view column has a mapping in the ONNX context. Once confirmed, callers can
            safely call <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.GetVariableName(System.String)"/>.
            </summary>
            <param name="colName">The data view column name</param>
            <returns>Whether the column is mapped in this context</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.RemoveColumn(System.String,System.Boolean)">
            <summary>
            Stops tracking a column.
            </summary>
            <param name="colName">Column name to stop tracking</param>
            <param name="removeVariable">Remove associated ONNX variable. This is useful in the event where an output
            variable is created through <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.AddIntermediateVariable(Microsoft.ML.Runtime.Data.ColumnType,System.String,System.Boolean)"/>before realizing
            the transform cannot actually save as ONNX.</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.RemoveVariable(System.String,System.Boolean)">
            <summary>
            Removes an ONNX variable. If removeColumn is true then it also removes the tracking for the <see
            cref="T:Microsoft.ML.Runtime.Data.IDataView"/> column associated with it.
            </summary>
            <param name="variableName">ONNX variable to remove. Note that this is an ONNX variable name, not an <see
            cref="T:Microsoft.ML.Runtime.Data.IDataView"/> column name</param>
            <param name="removeColumn">IDataView column to stop tracking</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.GetVariableName(System.String)">
            <summary>
            ONNX variables are referred to by name. At each stage of a ML.NET pipeline, the corresponding
            <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>'s column names will map to a variable in the ONNX graph if the intermediate steps
            used to calculate that value are things we knew how to save as ONNX. Retrieves the variable name that maps
            to the <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> column name at a given point in the pipeline execution. Callers should
            probably confirm with <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.ContainsColumn(System.String)"/> whether a mapping for that data view column
            already exists.
            </summary>
            <param name="colName">The data view column name</param>
            <returns>The ONNX variable name corresponding to that data view column</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.AddIntermediateVariable(Microsoft.ML.Runtime.Data.ColumnType,System.String,System.Boolean)">
            <summary>
            Establishes a new mapping from an data view column in the context, if necessary generates a unique name, and
            returns that newly allocated name.
            </summary>
            <param name="type">The data view type associated with this column name</param>
            <param name="colName">The data view column name</param>
            <param name="skip">Whether we should skip the process of establishing the mapping from data view column to
            ONNX variable name.</param>
            <returns>The returned value is the name of the variable corresponding </returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.CreateNode(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Creates an ONNX node
            </summary>
            <param name="opType">The name of the ONNX operator to apply</param>
            <param name="inputs">The names of the variables as inputs</param>
            <param name="outputs">The names of the variables to create as outputs,
            which ought to have been something returned from <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.AddIntermediateVariable(Microsoft.ML.Runtime.Data.ColumnType,System.String,System.Boolean)"/></param>
            <param name="name">The name of the operator, which ought to be something returned from <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.GetNodeName(System.String)"/></param>
            <param name="domain">The domain of the ONNX operator, if non-default</param>
            <returns>A node added to the in-progress ONNX graph, that attributes can be set on</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.CreateNode(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Convenience alternative to <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.CreateNode(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            for the case where there is exactly one input and output.
            </summary>
            <param name="opType">The name of the ONNX operator to apply</param>
            <param name="input">The name of the variable as input</param>
            <param name="output">The name of the variable as output,
            which ought to have been something returned from <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.AddIntermediateVariable(Microsoft.ML.Runtime.Data.ColumnType,System.String,System.Boolean)"/></param>
            <param name="name">The name of the operator, which ought to be something returned from <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.GetNodeName(System.String)"/></param>
            <param name="domain">The domain of the ONNX operator, if non-default</param>
            <returns>A node added to the in-progress ONNX graph, that attributes can be set on</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Onnx.OnnxNode">
            <summary>
            An abstraction for an ONNX node as created by
            <see cref="M:Microsoft.ML.Runtime.Model.Onnx.OnnxContext.CreateNode(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>.
            That method creates a with inputs and outputs, but this object can modify the node further
            by adding attributes (in ONNX parlance, attributes are more or less constant parameterizations).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext">
            <summary>
            This wraps a <see cref="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext"/>, except with auxiliary information
            that enables its inclusion relative to the <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> ecosystem.
            The idea is that one starts with a context built from some starting point,
            then subsequent transforms via <see cref="T:Microsoft.ML.Runtime.Model.Pfa.ITransformCanSavePfa"/> augment this context.
            Beyond what is offered in <see cref="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext"/>, <see cref="T:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext"/>
            has facilities to remember what column name in <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> maps to
            what token in the PFA being built up.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.Pfa">
            <summary>
            The internal PFA context, for an escape hatch.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext._nameToVarName">
            <summary>
            This will map from the "current" name of a data view column, to a corresponding
            token string.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext._unavailable">
            <summary>
            This contains a map of those names in
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.Finalize(Microsoft.ML.Runtime.Data.ISchema,System.String[])">
            <summary>
            This call will set <see cref="P:Microsoft.ML.Runtime.Model.Pfa.PfaContext.OutputType"/> to an appropriate output type based
            on the columns requested.
            </summary>
            <param name="schema">The schema corresponding to what we are outputting</param>
            <param name="toOutput">The columns to output</param>
            <returns>Returns a complete PFA program, where the output will correspond to the subset
            of columns from <paramref name="schema"/>.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.DeclareVar(System.Collections.Generic.KeyValuePair{System.String,Newtonsoft.Json.Linq.JToken}[])">
            <summary>
            Attempts to declare variables corresponding to a given column name. This
            will attempt to produce a PFA <c>let</c>/<c>set</c> declaration, and also
            do name mapping. The idea is that any transform implementing <see cref="T:Microsoft.ML.Runtime.Model.Pfa.ITransformCanSavePfa"/>
            will call this method to say, "hey, I produce this column, and this is the equivalent
            PFA for it."
            </summary>
            <param name="vars">The map from requested name, usually a dataview name,
            to the declaration</param>
            <returns>An array of assigned names in the PFA corresponding to the items in
            vars</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.Hide(System.String[])">
            <summary>
            As a complimentary operation to <see cref="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.DeclareVar(System.Collections.Generic.KeyValuePair{System.String,Newtonsoft.Json.Linq.JToken}[])"/>,
            this provides a mechanism for a transform to say, "hey, I am producing this column, but I
            am not writing any PFA for it, so if anyone asks for this column downstream don't say I
            have it."
            </summary>
            <param name="names">The names to hide</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.TokenOrNullForName(System.String)">
            <summary>
            Given an <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> column name, return the string for referencing the corresponding
            token in the PFA, or <c>null</c> if such a thing does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.IsInput(System.String)">
            <summary>
            Given an <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> column name, return whether in the PFA being built up
            whether the corresponding PFA variable is still the input. This will return <c>false</c>
            also in the event that the column is hidden, or simply not present.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.Pfa.ICanSavePfa.CanSavePfa">
            <summary>
            Whether this object really is capable of saving itself as part of a PFA
            pipeline. An implementor of this object might implement this interface,
            but still return <c>false</c> if there is some characteristic of this object
            only detectable during runtime that would prevent its being savable. (E.g.,
            it may wrap some other object that may or may not be savable.)
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Pfa.ISaveAsPfa">
            <summary>
            This component know how to save himself in Pfa format.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.ISaveAsPfa.SaveAsPfa(Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext)">
            <summary>
            Save as PFA. For any columns that are output, this interface should use
            <see cref="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.DeclareVar(System.String,Newtonsoft.Json.Linq.JToken)"/> to declare themselves,
            while any unwritable columns should be registered <see cref="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.Hide(System.String[])"/>.
            If <see cref="P:Microsoft.ML.Runtime.Model.Pfa.ICanSavePfa.CanSavePfa"/> is <c>false</c> this should not be called.
            </summary>
            <param name="ctx">The PFA program being built</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Pfa.ITransformCanSavePfa">
            <summary>
            This data model component is savable as PFA. See https://dmg.org/pfa/ .
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Pfa.IBindableCanSavePfa">
            <summary>
            This <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBindableMapper"/> is savable as a PFA. Note that this is
            typically called within an <see cref="T:Microsoft.ML.Runtime.Data.IDataScorerTransform"/> that is wrapping
            this mapper, and has already been bound to it.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.IBindableCanSavePfa.SaveAsPfa(Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext,Microsoft.ML.Runtime.Data.RoleMappedSchema,System.String[])">
            <summary>
            Save as PFA. If <see cref="P:Microsoft.ML.Runtime.Model.Pfa.ICanSavePfa.CanSavePfa"/> is
            <c>false</c> this should not be called. This method is intended to be called
            by the wrapping scorer transform, and is intended to produce enough information
            for that purpose.
            </summary>
            <param name="ctx">The PFA program being built</param>
            <param name="schema">The role mappings that was passed to this bindable
            object, when the <see cref="T:Microsoft.ML.Runtime.Data.ISchemaBoundMapper"/> was created that this transform
            is wrapping</param>
            <param name="outputNames">Since this method is called from a scorer transform,
            it is that transform that controls what the output column names will be, of
            the outputs produced by this bindable mapper. This is the array that holds
            those names, so that implementors of this method know what to produce in
            <paramref name="ctx"/>.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Pfa.ISingleCanSavePfa">
            <summary>
            For simple mappers. Intended to be used for <see cref="T:Microsoft.ML.Runtime.Data.IValueMapper"/> and
            <see cref="T:Microsoft.ML.Runtime.Internal.Calibration.ICalibrator"/> instances.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.ISingleCanSavePfa.SaveAsPfa(Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Implementors of this method are responsible for providing the PFA expression that
            computes the output of this object. Note that this method does not control what name
            will be given to the output, and is not responsible for declaring the variable into
            which the output will be returned. (Though, the method may of course declare other
            variables, cells, or such to enable this computation.)
            </summary>
            <param name="ctx">The PFA context</param>
            <param name="input">The PFA token representing the input. In the case of
            a predictor, for example, this would be a reference to the variable holding
            the features array.</param>
            <returns>A PFA expression</returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Pfa.IDistCanSavePfa">
            <summary>
            For simple mappers. Intended to be used for <see cref="T:Microsoft.ML.Runtime.Data.IValueMapperDist"/>
            instances.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.IDistCanSavePfa.SaveAsPfa(Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext,Newtonsoft.Json.Linq.JToken,System.String,Newtonsoft.Json.Linq.JToken@,System.String,Newtonsoft.Json.Linq.JToken@)">
            <summary>
            The call for distribution predictors. Unlike <see cref="M:Microsoft.ML.Runtime.Model.Pfa.ISingleCanSavePfa.SaveAsPfa(Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext,Newtonsoft.Json.Linq.JToken)"/>,
            this method requires this method to handle the declaration of the variables for their
            outputs, into the names <paramref name="score"/> and <paramref name="prob"/> provided.
            </summary>
            <param name="ctx">The PFA context</param>
            <param name="input">The PFA token representing the input. In nearly all cases this will
            be the name of the variable holding the features array.</param>
            <param name="score">The name of the column where the implementing method should
            save the expression, through <see cref="M:Microsoft.ML.Runtime.Model.Pfa.BoundPfaContext.DeclareVar(System.String,Newtonsoft.Json.Linq.JToken)"/>,
            or if <c>null</c></param>
            <param name="scoreToken"></param>
            <param name="prob">Similar to <paramref name="score"/>, except the probability expression.</param>
            <param name="probToken"></param>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Pfa.PfaContext">
            <summary>
            A context for defining a restricted sort of PFA output.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.PfaContext.CreateFuncBlock(Newtonsoft.Json.Linq.JArray,Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
            For creating an anonymous function block. This in itself will not modify the context.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.PfaContext.RegisterType(System.String)">
             <summary>
             PFA is weird in that you do not declare types separately, you declare them as part of a variable
             declaration. So, if you use a record type three times, that means one of the three usages must be
             accompanied by a full type declaration, whereas the other two can just then identify it by name.
             This is extremely silly, but there you go.
            
             Anyway: this will attempt to add a type to the list of registered types. If it returns <c>true</c>
             then the caller is responsible, then, for ensuring that their PFA code they are generating contains
             not only a reference of the type, but a declaration of the type. If however this returns <c>false</c>
             then it can just refer to the type by name, since it has already been declared.
             </summary>
             <param name="name">The type to register</param>
             <returns>If this name was not already registered</returns>
             <seealso cref="M:Microsoft.ML.Runtime.Model.Pfa.PfaContext.ContainsType(System.String)"/>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.Call(System.String,Newtonsoft.Json.Linq.JToken[])">
            <summary>
            Generic facilities for calling a function.
            </summary>
            <param name="func">The function to call</param>
            <param name="prms">The parameters for the function</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.VectorCase(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken,System.String,Newtonsoft.Json.Linq.JToken,System.String,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Builds a "cast" statement to the two vector types.
            </summary>
            <param name="itemType">The type of the item in the vector</param>
            <param name="src">The token we are casting</param>
            <param name="asMapName">The name for the token as it will appear in the <paramref name="mapDo"/></param>
            <param name="mapDo">The map case expression</param>
            <param name="asArrName">The name for the token as it will appear in the <paramref name="arrDo"/></param>
            <param name="arrDo">The array case expression</param>
            <returns>The cast/case expression</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureCount(Microsoft.ML.Runtime.Model.Pfa.PfaContext,Newtonsoft.Json.Linq.JToken)">
            <summary>
            This ensures that there is a function formatted as "count_type" (e.g., "count_double"),
            that takes either a map or array and returns the number of items in that map or array.
            </summary>
            <param name="ctx">The context to check for the existence of this</param>
            <param name="itemType">The item type this will operate on</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Pfa.PfaUtils.EnsureHasChars(Microsoft.ML.Runtime.Model.Pfa.PfaContext)">
            <summary>
            A string -> bool function for determining whether a string has content.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.SignatureLoadModel">
            <summary>
            Signature for a repository based model loader. This is the dual of ICanSaveModel.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.ICanSaveModel">
            <summary>
            For saving a model into a repository.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.ICanSaveInBinaryFormat">
            <summary>
            For saving to a single stream.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.Repository">
            <summary>
            Abstraction around a ZipArchive or other hierarchical storage.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.Repository.Entry.Path">
            <summary>
            The relative path of this entry.
            /// </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.Repository.Entry.Stream">
            <summary>
            The stream for this entry. This is either a memory stream or a file stream in
            the temporary directory. In either case, it is seekable and NOT the actual
            archive stream.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Model.Repository.ExceptionContext">
            <summary>
            Exception context.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Repository.DisposeAllEntries">
            <summary>
            Force all open entries to be disposed.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Repository.RemoveEntry(Microsoft.ML.Runtime.Model.Repository.Entry)">
            <summary>
            Remove the entry from _open. Note that under normal access patterns, entries are LIFO,
            so we search from the end of _open.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Repository.OnDispose(Microsoft.ML.Runtime.Model.Repository.Entry)">
            <summary>
            The entry is being disposed. Note that overrides should always call RemoveEntry, in addition to whatever
            they need to do with the corresponding stream.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Repository.NormalizeForArchiveEntry(System.String)">
            <summary>
            When considering entries inside one of our model archives, we want to ensure that we
            use a consistent directory separator. Zip archives are stored as flat lists of entries.
            When we load those entries into our look-up dictionary, we normalize them to always use
            backward slashes.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Repository.NormalizeForFileSystem(System.String)">
            <summary>
            When building paths to our local file system, we want to force both forward and backward slashes
            to the system directory separator character. We do this for cases where we either used Windows-specific
            path building logic, or concatenated filesystem paths with zip archive entries on Linux.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.Repository.GetPath(System.String@,System.String@,System.String,System.String,System.Boolean)">
            <summary>
            Constructs both the relative path to the entry and the absolute path of a corresponding
            temporary file. If createDir is true, makes sure the directory exists within the temp directory.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.RepositoryWriter.Commit">
            <summary>
            Commit the writing of the repository. This signals successful completion of the write.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.ModelFileUtils">
            <summary>
            This class provides utilities for loading components from the model file generated by MAML commands.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadPipeline(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream,Microsoft.ML.Runtime.Data.IMultiStreamSource,System.Boolean)">
            <summary>
            Loads and returns the loader and transforms from the specified model stream.
            </summary>
            <param name="env">The host environment to use.</param>
            <param name="modelStream">The model stream.</param>
            <param name="files">The data source to initialize the loader with.</param>
            <param name="extractInnerPipe">Whether to extract the transforms and loader from the wrapped CompositeDataLoader.</param>
            <returns>The created data view.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadPipeline(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.RepositoryReader,Microsoft.ML.Runtime.Data.IMultiStreamSource,System.Boolean)">
            <summary>
            Loads and returns the loader and transforms from the specified repository reader.
            </summary>
            <param name="env">The host environment to use.</param>
            <param name="rep">The repository reader.</param>
            <param name="files">The data source to initialize the loader with.</param>
            <param name="extractInnerPipe">Whether to extract the transforms and loader from the wrapped CompositeDataLoader.</param>
            <returns>The created data view.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadTransforms(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,System.IO.Stream)">
            <summary>
            Loads all transforms from the model stream, applies them sequentially to the provided data, and returns
            the resulting data. If there are no transforms in the stream, or if there's no DataLoader stream at all
            (this can happen if the model is produced by old TL), returns the source data.
            If the DataLoader stream is invalid, throws.
            </summary>
            <param name="env">The host environment to use.</param>
            <param name="data">The starting data view.</param>
            <param name="modelStream">The model stream.</param>
            <returns>The resulting data view.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadTransforms(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.Model.RepositoryReader)">
            <summary>
            Loads all transforms from the model stream, applies them sequentially to the provided data, and returns
            the resulting data. If there are no transforms in the stream, or if there's no DataLoader stream at all
            (this can happen if the model is produced by old TL), returns the source data.
            If the DataLoader stream is invalid, throws.
            </summary>
            <param name="env">The host environment to use.</param>
            <param name="data">The starting data view.</param>
            <param name="rep">The repository reader.</param>
            <returns>The resulting data view.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadPredictorOrNull(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Loads a predictor from the model stream. Returns null iff there's no predictor.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadPredictorOrNull(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.RepositoryReader)">
            <summary>
            Loads a predictor from the repository. Returns null iff there's no predictor.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.GetDataModelSavingContext(Microsoft.ML.Runtime.Model.RepositoryWriter)">
            <summary>
            Given a repository, returns the save context for saving the data loader model.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadLoader(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.RepositoryReader,Microsoft.ML.Runtime.Data.IMultiStreamSource,System.Boolean)">
            <summary>
            Loads data view (loader and transforms) from <paramref name="rep"/> if <paramref name="loadTransforms"/> is set to true,
            otherwise loads loader only.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.TryLoadFeatureNames(Microsoft.ML.Runtime.Internal.Internallearn.FeatureNameCollection@,Microsoft.ML.Runtime.Model.RepositoryReader)">
            <summary>
            REVIEW: consider adding an overload that returns <see cref="T:System.ReadOnlyMemory`1"/> of <see cref="T:System.Char"/>
            Loads optionally feature names from the repository directory.
            Returns false iff no stream was found for feature names, iff result is set to null.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.SaveRoleMappings(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,Microsoft.ML.Runtime.Data.RoleMappedSchema,Microsoft.ML.Runtime.Model.RepositoryWriter)">
            <summary>
            Save schema associations of role/column-name in <paramref name="rep"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadRoleMappingsOrNull(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Return role/column-name pairs loaded from <paramref name="modelStream"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadRoleMappingsOrNull(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.RepositoryReader)">
            <summary>
            Return role/column-name pairs loaded from a repository.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadRoleMappedSchemaOrNull(Microsoft.ML.Runtime.IHostEnvironment,System.IO.Stream)">
            <summary>
            Returns the <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedSchema"/> from a model stream, or <c>null</c> if there were no
            role mappings present.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Model.ModelFileUtils.LoadRoleMappedSchemaOrNull(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.Model.RepositoryReader)">
            <summary>
            Returns the <see cref="T:Microsoft.ML.Runtime.Data.RoleMappedSchema"/> from a repository, or <c>null</c> if there were no
            role mappings present.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.ModelFileUtils.RepositoryStreamWrapper">
            <summary>
            The RepositoryStreamWrapper is a IMultiStreamSource wrapper of a Stream object in a repository.
            It is used to deserialize RoleMappings.txt from a model zip file.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Model.ModelFileUtils.RepositoryStreamWrapper.EntryStream">
            <summary>
            A custom entry stream wrapper that includes custom dispose logic for disposing the entry
            when the stream is disposed.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.IPredictionTransformer`1">
            <summary>
            An interface for all the transformer that can transform data based on the <see cref="T:Microsoft.ML.Runtime.IPredictor"/> field.
            The implemendations of this interface either have no feature column, or have more than one feature column, and cannot implement the
            <see cref="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1"/>, which most of the ML.Net tranformer implement.
            </summary>
            <typeparam name="TModel">The <see cref="T:Microsoft.ML.Runtime.IPredictor"/> used for the data transformation.</typeparam>
        </member>
        <member name="T:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1">
            <summary>
            An ISingleFeaturePredictionTransformer contains the name of the <see cref="P:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1.FeatureColumn"/>
            and its type, <see cref="P:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1.FeatureColumnType"/>. Implementations of this interface, have the ability
            to score the data of an input <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> through the <see cref="M:Microsoft.ML.Core.Data.ITransformer.Transform(Microsoft.ML.Runtime.Data.IDataView)"/>
            </summary>
            <typeparam name="TModel">The <see cref="T:Microsoft.ML.Runtime.IPredictor"/> used for the data transformation.</typeparam>
        </member>
        <member name="P:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1.FeatureColumn">
            <summary>The name of the feature column.</summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.ISingleFeaturePredictionTransformer`1.FeatureColumnType">
            <summary>Holds information about the type of the feature column.</summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Training.TrainerBase`1.NoTrainingInstancesMessage">
            <summary>
            A standard string to use in errors or warnings by subclasses, to communicate the idea that no valid
            instances were able to be found.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2">
            <summary>
            This represents a basic class for 'simple trainer'.
            A 'simple trainer' accepts one feature column and one label column, also optionally a weight column.
            It produces a 'prediction transformer'.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.NoTrainingInstancesMessage">
            <summary>
            A standard string to use in errors or warnings by subclasses, to communicate the idea that no valid
            instances were able to be found.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.FeatureColumn">
            <summary>
            The feature column that the trainer expects.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.LabelColumn">
            <summary>
            The label column that the trainer expects. Can be <c>null</c>, which indicates that label
            is not used for training.
            </summary>
        </member>
        <member name="F:Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.WeightColumn">
            <summary>
            The weight column that the trainer expects. Can be <c>null</c>, which indicates that weight is
            not used for training.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.Info">
            <summary>
            The information about the trainer: whether it benefits from normalization, caching etc.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerEstimatorBase`2.GetOutputColumnsCore(Microsoft.ML.Core.Data.SchemaShape)">
            <summary>
            The columns that will be created by the fitted transformer.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.CursOpt">
            <summary>
            Options for creating a row cursor from a RoleMappedData with specified standard columns active.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector(Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Check for a standard (known-length vector of float) feature column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckFeatureFloatVector(Microsoft.ML.Runtime.Data.RoleMappedData,System.Int32@)">
            <summary>
            Check for a standard (known-length vector of float) feature column and determine its length.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckBinaryLabel(Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Check for a standard binary classification label.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckRegressionLabel(Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Check for a standard regression label.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiClassLabel(Microsoft.ML.Runtime.Data.RoleMappedData,System.Int32@)">
            <summary>
            Check for a standard multi-class label and determine its cardinality. If the column is a
            key type, it must have known cardinality. For other numeric types, this scans the data
            to determine the cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckMultiOutputRegressionLabel(Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Check for a standard regression label.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursor(Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Training.CursOpt,Microsoft.ML.Runtime.IRandom,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create a row cursor for the RoleMappedData with the indicated standard columns active.
            This does not verify that the columns exist, but merely activates the ones that do exist.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CreateRowCursorSet(Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Data.IRowCursorConsolidator@,Microsoft.ML.Runtime.Training.CursOpt,System.Int32,Microsoft.ML.Runtime.IRandom,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create a row cursor set for the RoleMappedData with the indicated standard columns active.
            This does not verify that the columns exist, but merely activates the ones that do exist.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Get the getter for the feature column, assuming it is a vector of float.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetFeatureFloatVectorGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Get the getter for the feature column, assuming it is a vector of float.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Get a getter for the label as a float. This assumes that the label column type
            has already been validated as appropriate for the kind of training being done.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetLabelFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedData)">
            <summary>
            Get a getter for the label as a float. This assumes that the label column type
            has already been validated as appropriate for the kind of training being done.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptWeightFloatGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Get the getter for the weight column, or null if there is no weight column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.GetOptGroupGetter(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Runtime.Data.RoleMappedSchema)">
            <summary>
            Get the getter for the group column, or null if there is no group column.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.MakeBoolScalarLabel(System.String)">
            <summary>
            The <see cref="T:Microsoft.ML.Core.Data.SchemaShape.Column"/> for the label column for binary classification tasks.
            </summary>
            <param name="labelColumn">name of the label column</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.MakeR4ScalarLabel(System.String)">
            <summary>
            The <see cref="T:Microsoft.ML.Core.Data.SchemaShape.Column"/> for the label column for regression tasks.
            </summary>
            <param name="labelColumn">name of the weight column</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.MakeU4ScalarLabel(System.String)">
            <summary>
            The <see cref="T:Microsoft.ML.Core.Data.SchemaShape.Column"/> for the label column for regression tasks.
            </summary>
            <param name="labelColumn">name of the weight column</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.MakeR4VecFeature(System.String)">
            <summary>
            The <see cref="T:Microsoft.ML.Core.Data.SchemaShape.Column"/> for the feature column.
            </summary>
            <param name="featureColumn">name of the feature column</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.MakeR4ScalarWeightColumn(System.String)">
            <summary>
            The <see cref="T:Microsoft.ML.Core.Data.SchemaShape.Column"/> for the weight column.
            </summary>
            <param name="weightColumn">name of the weight column</param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckArgsHaveDefaultColNames(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.EntryPoints.LearnerInputBaseWithGroupId)">
            <summary>
            Check that the label, feature, weights, groupId column names are not supplied in the args of the constructor, through the advancedSettings parameter,
            for cases when the public constructor is called.
            The recommendation is to set the column names directly.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainerUtils.CheckArgsAndAdvancedSettingMismatch``1(Microsoft.ML.Runtime.IChannel,``0,``0,``0,System.String)">
            <summary>
            If, after applying the advancedArgs delegate, the args are different that the default value
            and are also different than the value supplied directly to the xtension method, warn the user.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.TrainingCursorBase">
            <summary>
            This is the base class for a data cursor. Data cursors are specially typed
            "convenience" cursor-like objects, less general than a <see cref="T:Microsoft.ML.Runtime.Data.IRowCursor"/> but
            more convenient for common access patterns that occur in machine learning. For
            example, the common idiom of iterating over features/labels/weights while skipping
            "bad" features, labels, and weights. There will be two typical access patterns for
            users of the cursor. The first is just creation of the cursor using a constructor;
            this is best for one-off accesses of the data. The second access pattern, best for
            repeated accesses, is to use a cursor factory (usually a nested class of the cursor
            class). This keeps track of what filtering options were actually useful.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.#ctor(Microsoft.ML.Runtime.Data.IRowCursor,System.Action{Microsoft.ML.Runtime.Training.CursOpt})">
            <summary>
            The base constructor class for the factory-based cursor creation.
            </summary>
            <param name="input"></param>
            <param name="signal">This method is called </param>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.CursoringCompleteFlags">
             <summary>
             This method is called by <see cref="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.MoveNext"/> in the event we have reached the end
             of the cursoring. The intended usage is that it returns what flags will be passed to the signal
             delegate of the cursor, indicating what additional options should be specified on subsequent
             passes over the data. The base implementation checks if any rows were skipped, and if none were
             skipped, it signals the context that it needn't bother with any filtering checks.
            
             Because the result will be "or"-red, a perfectly acceptable implementation is that this
             return the default <see cref="T:Microsoft.ML.Runtime.Training.CursOpt"/>, in which case the flags will not ever change.
            
             If the cursor was created with a signal delegate, the return value of this method will be sent
             to that delegate.
             </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.MoveNext">
            <summary>
            Calls Cursor.MoveNext() and this.Accept() repeatedly until this.Accept() returns true.
            Returns false if Cursor.MoveNext() returns false. If you call Cursor.MoveNext() directly,
            also call this.Accept() to fetch the values of the current row. Note that if this.Accept()
            returns false, it's possible that not all values were fetched.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.Accept">
            <summary>
            This fetches and validates values for the standard active columns.
            It is called automatically by MoveNext(). Client code should only need
            to deal with this if it calls MoveNext() or MoveMany() on the underlying
            IRowCursor directly. That is, this is only for very advanced scenarios.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.TrainingCursorBase.FactoryBase`1">
            <summary>
            This is the base class for a data cursor factory. The factory is a reusable object,
            created with data and cursor options. From external non-implementing users it will
            appear to be more or less stateless, but internally it is keeping track of what sorts
            of filtering it needs to perform. For example, if we construct the factory with the
            option that it needs to filter out rows with bad feature values, but on the first
            iteration it is revealed there are no bad feature values, then it would be a complete
            waste of time to check on subsequent iterations over the data whether there are bad
            feature values again.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.FactoryBase`1.Create(Microsoft.ML.Runtime.IRandom,System.Int32[])">
            <summary>
            The typed analog to <see cref="M:Microsoft.ML.Runtime.Data.IDataView.GetRowCursor(System.Func{System.Int32,System.Boolean},Microsoft.ML.Runtime.IRandom)"/>.
            </summary>
            <param name="rand">Non-null if we are requesting a shuffled cursor.</param>
            <param name="extraCols">The extra columns to activate on the row cursor
            in addition to those required by the factory's options.</param>
            <returns>The wrapping typed cursor.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.FactoryBase`1.CreateSet(System.Int32,Microsoft.ML.Runtime.IRandom,System.Int32[])">
            <summary>
            The typed analog to <see cref="M:Microsoft.ML.Runtime.Data.IDataView.GetRowCursorSet(Microsoft.ML.Runtime.Data.IRowCursorConsolidator@,System.Func{System.Int32,System.Boolean},System.Int32,Microsoft.ML.Runtime.IRandom)"/>, this provides a
            partitioned cursoring of the data set, appropriate to multithreaded algorithms
            that want to consume parallel cursors without any consolidation.
            </summary>
            <param name="n">Suggested degree of parallelism.</param>
            <param name="rand">Non-null if we are requesting a shuffled cursor.</param>
            <param name="extraCols">The extra columns to activate on the row cursor
            in addition to those required by the factory's options.</param>
            <returns>The cursor set. Note that this needn't necessarily be of size
            <paramref name="n"/>.</returns>
        </member>
        <member name="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.FactoryBase`1.CreateCursorCore(Microsoft.ML.Runtime.Data.IRowCursor,Microsoft.ML.Runtime.Data.RoleMappedData,Microsoft.ML.Runtime.Training.CursOpt,System.Action{Microsoft.ML.Runtime.Training.CursOpt})">
            <summary>
            Called by both the <see cref="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.FactoryBase`1.Create(Microsoft.ML.Runtime.IRandom,System.Int32[])"/> and <see cref="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.FactoryBase`1.CreateSet(System.Int32,Microsoft.ML.Runtime.IRandom,System.Int32[])"/> factory methods. Implementors
            should instantiate the particular wrapping cursor.
            </summary>
            <param name="input">The row cursor we will wrap.</param>
            <param name="data">The data from which the row cursor was instantiated.</param>
            <param name="opt">The cursor options this row cursor was created with.</param>
            <param name="signal">The action that our wrapping cursor will call. Implementors of the cursor
            do not usually call it directly, but instead override
            <see cref="M:Microsoft.ML.Runtime.Training.TrainingCursorBase.CursoringCompleteFlags"/>, whose return value is used to call
            this action.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.TrainingCursorBase.FactoryBase`1.AndAccumulator">
            <summary>
            Accumulates signals from cursors, anding them together. Once it has
            all of the information it needs to signal the factory itself, it will
            do so.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.StandardScalarCursor">
            <summary>
            This supports Weight (float), Group (ulong), and Id (UInt128) columns.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.FeatureFloatVectorCursor">
            <summary>
            This derives from <see cref="T:Microsoft.ML.Runtime.Training.StandardScalarCursor"/> and adds the feature column
            as a <see cref="T:Microsoft.ML.Runtime.Data.VBuffer`1"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.FloatLabelCursor">
            <summary>
            This derives from the FeatureFloatVectorCursor and adds the Label (float) column.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.Training.MultiClassLabelCursor">
            <summary>
            This derives from the FeatureFloatVectorCursor and adds the Label (int) column,
            enforcing multi-class semantics.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.ISupportSdcaLoss">
            <summary>
            The loss function may know the close-form solution to the optimal dual update
            Ref: Sec(6.2) of http://jmlr.org/papers/volume14/shalev-shwartz13a/shalev-shwartz13a.pdf
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.ISupportSdcaLoss.DualUpdate(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Compute the dual update (\Delta\alpha_i) in SDCA
            - alpha: dual variable at the specified instance
            - lambdaN: L2 const x number of instances
            - cached invariant, hinted by the method above
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.ISupportSdcaLoss.DualLoss(System.Single,System.Double)">
            <summary>
            The dual loss function for a training example.
            If f(x) denotes the loss function on an individual training example,
            then this function returns -f*(-x*), where f*(x*) is the Fenchel conjugate
            of f(x).
            </summary>
            <param name="label">The label of the example.</param>
            <param name="dual">The dual variable of the example.</param>
        </member>
        <member name="T:Microsoft.ML.Runtime.HingeLoss">
            <summary>
            Hinge Loss
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.ExpLoss">
            <summary>
            Exponential Loss
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.PoissonLoss">
            <summary>
            Poisson Loss.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Runtime.TweedieLoss">
            <summary>
            Tweedie loss, based on the log-likelihood of the Tweedie distribution.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Runtime.TweedieLoss.#ctor(System.Double)">
            <summary>
            Constructor for Tweedie loss.
            </summary>
            <param name="index">Index parameter for the Tweedie distribution, in the range [1, 2].
            1 is Poisson loss, 2 is gamma loss, and intermediate values are compound Poisson loss.</param>
        </member>
        <member name="T:Microsoft.ML.Data.DataLoadSave.FakeSchema">
            <summary>
            A fake schema that is manufactured out of a SchemaShape.
            It will pretend that all vector sizes are equal to 10, all key value counts are equal to 10,
            and all values are defaults (for metadata).
            </summary>
        </member>
        <member name="T:Microsoft.ML.Data.ColumnCursorExtensions">
            <summary>
            Extension methods that allow to extract values of a single column of an <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> as an
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Data.ColumnCursorExtensions.GetColumn``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.String)">
            <summary>
            Extract all values of one column of the data view in a form of an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of the values. This must match the actual column type.</typeparam>
            <param name="data">The data view to get the column from.</param>
            <param name="env">The current host environment.</param>
            <param name="columnName">The name of the column to extract.</param>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.IsShapeAttribute">
             <summary>
             An indicator to the analyzer that this type parameter ought to be a valid schema-shape object (e.g., a leaf-tuple, or
             value-tuples of such) as the return type. Note that this attribute is typically only used in situations where a user
             might be essentially declaring that type, as opposed to using an already established shape type. So: a method that merely
             takes an already existing typed instance would tend on the other hand to not use this type parameter. To give an example:
             <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Append``1(System.Func{`1,``0})"/>
             has the parameter on the new output tuple shape.
            
             The cost to not specifying this on such an entry point is that the compile time type-checks on the shape parameters will
             no longer be enforced, which is suboptimal given that the purpose of the statically typed interfaces is to have compile-time
             checks. However, it is not disastrous since the runtime checks will still be in effect.
            
             User code may use this attribute on their types if they have generic type parameters that interface with this library.
             </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.PipelineColumn">
            <summary>
            This class is used as a type marker for <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> producing structures for use in the statically
            typed columnate pipeline building helper API. Users will not create these structures directly. Rather components
            will implement (hidden) subclasses of one of this classes subclasses (e.g., <see cref="T:Microsoft.ML.StaticPipe.Scalar`1"/>,
            <see cref="T:Microsoft.ML.StaticPipe.Vector`1"/>), which will contain information that the builder API can use to construct an actual
            sequence of <see cref="T:Microsoft.ML.Core.Data.IEstimator`1"/> objects.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Scalar`1">
            <summary>
            For representing a non-key, non-vector <see cref="T:Microsoft.ML.Runtime.Data.ColumnType"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Vector`1">
            <summary>
            For representing a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of known length.
            </summary>
            <typeparam name="T">The vector item type.</typeparam>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.NormVector`1">
            <summary>
            For representing a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> that is normalized, that is, its <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.IsNormalized"/>
            value is set with the value <c>true</c>.
            </summary>
            <typeparam name="T">The vector item type.</typeparam>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.VarVector`1">
            <summary>
            For representing a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of unknown length.
            </summary>
            <typeparam name="T">The vector item type.</typeparam>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Key`1">
            <summary>
            For representing a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality, where the type of key is not specified.
            </summary>
            <typeparam name="T">The physical type representing the key, which should always be one of <see cref="T:System.Byte"/>,
            <see cref="T:System.UInt16"/>, <see cref="T:System.UInt32"/>, or <see cref="T:System.UInt64"/></typeparam>
            <remarks>Note that a vector of keys type we would represent as <see cref="T:Microsoft.ML.StaticPipe.Vector`1"/> with a
            <see cref="T:Microsoft.ML.StaticPipe.Key`1"/> type parameter. Note also, if the type of the key is known then that should be represented
            by <see cref="T:Microsoft.ML.StaticPipe.Key`2"/>.</remarks>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Key`2">
            <summary>
            For representing a key-type of known cardinality that has key values over a particular type. This is used to
            represent a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> where it is known that it will have <see
            cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> of a particular type <typeparamref name="TVal"/>.
            </summary>
            <typeparam name="T">The physical type representing the key, which should always be one of <see cref="T:System.Byte"/>,
            <see cref="T:System.UInt16"/>, <see cref="T:System.UInt32"/>, or <see cref="T:System.UInt64"/></typeparam>
            <typeparam name="TVal">The type of values the key-type is enumerating. Commonly this is <see cref="T:System.String"/> but
            this is not necessary</typeparam>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.VarKey`1">
            <summary>
            For representing a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of unknown cardinality.
            </summary>
            <typeparam name="T">The physical type representing the key, which should always be one of <see cref="T:System.Byte"/>,
            <see cref="T:System.UInt16"/>, <see cref="T:System.UInt32"/>, or <see cref="T:System.UInt64"/></typeparam>
            <remarks>Note that unlike the <see cref="T:Microsoft.ML.StaticPipe.Key`1"/> and <see cref="T:Microsoft.ML.StaticPipe.Key`2"/> duality, there is no
            type corresponding to this type but with key-values, since key-values are necessarily a vector of known
            size so any enumeration into that set would itself be a key-value of unknown cardinality.</remarks>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.Reconciler">
            <summary>
            An object for <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> instances to indicate to the analysis code for static pipelines that
            they should be considered a single group of columns (through equality on the reconcilers), as well as how to
            actually create the underlying dynamic structures, whether an <see cref="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2"/>
            (for the <see cref="T:Microsoft.ML.StaticPipe.Runtime.ReaderReconciler`1"/>) or a <see cref="T:Microsoft.ML.Core.Data.IEstimator`1"/>
            (for the <see cref="T:Microsoft.ML.StaticPipe.Runtime.EstimatorReconciler"/>).
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.ReaderReconciler`1">
            <summary>
            Reconciler for column groups intended to resolve to a new <see cref="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2"/>
            or <see cref="T:Microsoft.ML.Core.Data.IDataReader`1"/>.
            </summary>
            <typeparam name="TIn">The input type of the <see cref="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2"/>
            object.</typeparam>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.ReaderReconciler`1.Reconcile(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.StaticPipe.PipelineColumn[],System.Collections.Generic.IReadOnlyDictionary{Microsoft.ML.StaticPipe.PipelineColumn,System.String})">
            <summary>
            Returns a data-reader estimator. Note that there are no input names because the columns from a data-reader
            estimator should have no dependencies.
            </summary>
            <param name="env">The host environment to use to create the data-reader estimator</param>
            <param name="toOutput">The columns that the object created by the reconciler should output</param>
            <param name="outputNames">A map containing</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.EstimatorReconciler">
            <summary>
            Reconciler for column groups intended to resolve to an <see cref="T:Microsoft.ML.Core.Data.IEstimator`1"/>. This type of
            reconciler will work with <see cref="M:Microsoft.ML.StaticPipe.Estimator`3.Append``1(System.Func{`1,``0})"/>
            or other methods that involve the creation of estimator chains.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.EstimatorReconciler.Reconcile(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.StaticPipe.PipelineColumn[],System.Collections.Generic.IReadOnlyDictionary{Microsoft.ML.StaticPipe.PipelineColumn,System.String},System.Collections.Generic.IReadOnlyDictionary{Microsoft.ML.StaticPipe.PipelineColumn,System.String},System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            Returns an estimator.
            </summary>
            <param name="env">The host environment to use to create the estimator</param>
            <param name="toOutput">The columns that the object created by the reconciler should output</param>
            <param name="inputNames">The name mapping that maps dependencies of the output columns to their names</param>
            <param name="outputNames">The name mapping that maps the output column to their names</param>
            <param name="usedNames">While most estimators allow full control over the names of their outputs, a limited
            subset of estimator transforms do not allow this: they produce columns whose names are unconfigurable. For
            these, there is this collection which provides the names used by the analysis tool. If the estimator under
            construction must use one of the names here, then they are responsible for "saving" the column they will
            overwrite using applications of the <see cref="T:Microsoft.ML.Runtime.Data.CopyColumnsEstimator"/>. Note that if the estimator under
            construction has complete control over what columns it produces, there is no need for it to pay this argument
            any attention.</param>
            <returns>Returns an estimator.</returns>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext">
             <summary>
             An object for declaring a schema-shape. This is mostly commonly used in situations where a user is
             asserting that a dynamic object bears a certain specific static schema. For example: when phrasing
             the dynamically typed <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/> as being a specific <see cref="T:Microsoft.ML.StaticPipe.DataView`1"/>.
             It is never created by the user directly, but instead an instance is typically fed in as an argument
             to a delegate, and the user will call methods on this context to indicate a certain type is so.
             </summary>
             <remarks>
             All <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> objects are, deliberately, imperitavely useless as they are
             intended to be used only in a declarative fashion. The methods and properties of this class go one step
             further and return <c>null</c> for everything with a return type of <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/>.
            
             Because <see cref="T:Microsoft.ML.Runtime.Data.IDataView"/>'s type system is extensible, assemblies that declare their own types
             should allow users to assert typedness in their types by defining extension methods over this class.
             However, even failing the provision of such a helper, a user can still provide a workaround by just
             declaring the type as something like <c>default(Scalar&lt;TheCustomType&gt;</c>, without using the
             instance of this context.
             </remarks>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.I1">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I1"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.I2">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I2"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.I4">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I4"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.I8">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I8"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.U1">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U1"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.U2">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U2"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.U4">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U4"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.U8">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U8"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.R4">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.R4"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.R8">
            <summary>Assertions over a column of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.R8"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.Text">
            <summary>Assertions over a column of <see cref="T:Microsoft.ML.Runtime.Data.TextType"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.Bool">
            <summary>Assertions over a column of <see cref="T:Microsoft.ML.Runtime.Data.BoolType"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyU1">
            <summary>Assertions over a column of <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> with <see cref="F:Microsoft.ML.Runtime.Data.DataKind.U1"/> <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.RawKind"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyU2">
            <summary>Assertions over a column of <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> with <see cref="F:Microsoft.ML.Runtime.Data.DataKind.U2"/> <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.RawKind"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyU4">
            <summary>Assertions over a column of <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> with <see cref="F:Microsoft.ML.Runtime.Data.DataKind.U4"/> <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.RawKind"/>.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyU8">
            <summary>Assertions over a column of <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> with <see cref="F:Microsoft.ML.Runtime.Data.DataKind.U8"/> <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.RawKind"/>.</summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.PrimitiveTypeAssertions`1">
            <summary>
            Holds assertions relating to the basic primitive types.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.PrimitiveTypeAssertions`1.Scalar">
            <summary>
            Asserts a type that is directly this <see cref="T:Microsoft.ML.Runtime.Data.PrimitiveType"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.PrimitiveTypeAssertions`1.Vector">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of this <see cref="T:Microsoft.ML.Runtime.Data.PrimitiveType"/>,
            where <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.IsKnownSizeVector"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.PrimitiveTypeAssertions`1.VarVector">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of this <see cref="T:Microsoft.ML.Runtime.Data.PrimitiveType"/>,
            where <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.IsKnownSizeVector"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.NormalizableTypeAssertions`1.Scalar">
            <summary>
            Asserts a type that is directly this <see cref="T:Microsoft.ML.Runtime.Data.PrimitiveType"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.NormalizableTypeAssertions`1.Vector">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of this <see cref="T:Microsoft.ML.Runtime.Data.PrimitiveType"/>,
            where <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.IsKnownSizeVector"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.NormalizableTypeAssertions`1.VarVector">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of this <see cref="T:Microsoft.ML.Runtime.Data.PrimitiveType"/>,
            where <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.IsKnownSizeVector"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.NormalizableTypeAssertions`1.NormVector">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of this <see cref="T:Microsoft.ML.Runtime.Data.PrimitiveType"/>,
            where <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.IsKnownSizeVector"/> is true, and the <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.IsNormalized"/>
            metadata is defined with a Boolean <c>true</c> value.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeVectorAssertions`1">
            <summary>
            Once a single general key type has been selected, we can select its vector-ness.
            </summary>
            <typeparam name="T">The static type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/>.</typeparam>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeVectorAssertions`1.Scalar">
            <summary>
            Asserts a type that is directly this <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeVectorAssertions`1.Vector">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of this <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/>,
            where <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.IsKnownSizeVector"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeVectorAssertions`1.VarVector">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.VectorType"/> of this <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/>,
            where <see cref="P:Microsoft.ML.Runtime.Data.ColumnType.IsKnownSizeVector"/> is true.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1">
            <summary>
            Assertions for key types of various forms. Used to select a particular <see cref="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeVectorAssertions`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.NoValue">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> where <see cref="P:Microsoft.ML.Runtime.Data.KeyType.Count"/> is positive, that is, is of known cardinality,
            but that we are not asserting has any particular type of <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.UnknownCardinality">
            <summary>
            Asserts a type corresponding to a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> where <see cref="P:Microsoft.ML.Runtime.Data.KeyType.Count"/> is zero, that is, is of unknown cardinality.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.I1Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I1"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.I2Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I2"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.I4Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I4"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.I8Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.I8"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.U1Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U1"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.U2Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U2"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.U4Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U4"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.U8Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.U8"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.R4Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.R4"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.R8Values">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="P:Microsoft.ML.Runtime.Data.NumberType.R8"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.TextValues">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="T:Microsoft.ML.Runtime.Data.TextType"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext.KeyTypeSelectorAssertions`1.BoolValues">
            <summary>Asserts a <see cref="T:Microsoft.ML.Runtime.Data.KeyType"/> of known cardinality with a vector of <see cref="T:Microsoft.ML.Runtime.Data.BoolType"/> <see cref="F:Microsoft.ML.Runtime.Data.MetadataUtils.Kinds.KeyValues"/> metadata.</summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils">
            <summary>
            Utility functions useful for the internal implementations of the key pipeline utilities.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.MakeAnalysisInstance``1(Microsoft.ML.StaticPipe.Runtime.ReaderReconciler{System.Int32}@)">
            <summary>
            Given a type which is a <see cref="T:System.ValueTuple"/> tree with <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> leaves, return an instance of that
            type which has appropriate instances of <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> that use the returned reconciler.
            </summary>
            <param name="fakeReconciler">This is a data-reconciler that always reconciles to a <c>null</c> object</param>
            <typeparam name="T">A type of either <see cref="T:System.ValueTuple"/> or one of the major <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> subclasses
            (e.g., <see cref="T:Microsoft.ML.StaticPipe.Scalar`1"/>, <see cref="T:Microsoft.ML.StaticPipe.Vector`1"/>, etc.)</typeparam>
            <returns>An instance of <typeparamref name="T"/> where all <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> fields have the provided reconciler</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.AnalyzeUtil.UnstructedCreate``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            Note that we use this instead of <see cref="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)"/>
            for the eight-item because that method will embed the last element into a one-element tuple,
            which is embedded in the original. The actual physical representation, which is what is relevant here,
            has no real conveniences around its creation.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.GetNamesValues``1(``0,System.Reflection.ParameterInfo)">
            <summary>
            Given a schema shape defining instance, return the pairs of names and values, based on a recursive
            traversal of the value-tuple. If in that list the value <c>a.b.c</c> is paired with an item <c>x</c>,
            then programmatically <paramref name="record"/> when accessed as <paramref name="record"/><c>.a.b.c</c>
            would be that item <c>x</c>.
            </summary>
            <typeparam name="T">The schema shape defining type.</typeparam>
            <param name="record">The instance of that schema shape defining type, whose items will
            populate the <see cref="P:System.Collections.Generic.KeyValuePair`2.Value"/> fields of the returned items.</param>
            <param name="pInfo">It is an implementation detail of the value-tuple type that the names
            are not associated with the type at all, but there is instead an illusion propagated within
            Visual Studio, that works via attributes. Programmatic access to this is limited, except that
            a <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute"/> is attached to the type in appropriate places, e.g.,
            in a delegate one of the parameters, or the return parameter, or somesuch. If present, the names
            will be extracted from that structure, and if not the default names of <c>Item1</c>, <c>Item2</c>,
            etc. will be used.</param>
            <returns>The set of names and corresponding values.</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.IsAssignableFromStaticPipeline(System.Type,System.Type)">
            <summary>
            A sort of extended version of <see cref="M:System.Type.IsAssignableFrom(System.Type)"/> that accounts
            for the presence of the <see cref="T:Microsoft.ML.StaticPipe.Vector`1"/>, <see cref="T:Microsoft.ML.StaticPipe.VarVector`1"/> and <see cref="T:Microsoft.ML.StaticPipe.NormVector`1"/> types. />
            </summary>
            <param name="to">Can we assign to this type?</param>
            <param name="from">From that type?</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.NameUtil`1">
            <summary>
            Utility for extracting names out of value-tuple tree structures.
            </summary>
            <typeparam name="TLeaf"></typeparam>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.NameUtil`1.GetNames``1(``0,System.Reflection.ParameterInfo)">
             <summary>
             A utility for exacting name/type/value triples out of a value-tuple based tree structure.
            
             For example: If <typeparamref name="TLeaf"/> were <see cref="T:System.Int32"/> then the value-tuple
             <c>(a: 1, b: (c: 2, d: 3), e: 4)</c> would result in the return array where the name/value
             pairs were <c>[("a", 1), ("b.c", 2), ("b.d", 3), "e", 4]</c>, in some order, and the type
             is <c>typeof(int)</c>.
            
             Note that the type returned in the triple is the type as declared in the tuple, which will
             be a derived type of <typeparamref name="TLeaf"/>, and in turn the type of the value will be
             of a type derived from that type.
            
             This method will throw if anything other than value-tuples or <typeparamref name="TLeaf"/>
             instances are detected during its execution.
             </summary>
             <typeparam name="T">The type to extract on.</typeparam>
             <param name="record">The instance to extract values out of.</param>
             <param name="pInfo">A type parameter associated with this, usually extracted out of some
             delegate over this value tuple type. Note that names in value-tuples are an illusion perpetrated
             by the C# compiler, and are not accessible though <typeparamref name="T"/> by reflection, which
             is why it is necessary to engage in trickery like passing in a delegate over those types, which
             does retain the information on the names.</param>
             <returns>The list of name/type/value triples extracted out of the tree like-structure</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.NameUtil`1.RecurseNames``1(System.Object,System.Collections.Generic.IList{System.String},System.Int32,System.String,System.Collections.Generic.List{System.ValueTuple{System.String,System.Type,`0}})">
            <summary>
            Helper method for <see cref="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeInternalUtils.GetNamesValues``2(``0,System.Reflection.ParameterInfo)"/>, that given a <see cref="T:System.ValueTuple"/>
            <paramref name="record"/> will either append triples to <paramref name="accum"/> (if the item is of type
            <typeparamref name="TLeaf"/>), or recurse on this function (if the item is a <see cref="T:System.ValueTuple"/>),
            or otherwise throw an error.
            </summary>
            <typeparam name="T">The type we are recursing on, should be a <see cref="T:System.ValueTuple"/> of some sort</typeparam>
            <param name="record">The <see cref="T:System.ValueTuple"/> we are extracting on. Note that this is <see cref="T:System.Object"/>
            just for the sake of ease of using
            <see cref="M:Microsoft.ML.Runtime.Internal.Utilities.Utils.MarshalInvoke``6(System.Func{``0,``1,``2,``3,``4,``5},System.Type,``0,``1,``2,``3,``4)"/></param>.
            <param name="names">The names list extracted from the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute"/> attribute, or <c>null</c>
            if no such attribute could be found.</param>
            <param name="namesOffset">The offset into <paramref name="names"/> where <paramref name="record"/>'s names begin.</param>
            <param name="namePrefix"><c>null</c> for the root level structure, or the appendation of <c>.</c> suffixed names
            of the path of value-tuples down to this item.</param>
            <param name="accum">The list into which the names are being added</param>
            <returns>The total number of items added to <paramref name="accum"/></returns>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils">
            <summary>
            Utility methods for components that want to expose themselves in the idioms of the statically-typed pipelines.
            These utilities are meant to be called by and useful to component authors, not users of those components. The
            purpose is not to keep them hidden per se, but rather in a place less conspicuous to users that are just trying
            to use the library without writing additional components of their own.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.ReaderEstimatorAnalyzerHelper``3(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Runtime.IChannel,``1,Microsoft.ML.StaticPipe.Runtime.ReaderReconciler{``0},System.Func{``1,``2})">
            <summary>
            This is a utility method intended to be used by authors of <see cref="T:Microsoft.ML.Core.Data.IDataReaderEstimator`2"/> components to provide a strongly typed <see cref="T:Microsoft.ML.StaticPipe.DataReaderEstimator`3"/>.
            This analysis tool provides a standard way for readers to exploit statically typed pipelines with the
            standard tuple-shape objects without having to write such code themselves.
            </summary>
            <param name="env">Estimators will be instantiated with this environment</param>
            /// <param name="ch">Some minor debugging information will be passed along to this channel</param>
            <param name="input">The input that will be used when invoking <paramref name="mapper"/>, which is used
            either to produce the input columns.</param>
            <param name="baseReconciler">All columns that are yielded by <paramref name="input"/> should produce this
            single reconciler. The analysis code in this method will ensure that this is the first object to be
            reconciled, before all others.</param>
            <param name="mapper">The user provided delegate.</param>
            <typeparam name="TIn">The type parameter for the input type to the data reader estimator.</typeparam>
            <typeparam name="TDelegateInput">The input type of the input delegate. This might be some object out of
            which one can fetch or else retrieve </typeparam>
            <typeparam name="TTupleOutShape"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.GetEnvironment``1(Microsoft.ML.StaticPipe.SchemaBearing{``0})">
            <summary>
            Retrieves the internally stored environment in <paramref name="schematized"/>.
            Intended usecases is component generating code that needs to have access to an
            environment.
            </summary>
            <typeparam name="T">The shape type.</typeparam>
            <param name="schematized">The object for which we get the environment.</param>
            <returns>The internal <see cref="T:Microsoft.ML.Runtime.IHostEnvironment"/> of the object.</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.GetIndexer``1(Microsoft.ML.StaticPipe.SchemaBearing{``0})">
            <summary>
            Retrieves the index helper object for <paramref name="schematized"/>.
            </summary>
            <typeparam name="T">The shape type.</typeparam>
            <param name="schematized">The object for which we get the indexer.</param>
            <returns>The index helper.</returns>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1">
            <summary>
            An indexer that can be constructed over a static pipeline object, to enable us to determine
            the names of the columns. This is used by component authors to allow users to "select" a column,
            but the structure is itself not directly used by users of the API as a general rule. Rather,
            one might imagine the component exposing some sort of delegate taking method that given the
            instance <see cref="P:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Indices"/>, returns one of the <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> instances stored
            therein, which the component can use to do specific operations.
            </summary>
            <typeparam name="T">The shape type.</typeparam>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Indices">
            <summary>
            An instance of the shape type whose items can be used to index to find the names of column.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Map">
            <summary>
            Maps the items inside <see cref="P:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Indices"/> to the names of the associated data's column's name.
            Components can use this structure, but it may be preferable to use <see cref="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Get(Microsoft.ML.StaticPipe.PipelineColumn,Microsoft.ML.Runtime.IExceptionContext)" />
            to ensure uniformity in the exception messages, if possible.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Get(Microsoft.ML.StaticPipe.PipelineColumn,Microsoft.ML.Runtime.IExceptionContext)">
            <summary>
            Performs a lookup on <see cref="P:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Map"/>. If the key is not present this will throw an exception
            more generally helpful in context than that of a direct failure of index on <see cref="P:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.Map"/>.
            </summary>
            <param name="key">The column to look up.</param>
            <param name="ectx">The optional exception context.</param>
            <returns>If successful the name of the column.</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.#ctor(Microsoft.ML.StaticPipe.SchemaBearing{`0})">
            <summary>
            Constructor for the index helper. Note that any public or component code will instead use
            <see cref="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.GetIndexer``1(Microsoft.ML.StaticPipe.SchemaBearing{``0})"/>, to fetch the lazily constructed instance of this
            object, since its construction is somewhat expensive.
            </summary>
            <param name="schematized">Constructs the helper for this object.</param>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape">
            <summary>
            A schema shape with names corresponding to a type parameter in one of the typed variants
            of the data pipeline structures. Instances of this class tend to be bundled with the statically
            typed variants of the dynamic structures (e.g., <see cref="T:Microsoft.ML.StaticPipe.DataView`1"/> and so forth),
            and their primary purpose is to ensure that the schemas of the dynamic structures and the
            statically declared structures are compatible.
            </summary>
        </member>
        <member name="F:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape.Pairs">
            <summary>
            The enumeration of name/type pairs. Do not modify.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape.Make``1(System.Reflection.ParameterInfo)">
            <summary>
            Creates a new instance out of a parameter info, presumably fetched from a user specified delegate.
            </summary>
            <typeparam name="TTupleShape">The static tuple-shape type</typeparam>
            <param name="info">The parameter info on the method, whose type should be
            <typeparamref name="TTupleShape"/></param>
            <returns>A new instance with names and members types enumerated</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape.Check(Microsoft.ML.Runtime.IExceptionContext,Microsoft.ML.Runtime.Data.ISchema)">
            <summary>
            Checks whether this object is consistent with an actual schema from a dynamic object,
            throwing exceptions if not.
            </summary>
            <param name="ectx">The context on which to throw exceptions</param>
            <param name="schema">The schema to check</param>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape.Check(Microsoft.ML.Runtime.IExceptionContext,Microsoft.ML.Core.Data.SchemaShape)">
            <summary>
            Checks whether this object is consistent with an actual schema shape from a dynamic object,
            throwing exceptions if not.
            </summary>
            <param name="ectx">The context on which to throw exceptions</param>
            <param name="shape">The schema shape to check</param>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape.IsStandard(Microsoft.ML.Runtime.IExceptionContext,System.Type)">
            <summary>
            Returns true if the input type is something recognizable as being oen of the standard
            builtin types. This method will also throw if something is detected as being definitely
            wrong (e.g., the input type does not descend from <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> at all,
            or a <see cref="T:Microsoft.ML.StaticPipe.Key`1"/> is declared with a <see cref="T:System.String"/> type parameter or
            something.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape.GetTypeOrNull(Microsoft.ML.Runtime.Data.IColumn)">
            <summary>
            Returns a .NET type corresponding to the static pipelines that would tend to represent this column.
            Generally this will return <c>null</c> if it simply does not recognize the type but might throw if
            there is something seriously wrong with it.
            </summary>
            <param name="col">The column</param>
            <returns>The .NET type for the static pipelines that should be used to reflect this type, given
            both the characteristics of the <see cref="T:Microsoft.ML.Runtime.Data.ColumnType"/> as well as one or two crucial pieces of metadata</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape.StaticKind(Microsoft.ML.Runtime.Data.DataKind)">
            <summary>
            Note that this can return a different type than the actual physical representation type, e.g., for
            <see cref="F:Microsoft.ML.Runtime.Data.DataKind.Text"/> the return type is <see cref="T:System.String"/>, even though we do not use that
            type for communicating text.
            </summary>
            <returns>The basic type used to represent an item type in the static pipeline</returns>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler">
            <summary>
            General purpose reconciler for a typical case with trainers, where they accept some generally
            fixed number of inputs, and produce some outputs where the names of the outputs are fixed.
            Authors of components that want to produce columns can subclass this directly, or use one of the
            common nested subclasses.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Outputs">
            <summary>
            The output columns. Note that subclasses should return exactly the same items each time,
            and the items should correspond to the output names passed into the constructor.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.#ctor(Microsoft.ML.StaticPipe.PipelineColumn[],System.String[])">
            <summary>
            Constructor for the base class.
            </summary>
            <param name="inputs">The set of inputs</param>
            <param name="outputNames">The names of the outputs, which we assume cannot be changed</param>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.ReconcileCore(Microsoft.ML.Runtime.IHostEnvironment,System.String[])">
            <summary>
            Produce the training estimator.
            </summary>
            <param name="env">The host environment to use to create the estimator.</param>
            <param name="inputNames">The names of the inputs, which corresponds exactly to the input columns
            fed into the constructor.</param>
            <returns>An estimator, which should produce the additional columns indicated by the output names
            in the constructor.</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Reconcile(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.StaticPipe.PipelineColumn[],System.Collections.Generic.IReadOnlyDictionary{Microsoft.ML.StaticPipe.PipelineColumn,System.String},System.Collections.Generic.IReadOnlyDictionary{Microsoft.ML.StaticPipe.PipelineColumn,System.String},System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            Produces the estimator. Note that this is made out of <see cref="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.ReconcileCore(Microsoft.ML.Runtime.IHostEnvironment,System.String[])"/>'s
            return value, plus whatever usages of <see cref="T:Microsoft.ML.Runtime.Data.CopyColumnsEstimator"/> are necessary to avoid collisions with
            the output names fed to the constructor. This class provides the implementation, and subclasses should instead
            override <see cref="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.ReconcileCore(Microsoft.ML.Runtime.IHostEnvironment,System.String[])"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Regression">
            <summary>
            A reconciler for regression capable of handling the most common cases for regression.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Regression.EstimatorFactory">
            <summary>
            The delegate to create the regression trainer instance.
            </summary>
            <param name="env">The environment with which to create the estimator</param>
            <param name="label">The label column name</param>
            <param name="features">The features column name</param>
            <param name="weights">The weights column name, or <c>null</c> if the reconciler was constructed with <c>null</c> weights</param>
            <returns>A estimator producing columns with the fixed name <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Score"/>.</returns>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Regression.Score">
            <summary>
            The output score column for the regression. This will have this instance as its reconciler.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Regression.#ctor(Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Regression.EstimatorFactory,Microsoft.ML.StaticPipe.Scalar{System.Single},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single})">
            <summary>
            Constructs a new general regression reconciler.
            </summary>
            <param name="estimatorFactory">The delegate to create the training estimator. It is assumed that this estimator
            will produce a single new scalar <see cref="T:System.Single"/> column named <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Score"/>.</param>
            <param name="label">The input label column.</param>
            <param name="features">The input features column.</param>
            <param name="weights">The input weights column, or <c>null</c> if there are no weights.</param>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifier">
            <summary>
            A reconciler capable of handling the most common cases for binary classification with calibrated outputs.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifier.EstimatorFactory">
            <summary>
            The delegate to create the binary classifier trainer instance.
            </summary>
            <param name="env">The environment with which to create the estimator.</param>
            <param name="label">The label column name.</param>
            <param name="features">The features column name.</param>
            <param name="weights">The weights column name, or <c>null</c> if the reconciler was constructed with <c>null</c> weights.</param>
            <returns>A binary classification trainer estimator.</returns>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifier.Output">
            <summary>
            The general output for binary classifiers.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifier.#ctor(Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifier.EstimatorFactory,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single})">
            <summary>
            Constructs a new general regression reconciler.
            </summary>
            <param name="estimatorFactory">The delegate to create the training estimator. It is assumed that this estimator
            will produce a single new scalar <see cref="T:System.Single"/> column named <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Score"/>.</param>
            <param name="label">The input label column.</param>
            <param name="features">The input features column.</param>
            <param name="weights">The input weights column, or <c>null</c> if there are no weights.</param>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifierNoCalibration">
            <summary>
            A reconciler capable of handling the most common cases for binary classification that does not
            necessarily have calibrated outputs.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifierNoCalibration.EstimatorFactory">
            <summary>
            The delegate to create the binary classifier trainer instance.
            </summary>
            <param name="env">The environment with which to create the estimator</param>
            <param name="label">The label column name.</param>
            <param name="features">The features column name.</param>
            <param name="weights">The weights column name, or <c>null</c> if the reconciler was constructed with <c>null</c> weights.</param>
            <returns>A binary classification trainer estimator.</returns>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifierNoCalibration.Output">
            <summary>
            The general output for binary classifiers.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifierNoCalibration.Outputs">
            <summary>
            The output columns, which will contain at least the columns produced by <see cref="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifierNoCalibration.Output"/> and may contain an
            additional <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Probability"/> column if at runtime we determine the predictor actually
            is calibrated.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifierNoCalibration.#ctor(Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.BinaryClassifierNoCalibration.EstimatorFactory,Microsoft.ML.StaticPipe.Scalar{System.Boolean},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single},System.Boolean)">
            <summary>
            Constructs a new general binary classifier reconciler.
            </summary>
            <param name="estimatorFactory">The delegate to create the training estimator. It is assumed that this estimator
            will produce a single new scalar <see cref="T:System.Single"/> column named <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Score"/>.</param>
            <param name="label">The input label column.</param>
            <param name="features">The input features column.</param>
            <param name="weights">The input weights column, or <c>null</c> if there are no weights.</param>
            <param name="hasProbs">While this type is a compile time construct, it may be that at runtime we have determined that we will have probabilities,
            and so ought to do the renaming of the <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Probability"/> column anyway if appropriate. If this is so, then this should
            be set to true.</param>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Clustering">
            <summary>
            A reconciler capable of handling clustering.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Clustering.EstimatorFactory">
            <summary>
            The delegate to create the clustering trainer instance.
            </summary>
            <param name="env">The environment with which to create the estimator.</param>
            <param name="features">The features column name.</param>
            <param name="weights">The weights column name, or <c>null</c> if the reconciler was constructed with <c>null</c> weights.</param>
            <returns>A clustering trainer estimator.</returns>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Clustering.Output">
            <summary>
            The general output for clustering.
            </summary>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Clustering.Outputs">
            <summary>
            The output columns, which will contain the columns produced by <see cref="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Clustering.Output"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Clustering.#ctor(Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.Clustering.EstimatorFactory,Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single})">
            <summary>
            Constructs a new general clustering reconciler.
            </summary>
            <param name="estimatorFactory">The delegate to create the training estimator. It is assumed that this estimator
            will produce a new scalar <see cref="T:System.Single"/> column named <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Score"/> and a <see cref="T:Microsoft.ML.StaticPipe.Key`1"/>
            named PredictedLabel.</param>
            <param name="features">The input features column.</param>
            <param name="weights">The input weights column, or <c>null</c> if there are no weights.</param>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.MulticlassClassifier`1">
            <summary>
            A reconciler for regression capable of handling the most common cases for regression.
            </summary>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.MulticlassClassifier`1.EstimatorFactory">
            <summary>
            The delegate to create the multiclass classifier trainer instance.
            </summary>
            <param name="env">The environment with which to create the estimator</param>
            <param name="label">The label column name</param>
            <param name="features">The features column name</param>
            <param name="weights">The weights column name, or <c>null</c> if the reconciler was constructed with <c>null</c> weights</param>
            <returns>A estimator producing columns with the fixed name <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Score"/> and <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.PredictedLabel"/>.</returns>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.MulticlassClassifier`1.Output">
            <summary>
            The general output for multiclass classifiers.
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.MulticlassClassifier`1.#ctor(Microsoft.ML.StaticPipe.Runtime.TrainerEstimatorReconciler.MulticlassClassifier{`0}.EstimatorFactory,Microsoft.ML.StaticPipe.Key{System.UInt32,`0},Microsoft.ML.StaticPipe.Vector{System.Single},Microsoft.ML.StaticPipe.Scalar{System.Single})">
            <summary>
            Constructs a new general multiclass classifier reconciler.
            </summary>
            <param name="estimatorFactory">The delegate to create the training estimator. It is assumed that this estimator
            will produce a vector <see cref="T:System.Single"/> column named <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.Score"/> and a scalar
            key column named <see cref="F:Microsoft.ML.Runtime.Data.DefaultColumnNames.PredictedLabel"/>.</param>
            <param name="label">The input label column.</param>
            <param name="features">The input features column.</param>
            <param name="weights">The input weights column, or <c>null</c> if there are no weights.</param>
        </member>
        <member name="T:Microsoft.ML.StaticPipe.SchemaBearing`1">
            <summary>
            A base class for the statically-typed pipeline components, that are marked as producing
            data whose schema has a certain shape.
            </summary>
            <typeparam name="TTupleShape"></typeparam>
        </member>
        <member name="P:Microsoft.ML.StaticPipe.SchemaBearing`1.Indexer">
            <summary>
            The indexer for the object. Note component authors will not access this directly but should instead
            work via the public method <see cref="M:Microsoft.ML.StaticPipe.Runtime.StaticPipeUtils.IndexHelper`1.#ctor(Microsoft.ML.StaticPipe.SchemaBearing{`0})"/>
            </summary>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.SchemaBearing`1.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.StaticPipe.Runtime.StaticSchemaShape)">
            <summary>
            Constructor for a block maker.
            </summary>
            <param name="env">The host environment, stored with this object</param>
            <param name="shape">The item holding the name and types as enumerated within
            <typeparamref name="TTupleShape"/></param>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.SchemaBearing`1.MakeNewEstimator">
            <summary>
            Starts a new pipeline, using the output schema of this object. Note that the returned
            estimator does not contain this object, but it has its schema informed by <typeparamref name="TTupleShape"/>.
            The returned object is an empty estimator, on which a new segment of the pipeline can be created.
            </summary>
            <returns>An empty estimator with the same shape as the object on which it was created</returns>
        </member>
        <member name="M:Microsoft.ML.StaticPipe.StaticPipeExtensions.AssertStatic``1(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IHostEnvironment,System.Func{Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext,``0})">
            <summary>
            Asserts that a given data view has the indicated schema. If this method returns without
            throwing then the view has been validated to have columns with the indicated names and types.
            </summary>
            <typeparam name="T">The type representing the view's schema shape</typeparam>
            <param name="view">The view to assert the static schema on</param>
            <param name="env">The host environment to keep in the statically typed variant</param>
            <param name="outputDecl">The delegate through which we declare the schema, which ought to
            use the input <see cref="T:Microsoft.ML.StaticPipe.Runtime.SchemaAssertionContext"/> to declare a <see cref="T:System.ValueTuple"/>
            of the <see cref="T:Microsoft.ML.StaticPipe.PipelineColumn"/> indices, properly named</param>
            <returns>A statically typed wrapping of the input view</returns>
        </member>
        <member name="T:Microsoft.ML.TrainContextBase">
            <summary>
            A training context is an object instantiable by a user to do various tasks relating to a particular
            "area" of machine learning. A subclass would represent a particular task in machine learning. The idea
            is that a user can instantiate that particular area, and get trainers and evaluators.
            </summary>
        </member>
        <member name="M:Microsoft.ML.TrainContextBase.TrainTestSplit(Microsoft.ML.Runtime.Data.IDataView,System.Double,System.String)">
            <summary>
            Split the dataset into the train set and test set according to the given fraction.
            Respects the <paramref name="stratificationColumn"/> if provided.
            </summary>
            <param name="data">The dataset to split.</param>
            <param name="testFraction">The fraction of data to go into the test set.</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>A pair of datasets, for the train and test set.</returns>
        </member>
        <member name="M:Microsoft.ML.TrainContextBase.CrossValidateTrain(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},System.Int32,System.String)">
            <summary>
            Train the <paramref name="estimator"/> on <paramref name="numFolds"/> folds of the data sequentially.
            Return each model and each scored test dataset.
            </summary>
        </member>
        <member name="M:Microsoft.ML.TrainContextBase.EnsureStratificationColumn(Microsoft.ML.Runtime.Data.IDataView@,System.String@)">
            <summary>
            Make sure the provided <paramref name="stratificationColumn"/> is valid
            for <see cref="T:Microsoft.ML.Runtime.Data.RangeFilter"/>, hash it if needed, or introduce a new one
            if needed.
            </summary>
        </member>
        <member name="T:Microsoft.ML.TrainContextBase.ContextInstantiatorBase">
            <summary>
            Subclasses of <see cref="T:Microsoft.ML.Runtime.TrainContext"/> will provide little "extension method" hookable objects
            (e.g., something like <see cref="P:Microsoft.ML.BinaryClassificationContext.Trainers"/>). User code will only
            interact with these objects by invoking the extension methods. The actual component code can work
            through <see cref="T:Microsoft.ML.TrainContextComponentUtils"/> to get more "hidden" information from this object,
            e.g., the environment.
            </summary>
        </member>
        <member name="T:Microsoft.ML.TrainContextComponentUtils">
            <summary>
            Utilities for component authors that want to be able to instantiate components using these context
            objects. These utilities are not hidden from non-component authoring users per see, but are at least
            registered somewhat less obvious so that they are not confused by the presence.
            </summary>
            <seealso cref="T:Microsoft.ML.TrainContextBase"/>
        </member>
        <member name="M:Microsoft.ML.TrainContextComponentUtils.GetEnvironment(Microsoft.ML.TrainContextBase.ContextInstantiatorBase)">
            <summary>
            Gets the environment hidden within the instantiator's context.
            </summary>
            <param name="obj">The extension method hook object for a context.</param>
            <returns>An environment that can be used when instantiating components.</returns>
        </member>
        <member name="M:Microsoft.ML.TrainContextComponentUtils.GetEnvironment(Microsoft.ML.TrainContextBase)">
            <summary>
            Gets the environment hidden within the context.
            </summary>
            <param name="ctx">The context.</param>
            <returns>An environment that can be used when instantiating components.</returns>
        </member>
        <member name="T:Microsoft.ML.BinaryClassificationContext">
            <summary>
            The central context for binary classification trainers.
            </summary>
        </member>
        <member name="P:Microsoft.ML.BinaryClassificationContext.Trainers">
            <summary>
            For trainers for performing binary classification.
            </summary>
        </member>
        <member name="M:Microsoft.ML.BinaryClassificationContext.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String,System.String)">
            <summary>
            Evaluates scored binary classification data.
            </summary>
            <param name="data">The scored data.</param>
            <param name="label">The name of the label column in <paramref name="data"/>.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="probability">The name of the probability column in <paramref name="data"/>, the calibrated version of <paramref name="score"/>.</param>
            <param name="predictedLabel">The name of the predicted label column in <paramref name="data"/>.</param>
            <returns>The evaluation results for these calibrated outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.BinaryClassificationContext.EvaluateNonCalibrated(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String)">
            <summary>
            Evaluates scored binary classification data, without probability-based metrics.
            </summary>
            <param name="data">The scored data.</param>
            <param name="label">The name of the label column in <paramref name="data"/>.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="predictedLabel">The name of the predicted label column in <paramref name="data"/>.</param>
            <returns>The evaluation results for these uncalibrated outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.BinaryClassificationContext.CrossValidateNonCalibrated(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},System.Int32,System.String,System.String)">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="labelColumn"/> and return metrics.
            </summary>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="labelColumn">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="M:Microsoft.ML.BinaryClassificationContext.CrossValidate(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},System.Int32,System.String,System.String)">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="labelColumn"/> and return metrics.
            </summary>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="labelColumn">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="T:Microsoft.ML.ClusteringContext">
            <summary>
            The central context for clustering trainers.
            </summary>
        </member>
        <member name="P:Microsoft.ML.ClusteringContext.Trainers">
            <summary>
            List of trainers for performing clustering.
            </summary>
        </member>
        <member name="M:Microsoft.ML.ClusteringContext.#ctor(Microsoft.ML.Runtime.IHostEnvironment)">
            <summary>
            The clustering context.
            </summary>
        </member>
        <member name="M:Microsoft.ML.ClusteringContext.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String)">
            <summary>
            Evaluates scored clustering data.
            </summary>
            <param name="data">The scored data.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="label">The name of the optional label column in <paramref name="data"/>.
            If present, the <see cref="P:Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result.Nmi"/> metric will be computed.</param>
            <param name="features">The name of the optional features column in <paramref name="data"/>.
            If present, the <see cref="P:Microsoft.ML.Runtime.Data.ClusteringEvaluator.Result.Dbi"/> metric will be computed.</param>
            <returns>The evaluation result.</returns>
        </member>
        <member name="T:Microsoft.ML.MulticlassClassificationContext">
            <summary>
            The central context for multiclass classification trainers.
            </summary>
        </member>
        <member name="P:Microsoft.ML.MulticlassClassificationContext.Trainers">
            <summary>
            For trainers for performing multiclass classification.
            </summary>
        </member>
        <member name="M:Microsoft.ML.MulticlassClassificationContext.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String,System.String,System.Int32)">
            <summary>
            Evaluates scored multiclass classification data.
            </summary>
            <param name="data">The scored data.</param>
            <param name="label">The name of the label column in <paramref name="data"/>.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <param name="predictedLabel">The name of the predicted label column in <paramref name="data"/>.</param>
            <param name="topK">If given a positive value, the <see cref="P:Microsoft.ML.Runtime.Data.MultiClassClassifierEvaluator.Result.TopKAccuracy"/> will be filled with
            the top-K accuracy, that is, the accuracy assuming we consider an example with the correct class within
            the top-K values as being stored "correctly."</param>
            <returns>The evaluation results for these calibrated outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.MulticlassClassificationContext.CrossValidate(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},System.Int32,System.String,System.String)">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="labelColumn"/> and return metrics.
            </summary>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="labelColumn">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="T:Microsoft.ML.RegressionContext">
            <summary>
            The central context for regression trainers.
            </summary>
        </member>
        <member name="P:Microsoft.ML.RegressionContext.Trainers">
            <summary>
            For trainers for performing regression.
            </summary>
        </member>
        <member name="M:Microsoft.ML.RegressionContext.Evaluate(Microsoft.ML.Runtime.Data.IDataView,System.String,System.String)">
            <summary>
            Evaluates scored regression data.
            </summary>
            <param name="data">The scored data.</param>
            <param name="label">The name of the label column in <paramref name="data"/>.</param>
            <param name="score">The name of the score column in <paramref name="data"/>.</param>
            <returns>The evaluation results for these calibrated outputs.</returns>
        </member>
        <member name="M:Microsoft.ML.RegressionContext.CrossValidate(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Core.Data.IEstimator{Microsoft.ML.Core.Data.ITransformer},System.Int32,System.String,System.String)">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="labelColumn"/> and return metrics.
            </summary>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="labelColumn">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="T:Microsoft.ML.Core.Prediction.TrainerEstimatorContext">
            <summary>
            Holds information relevant to trainers. It is passed to the constructor of the<see cref="T:Microsoft.ML.Runtime.Training.ITrainerEstimator`2"/>
            holding additional data needed to fit the estimator. The additional data can be a validation set or an initial model.
            This holds at least a training set, as well as optioonally a predictor.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Core.Prediction.TrainerEstimatorContext.ValidationSet">
            <summary>
            The validation set. Can be <c>null</c>. Note that passing a non-<c>null</c> validation set into
            a trainer that does not support validation sets should not be considered an error condition. It
            should simply be ignored in that case.
            </summary>
        </member>
        <member name="P:Microsoft.ML.Core.Prediction.TrainerEstimatorContext.InitialPredictor">
            <summary>
            The initial predictor, for incremental training. Note that if a <see cref="T:Microsoft.ML.Runtime.Training.ITrainerEstimator`2"/> implementor
            does not support incremental training, then it can ignore it similarly to how one would ignore
            <see cref="P:Microsoft.ML.Core.Prediction.TrainerEstimatorContext.ValidationSet"/>. However, if the trainer does support incremental training and there
            is something wrong with a non-<c>null</c> value of this, then the trainer ought to throw an exception.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Core.Prediction.TrainerEstimatorContext.#ctor(Microsoft.ML.Runtime.Data.IDataView,Microsoft.ML.Runtime.IPredictor)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.ML.Core.Prediction.TrainerEstimatorContext"/>, given a training set and optional other arguments.
            </summary>
            <param name="validationSet">Will set <see cref="P:Microsoft.ML.Core.Prediction.TrainerEstimatorContext.ValidationSet"/> to this value if specified</param>
            <param name="initialPredictor">Will set <see cref="P:Microsoft.ML.Core.Prediction.TrainerEstimatorContext.InitialPredictor"/> to this value if specified</param>
        </member>
        <member name="T:Microsoft.ML.TrainingStaticExtensions">
            <summary>
            Defines static extension methods that allow operations like train-test split, cross-validate,
            sampling etc. with the <see cref="T:Microsoft.ML.TrainContextBase"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ML.TrainingStaticExtensions.TrainTestSplit``1(Microsoft.ML.TrainContextBase,Microsoft.ML.StaticPipe.DataView{``0},System.Double,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})">
            <summary>
            Split the dataset into the train set and test set according to the given fraction.
            Respects the <paramref name="stratificationColumn"/> if provided.
            </summary>
            <typeparam name="T">The tuple describing the data schema.</typeparam>
            <param name="context">The training context.</param>
            <param name="data">The dataset to split.</param>
            <param name="testFraction">The fraction of data to go into the test set.</param>
            <param name="stratificationColumn">Optional selector for the stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>A pair of datasets, for the train and test set.</returns>
        </member>
        <member name="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.RegressionContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Single}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="label"/> and return metrics.
            </summary>
            <typeparam name="TInShape">The input schema shape.</typeparam>
            <typeparam name="TOutShape">The output schema shape.</typeparam>
            <typeparam name="TTransformer">The type of the trained model.</typeparam>
            <param name="context">The training context.</param>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="label">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.MulticlassClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Key{System.UInt32}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="label"/> and return metrics.
            </summary>
            <typeparam name="TInShape">The input schema shape.</typeparam>
            <typeparam name="TOutShape">The output schema shape.</typeparam>
            <typeparam name="TTransformer">The type of the trained model.</typeparam>
            <param name="context">The training context.</param>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="label">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="M:Microsoft.ML.TrainingStaticExtensions.CrossValidateNonCalibrated``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="label"/> and return metrics.
            </summary>
            <typeparam name="TInShape">The input schema shape.</typeparam>
            <typeparam name="TOutShape">The output schema shape.</typeparam>
            <typeparam name="TTransformer">The type of the trained model.</typeparam>
            <param name="context">The training context.</param>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="label">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="M:Microsoft.ML.TrainingStaticExtensions.CrossValidate``3(Microsoft.ML.BinaryClassificationContext,Microsoft.ML.StaticPipe.DataView{``0},Microsoft.ML.StaticPipe.Estimator{``0,``1,``2},System.Func{``1,Microsoft.ML.StaticPipe.Scalar{System.Boolean}},System.Int32,System.Func{``0,Microsoft.ML.StaticPipe.PipelineColumn})">
            <summary>
            Run cross-validation over <paramref name="numFolds"/> folds of <paramref name="data"/>, by fitting <paramref name="estimator"/>,
            and respecting <paramref name="stratificationColumn"/> if provided.
            Then evaluate each sub-model against <paramref name="label"/> and return metrics.
            </summary>
            <typeparam name="TInShape">The input schema shape.</typeparam>
            <typeparam name="TOutShape">The output schema shape.</typeparam>
            <typeparam name="TTransformer">The type of the trained model.</typeparam>
            <param name="context">The training context.</param>
            <param name="data">The data to run cross-validation on.</param>
            <param name="estimator">The estimator to fit.</param>
            <param name="numFolds">Number of cross-validation folds.</param>
            <param name="label">The label column (for evaluation).</param>
            <param name="stratificationColumn">Optional stratification column.</param>
            <remarks>If two examples share the same value of the <paramref name="stratificationColumn"/> (if provided),
            they are guaranteed to appear in the same subset (train or test). Use this to make sure there is no label leakage from
            train to the test set.</remarks>
            <returns>Per-fold results: metrics, models, scored datasets.</returns>
        </member>
        <member name="T:Microsoft.ML.Transforms.HashTransformer">
            <summary>
            This transform can hash either single valued columns or vector columns. For vector columns,
            it hashes each slot separately.
            It can hash either text values or key values.
            </summary>
        </member>
        <member name="M:Microsoft.ML.Transforms.HashTransformer.ColumnInfo.#ctor(System.String,System.String,System.Int32,System.UInt32,System.Boolean,System.Int32)">
            <summary>
            Describes how the transformer handles one column pair.
            </summary>
            <param name="input">Name of input column.</param>
            <param name="output">Name of output column.</param>
            <param name="hashBits">Number of bits to hash into. Must be between 1 and 31, inclusive.</param>
            <param name="seed">Hashing seed.</param>
            <param name="ordered">Whether the position of each term should be included in the hash.</param>
            <param name="invertHash">Limit the number of keys used to generate the slot name to this many. 0 means no invert hashing, -1 means no limit.</param>
        </member>
        <member name="M:Microsoft.ML.Transforms.HashTransformer.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Transforms.HashTransformer.ColumnInfo[])">
            <summary>
            Constructor for case where you don't need to 'train' transform on data, e.g. InvertHash for all columns set to zero.
            </summary>
            <param name="env">Host Environment.</param>
            <param name="columns">Description of dataset columns and how to process them.</param>
        </member>
        <member name="M:Microsoft.ML.Transforms.HashTransformer.InvertHashHelper.Create(Microsoft.ML.Runtime.Data.IRow,Microsoft.ML.Transforms.HashTransformer.ColumnInfo,System.Int32,System.Delegate)">
            <summary>
            Constructs an <see cref="T:Microsoft.ML.Transforms.HashTransformer.InvertHashHelper"/> instance to accumulate hash/value pairs
            from a single column as parameterized by this transform, with values fetched from
            the row.
            </summary>
            <param name="row">The input source row, from which the hashed values can be fetched</param>
            <param name="ex">The extra column info</param>
            <param name="invertHashMaxCount">The number of input hashed valuPres to accumulate per output hash value</param>
            <param name="dstGetter">A hash getter, built on top of <paramref name="row"/>.</param>
        </member>
        <member name="M:Microsoft.ML.Transforms.HashTransformer.InvertHashHelper.Process">
            <summary>
            This calculates the hash/value pair from the current value of the column, and does
            appropriate processing of them to build the invert hash map.
            </summary>
        </member>
        <member name="T:Microsoft.ML.Transforms.HashEstimator">
            <summary>
            Estimator for <see cref="T:Microsoft.ML.Transforms.HashTransformer"/>
            </summary>
        </member>
        <member name="M:Microsoft.ML.Transforms.HashEstimator.#ctor(Microsoft.ML.Runtime.IHostEnvironment,System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Convinence constructor for simple one column case
            </summary>
            <param name="env">Host Environment.</param>
            <param name="inputColumn">Name of the output column.</param>
            <param name="outputColumn">Name of the column to be transformed. If this is null '<paramref name="inputColumn"/>' will be used.</param>
            <param name="hashBits">Number of bits to hash into. Must be between 1 and 31, inclusive.</param>
            <param name="invertHash">Limit the number of keys used to generate the slot name to this many. 0 means no invert hashing, -1 means no limit.</param>
        </member>
        <member name="M:Microsoft.ML.Transforms.HashEstimator.#ctor(Microsoft.ML.Runtime.IHostEnvironment,Microsoft.ML.Transforms.HashTransformer.ColumnInfo[])">
            <param name="env">Host Environment.</param>
            <param name="columns">Description of dataset columns and how to process them.</param>
        </member>
    </members>
</doc>
